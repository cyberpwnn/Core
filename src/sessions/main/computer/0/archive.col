/rom/startup/@/`n-- Setup paths`nlocal sPath = ".:/rom/programs"`nif term.isColor() then`n	sPath = sPath..":/rom/programs/advanced"`nend`nif turtle then`n	sPath = sPath..":/rom/programs/turtle"`nelse`n    sPath = sPath..":/rom/programs/rednet:/rom/programs/fun"`n    if term.isColor() then`n    	sPath = sPath..":/rom/programs/fun/advanced"`n    end`nend`nif pocket then`n    sPath = sPath..":/rom/programs/pocket"`nend`nif http then`n	sPath = sPath..":/rom/programs/http"`nend`nshell.setPath( sPath )`nhelp.setPath( "/rom/help" )`n`n-- Setup aliases`nshell.setAlias( "ls", "list" )`nshell.setAlias( "dir", "list" )`nshell.setAlias( "cp", "copy" )`nshell.setAlias( "mv", "move" )`nshell.setAlias( "rm", "delete" )`nshell.setAlias( "clr", "clear" )`nshell.setAlias( "rs", "redstone" )`nshell.setAlias( "sh", "shell" )`nif term.isColor() then`n    shell.setAlias( "background", "bg" )`n    shell.setAlias( "foreground", "fg" )`nend`n`n-- Run autorun files`nif fs.exists( "/rom/autorun" ) and fs.isDir( "/rom/autorun" ) then`n	local tFiles = fs.list( "/rom/autorun" )`n	table.sort( tFiles )`n	for n, sFile in ipairs( tFiles ) do`n		if string.sub( sFile, 1, 1 ) ~= "." then`n			local sPath = "/rom/autorun/"..sFile`n			if not fs.isDir( sPath ) then`n				shell.run( sPath )`n			end`n		end`n	end`nend`n`n-- Run the user created startup, either from disk drives or the root`nlocal sUserStartup = shell.resolveProgram( "/startup" )`nfor n,sName in pairs( peripheral.getNames() ) do`n    if disk.isPresent( sName ) and disk.hasData( sName ) then`n        local sDiskStartup = shell.resolveProgram( "/" .. disk.getMountPath( sName ) .. "/startup" )`n        if sDiskStartup then`n            sUserStartup = sDiskStartup`n            break`n        end`n    end`nend`nif sUserStartup then`n    shell.run( sUserStartup )`nend`n`n/rom/apis/colors/@/-- Colors`nwhite = 1`norange = 2`nmagenta = 4`nlightBlue = 8`nyellow = 16`nlime = 32`npink = 64`ngray = 128`nlightGray = 256`ncyan = 512`npurple = 1024`nblue = 2048`nbrown = 4096`ngreen = 8192`nred = 16384`nblack = 32768`n`nfunction combine( ... )`n    local r = 0`n    for n,c in ipairs( { ... } ) do`n        r = bit.bor(r,c)`n    end`n    return r`nend`n`nfunction subtract( colors, ... )`n	local r = colors`n	for n,c in ipairs( { ... } ) do`n		r = bit.band(r, bit.bnot(c))`n	end`n	return r`nend`n`nfunction test( colors, color )`n    return ((bit.band(colors, color)) == color)`nend`n`n/rom/apis/colours/@/-- Colours (for lovers of british spelling)`nlocal fnFile, err = loadfile("/rom/apis/colors")`nif not fnFile then`n	error( err )`nend`n`nlocal tColors = {}`nsetmetatable( tColors, { __index = _G } )`nsetfenv( fnFile, tColors )`nfnFile( tColors )`n`nlocal tColours = getfenv()`nfor k,v in pairs( tColors ) do`n	tColours[k] = v`nend`n`ntColours.gray = nil`ntColours.grey = tColors.gray`n`ntColours.lightGray = nil`ntColours.lightGrey = tColors.lightGray`n`n/rom/apis/disk/@/`nlocal function isDrive( name )`n	return peripheral.getType( name ) == "drive"`nend`n`nfunction isPresent( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "isDiskPresent" )`n	end`n	return false`nend`n`nfunction getLabel( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "getDiskLabel" )`n	end`n	return nil`nend`n`nfunction setLabel( name, label )`n	if isDrive( name ) then`n		peripheral.call( name, "setDiskLabel", label )`n	end`nend`n`nfunction hasData( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "hasData" )`n	end`n	return false`nend`n`nfunction getMountPath( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "getMountPath" )`n	end`n	return nil`nend`n`nfunction hasAudio( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "hasAudio" )`n	end`n	return false`nend`n`nfunction getAudioTitle( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "getAudioTitle" )`n	end`n	return nil`nend`n`nfunction playAudio( name )`n	if isDrive( name ) then`n		peripheral.call( name, "playAudio" )`n	end`nend`n`nfunction stopAudio( name )`n	if not name then`n		for n,sName in ipairs( peripheral.getNames() ) do`n			stopAudio( sName )`n		end`n	else`n		if isDrive( name ) then`n			peripheral.call( name, "stopAudio" )`n		end`n	end`nend`n`nfunction eject( name )`n	if isDrive( name ) then`n		peripheral.call( name, "ejectDisk" )`n	end`nend`n`nfunction getID( name )`n	if isDrive( name ) then`n		return peripheral.call( name, "getDiskID" )`n	end`n	return nil`nend`n`n`n/rom/apis/gps/@/`nCHANNEL_GPS = 65534`n`nlocal function trilaterate( A, B, C )`n	local a2b = B.vPosition - A.vPosition`n	local a2c = C.vPosition - A.vPosition`n		`n	if math.abs( a2b:normalize():dot( a2c:normalize() ) ) > 0.999 then`n		return nil`n	end`n	`n	local d = a2b:length()`n	local ex = a2b:normalize( )`n	local i = ex:dot( a2c )`n	local ey = (a2c - (ex * i)):normalize()`n	local j = ey:dot( a2c )`n	local ez = ex:cross( ey )`n`n	local r1 = A.nDistance`n	local r2 = B.nDistance`n	local r3 = C.nDistance`n		`n	local x = (r1*r1 - r2*r2 + d*d) / (2*d)`n	local y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)`n		`n	local result = A.vPosition + (ex * x) + (ey * y)`n`n	local zSquared = r1*r1 - x*x - y*y`n	if zSquared > 0 then`n		local z = math.sqrt( zSquared )`n		local result1 = result + (ez * z)`n		local result2 = result - (ez * z)`n		`n		local rounded1, rounded2 = result1:round( 0.01 ), result2:round( 0.01 )`n		if rounded1.x ~= rounded2.x or rounded1.y ~= rounded2.y or rounded1.z ~= rounded2.z then`n			return rounded1, rounded2`n		else`n			return rounded1`n		end`n	end`n	return result:round( 0.01 )`n	`nend`n`nlocal function narrow( p1, p2, fix )`n	local dist1 = math.abs( (p1 - fix.vPosition):length() - fix.nDistance )`n	local dist2 = math.abs( (p2 - fix.vPosition):length() - fix.nDistance )`n	`n	if math.abs(dist1 - dist2) < 0.01 then`n		return p1, p2`n	elseif dist1 < dist2 then`n		return p1:round( 0.01 )`n	else`n		return p2:round( 0.01 )`n	end`nend`n`nfunction locate( _nTimeout, _bDebug )`n`n	-- Find a modem`n	local sModemSide = nil`n	for n,sSide in ipairs( rs.getSides() ) do`n		if peripheral.getType( sSide ) == "modem" and peripheral.call( sSide, "isWireless" ) then	`n			sModemSide = sSide`n			break`n		end`n	end`n`n	if sModemSide == nil then`n		if _bDebug then`n			print( "No wireless modem attached" )`n		end`n		return nil`n	end`n	`n	if _bDebug then`n		print( "Finding position..." )`n	end`n	`n	-- Open a channel`n	local modem = peripheral.wrap( sModemSide )`n	local bCloseChannel = false`n	if not modem.isOpen( os.getComputerID() ) then`n		modem.open( os.getComputerID() )`n		bCloseChannel = true`n	end`n	`n	-- Send a ping to listening GPS hosts`n	modem.transmit( CHANNEL_GPS, os.getComputerID(), "PING" )`n		`n	-- Wait for the responses`n	local tFixes = {}`n	local pos1, pos2 = nil, nil`n	local timeout = os.startTimer( _nTimeout or 2 )`n	while true do`n		local e, p1, p2, p3, p4, p5 = os.pullEvent()`n		if e == "modem_message" then`n			-- We received a message from a modem`n			local sSide, sChannel, sReplyChannel, tMessage, nDistance = p1, p2, p3, p4, p5`n			if sSide == sModemSide and sChannel == os.getComputerID() and sReplyChannel == CHANNEL_GPS then`n				-- Received the correct message from the correct modem: use it to determine position`n				if type(tMessage) == "table" and #tMessage == 3 then`n					local tFix = { vPosition = vector.new( tMessage[1], tMessage[2], tMessage[3] ), nDistance = nDistance }`n					if _bDebug then`n						print( tFix.nDistance.." metres from "..tostring( tFix.vPosition ) )`n					end`n					if tFix.nDistance == 0 then`n					    pos1, pos2 = tFix.vPosition, nil`n					else`n                        table.insert( tFixes, tFix )`n                        if #tFixes >= 3 then`n                            if not pos1 then`n                                pos1, pos2 = trilaterate( tFixes[1], tFixes[2], tFixes[#tFixes] )`n                            else`n                                pos1, pos2 = narrow( pos1, pos2, tFixes[#tFixes] )`n                            end`n                        end`n                    end`n					if pos1 and not pos2 then`n						break`n					end`n				end`n			end`n			`n		elseif e == "timer" then`n			-- We received a timeout`n			local timer = p1`n			if timer == timeout then`n				break`n			end`n		`n		end `n	end`n	`n	-- Close the channel, if we opened one`n	if bCloseChannel then`n		modem.close( os.getComputerID() )`n	end`n	`n	-- Return the response`n	if pos1 and pos2 then`n		if _bDebug then`n			print( "Ambiguous position" )`n			print( "Could be "..pos1.x..","..pos1.y..","..pos1.z.." or "..pos2.x..","..pos2.y..","..pos2.z )`n		end`n		return nil`n	elseif pos1 then`n		if _bDebug then`n			print( "Position is "..pos1.x..","..pos1.y..","..pos1.z )`n		end`n		return pos1.x, pos1.y, pos1.z`n	else`n		if _bDebug then`n			print( "Could not determine position" )`n		end`n		return nil`n	end`nend`n`n/rom/apis/help/@/`nlocal sPath = "/rom/help"`n`nfunction path()`n	return sPath`nend`n`nfunction setPath( _sPath )`n	sPath = _sPath`nend`n`nfunction lookup( _sTopic )`n 	-- Look on the path variable`n    for sPath in string.gmatch(sPath, "[^:]+") do`n    	sPath = fs.combine( sPath, _sTopic )`n    	if fs.exists( sPath ) and not fs.isDir( sPath ) then`n			return sPath`n    	end`n    end`n	`n	-- Not found`n	return nil`nend`n`nfunction topics()`n	local tItems = {}`n	`n	-- Add topics from the path`n    for sPath in string.gmatch(sPath, "[^:]+") do`n		if fs.isDir( sPath ) then`n			local tList = fs.list( sPath )`n			for n,sFile in pairs( tList ) do`n				if string.sub( sFile, 1, 1 ) ~= "." then`n					if not fs.isDir( fs.combine( sPath, sFile ) ) then`n						tItems[ sFile ] = true`n					end`n				end`n			end`n		end`n    end	`n`n	-- Sort and return`n	local tItemList = {}`n	for sItem, b in pairs( tItems ) do`n		table.insert( tItemList, sItem )`n	end`n	table.sort( tItemList )`n	return tItemList`nend`n`n/rom/apis/io/@/-- Definition for the IO API`n`nlocal g_defaultInput = {`n	bFileHandle = true,`n	bClosed = false,`n	close = function( self )`n	end,`n	read = function( self, _sFormat )`n		if _sFormat and _sFormat ~= "*l" then`n			error( "Unsupported format" )`n		end`n		return _G.read()`n	end,`n	lines = function( self )`n		return function()`n			return _G.read()`n		end`n	end,`n}`n`nlocal g_defaultOutput = {`n	bFileHandle = true,`n	bClosed = false,`n	close = function( self )`n	end,`n	write = function( self, _sText )`n		_G.write( _sText )`n	end,`n	flush = function( self )`n	end,`n}`n`nlocal g_currentInput = g_defaultInput`nlocal g_currentOutput = g_defaultOutput`n`nfunction close( _file )`n	(_file or g_currentOutput):close()`nend`n`nfunction flush()`n	g_currentOutput:flush()`nend`n`nfunction input( _arg )`n	if _G.type( _arg ) == "string" then`n		g_currentInput = open( _arg, "r" )`n	elseif _G.type( _arg ) == "table" then`n		g_currentInput = _arg`n	elseif _G.type( _arg ) == "nil" then`n		return g_currentInput`n	else`n		error( "Expected file name or file handle" )`n	end`nend`n`nfunction lines( _sFileName )`n	if _sFileName then`n		return open( _sFileName, "r" ):lines()`n	else`n		return g_currentInput:lines()`n	end`nend`n`nfunction open( _sPath, _sMode )`n	local sMode = _sMode or "r"`n	local file = fs.open( _sPath, sMode )`n	if not file then`n		return nil`n	end`n	`n	if sMode == "r"then`n		return {`n			bFileHandle = true,`n			bClosed = false,				`n			close = function( self )`n				file.close()`n				self.bClosed = true`n			end,`n			read = function( self, _sFormat )`n				local sFormat = _sFormat or "*l"`n				if sFormat == "*l" then`n					return file.readLine()`n				elseif sFormat == "*a" then`n					return file.readAll()`n				else`n					error( "Unsupported format" )`n				end`n				return nil`n			end,`n			lines = function( self )`n				return function()`n					local sLine = file.readLine()`n					if sLine == nil then`n						file.close()`n						self.bClosed = true`n					end`n					return sLine`n				end`n			end,`n		}`n	elseif sMode == "w" or sMode == "a" then`n		return {`n			bFileHandle = true,`n			bClosed = false,				`n			close = function( self )`n				file.close()`n				self.bClosed = true`n			end,`n			write = function( self, _sText )`n				file.write( _sText )`n			end,`n			flush = function( self )`n				file.flush()`n			end,`n		}`n	`n	elseif sMode == "rb" then`n		return {`n			bFileHandle = true,`n			bClosed = false,				`n			close = function( self )`n				file.close()`n				self.bClosed = true`n			end,`n			read = function( self )`n				return file.read()`n			end,`n		}`n		`n	elseif sMode == "wb" or sMode == "ab" then`n		return {`n			bFileHandle = true,`n			bClosed = false,				`n			close = function( self )`n				file.close()`n				self.bClosed = true`n			end,`n			write = function( self, _number )`n				file.write( _number )`n			end,`n			flush = function( self )`n				file.flush()`n			end,`n		}`n	`n	else`n		file.close()`n		error( "Unsupported mode" )`n		`n	end`nend`n`nfunction output( _arg )`n	if _G.type( _arg ) == "string" then`n		g_currentOutput = open( _arg, "w" )`n	elseif _G.type( _arg ) == "table" then`n		g_currentOutput = _arg`n	elseif _G.type( _arg ) == "nil" then`n		return g_currentOutput`n	else`n		error( "Expected file name or file handle" )`n	end`nend`n`nfunction read( ... )`n	return input():read( ... )`nend`n`nfunction type( _handle )`n	if _G.type( _handle ) == "table" and _handle.bFileHandle == true then`n		if _handle.bClosed then`n			return "closed file"`n		else`n			return "file"`n		end`n	end`n	return nil`nend`n`nfunction write( ... )`n	return output():write( ... )`nend`n`n/rom/apis/keys/@/`n-- Minecraft key code bindings`n-- See http://www.minecraftwiki.net/wiki/Key_codes for more info`n`nlocal nothing = 42`nlocal tKeys = {`n	nil,	 	"one", 		"two", 		"three", 	"four",			-- 1`n	"five", 	"six", 		"seven", 	"eight", 	"nine",			-- 6`n	"zero", 	"minus", 	"equals", 	"backspace","tab",			-- 11`n	"q", 		"w", 		"e", 		"r",		"t",			-- 16`n	"y",		"u",		"i",		"o",		"p",			-- 21`n	"leftBracket","rightBracket","enter","leftCtrl","a",			-- 26`n	"s",		"d",		"f",		"g",		"h",			-- 31`n	"j",		"k",		"l",		"semiColon","apostrophe",	-- 36`n	"grave",	"leftShift","backslash","z",		"x",			-- 41`n	"c",		"v",		"b",		"n",		"m",			-- 46`n	"comma",	"period",	"slash",	"rightShift","multiply",	-- 51`n	"leftAlt",	"space",	"capsLock",	"f1",		"f2",			-- 56`n	"f3",		"f4",		"f5",		"f6",		"f7",			-- 61`n	"f8",		"f9",		"f10",		"numLock",	"scollLock",	-- 66	`n	"numPad7",	"numPad8",	"numPad9",	"numPadSubtract","numPad4",	-- 71`n	"numPad5",	"numPad6",	"numPadAdd","numPad1",	"numPad2",		-- 76`n	"numPad3",	"numPad0",	"numPadDecimal",nil,	nil,			-- 81`n	nil,	 	"f11",		"f12",		nil,		nil,			-- 86`n	nil,		nil,		nil,		nil,		nil,			-- 91`n	nil,		nil,		nil,		nil,		"f13",			-- 96`n	"f14",		"f15",		nil,		nil,		nil,			-- 101`n	nil,		nil,		nil,		nil,		nil,			-- 106`n	nil,		"kana",		nil,		nil,		nil,			-- 111`n	nil,		nil,		nil,		nil,		nil,			-- 116	`n	"convert",	nil,		"noconvert",nil,		"yen",			-- 121`n	nil,		nil,		nil,		nil,		nil,			-- 126`n	nil,		nil,		nil,		nil,		nil,			-- 131`n	nil,		nil,		nil,		nil,		nil,			-- 136`n	"numPadEquals",nil,		nil,		"cimcumflex","at",			-- 141`n	"colon",	"underscore","kanji",	"stop",		"ax",			-- 146`n	nil,		"numPadEnter","rightCtrl",nil,		nil,			-- 151`n	nil,		nil,		nil,		nil,		nil,			-- 156`n	nil,		nil,		nil,		nil,		nil,			-- 161`n	nil,		nil,		nil,		nil,		nil,			-- 166`n	nil,		nil,		nil,		nil,		nil,			-- 171`n	nil,		nil,		nil,		"numPadComma",nil,			-- 176`n	"numPadDivide",nil,		nil,		"rightAlt",	nil,			-- 181`n	nil,		nil,		nil,		nil,		nil,			-- 186`n	nil,		nil,		nil,		nil,		nil,			-- 191`n	nil,		"pause",	nil,		"home",		"up",			-- 196`n	"pageUp",	nil,		"left",		nil,		"right",		-- 201`n	nil,		"end",		"down",		"pageDown",	"insert",		-- 206`n	"delete"														-- 211`n}`n`nlocal keys = getfenv()`nfor nKey, sKey in pairs( tKeys ) do`n	keys[sKey] = nKey`nend`nkeys["return"] = keys.enter`n`nfunction getName( _nKey )`n	return tKeys[ _nKey ]`nend`n`n/rom/apis/paintutils/@/`nlocal function drawPixelInternal( xPos, yPos )`n    term.setCursorPos( xPos, yPos )`n    term.write(" ")`nend`n`nlocal tColourLookup = {}`nfor n=1,16 do`n    tColourLookup[ string.byte( "0123456789abcdef",n,n ) ] = 2^(n-1)`nend`n`nfunction loadImage( sPath )`n    if type( sPath ) ~= "string" then`n        error( "Expected path", 2 )`n    end`n`n    local tImage = {}`n    if fs.exists( sPath ) then`n        local file = io.open(sPath, "r" )`n        local sLine = file:read()`n        while sLine do`n            local tLine = {}`n            for x=1,sLine:len() do`n                tLine[x] = tColourLookup[ string.byte(sLine,x,x) ] or 0`n            end`n            table.insert( tImage, tLine )`n            sLine = file:read()`n        end`n        file:close()`n        return tImage`n    end`n    return nil`nend`n`nfunction drawPixel( xPos, yPos, nColour )`n    if type( xPos ) ~= "number" or type( yPos ) ~= "number" or (nColour ~= nil and type( nColour ) ~= "number") then`n        error( "Expected x, y, colour", 2 )`n    end`n    if nColour then`n        term.setBackgroundColor( nColour )`n    end`n    drawPixelInternal( xPos, yPos )`nend`n`nfunction drawLine( startX, startY, endX, endY, nColour )`n    if type( startX ) ~= "number" or type( startX ) ~= "number" or`n       type( endX ) ~= "number" or type( endY ) ~= "number" or`n       (nColour ~= nil and type( nColour ) ~= "number") then`n        error( "Expected startX, startY, endX, endY, colour", 2 )`n    end`n    `n    startX = math.floor(startX)`n    startY = math.floor(startY)`n    endX = math.floor(endX)`n    endY = math.floor(endY)`n`n    if nColour then`n        term.setBackgroundColor( nColour )`n    end`n    if startX == endX and startY == endY then`n        drawPixelInternal( startX, startY )`n        return`n    end`n    `n    local minX = math.min( startX, endX )`n    if minX == startX then`n        minY = startY`n        maxX = endX`n        maxY = endY`n    else`n        minY = endY`n        maxX = startX`n        maxY = startY`n    end`n`n    -- TODO: clip to screen rectangle?`n        `n    local xDiff = maxX - minX`n    local yDiff = maxY - minY`n            `n    if xDiff > math.abs(yDiff) then`n        local y = minY`n        local dy = yDiff / xDiff`n        for x=minX,maxX do`n            drawPixelInternal( x, math.floor( y + 0.5 ) )`n            y = y + dy`n        end`n    else`n        local x = minX`n        local dx = xDiff / yDiff`n        if maxY >= minY then`n            for y=minY,maxY do`n                drawPixelInternal( math.floor( x + 0.5 ), y )`n                x = x + dx`n            end`n        else`n            for y=minY,maxY,-1 do`n                drawPixelInternal( math.floor( x + 0.5 ), y )`n                x = x - dx`n            end`n        end`n    end`nend`n`nfunction drawBox( startX, startY, endX, endY, nColour )`n    if type( startX ) ~= "number" or type( startX ) ~= "number" or`n       type( endX ) ~= "number" or type( endY ) ~= "number" or`n       (nColour ~= nil and type( nColour ) ~= "number") then`n        error( "Expected startX, startY, endX, endY, colour", 2 )`n    end`n`n    startX = math.floor(startX)`n    startY = math.floor(startY)`n    endX = math.floor(endX)`n    endY = math.floor(endY)`n`n    if nColour then`n        term.setBackgroundColor( nColour )`n    end`n    if startX == endX and startY == endY then`n        drawPixelInternal( startX, startY )`n        return`n    end`n`n    local minX = math.min( startX, endX )`n    if minX == startX then`n        minY = startY`n        maxX = endX`n        maxY = endY`n    else`n        minY = endY`n        maxX = startX`n        maxY = startY`n    end`n`n    for x=minX,maxX do`n        drawPixelInternal( x, minY )`n        drawPixelInternal( x, maxY )`n    end`n`n    if (maxY - minY) >= 2 then`n        for y=(minY+1),(maxY-1) do`n            drawPixelInternal( minX, y )`n            drawPixelInternal( maxX, y )`n        end`n    end`nend`n`nfunction drawFilledBox( startX, startY, endX, endY, nColour )`n    if type( startX ) ~= "number" or type( startX ) ~= "number" or`n       type( endX ) ~= "number" or type( endY ) ~= "number" or`n       (nColour ~= nil and type( nColour ) ~= "number") then`n        error( "Expected startX, startY, endX, endY, colour", 2 )`n    end`n`n    startX = math.floor(startX)`n    startY = math.floor(startY)`n    endX = math.floor(endX)`n    endY = math.floor(endY)`n`n    if nColour then`n        term.setBackgroundColor( nColour )`n    end`n    if startX == endX and startY == endY then`n        drawPixelInternal( startX, startY )`n        return`n    end`n`n    local minX = math.min( startX, endX )`n    if minX == startX then`n        minY = startY`n        maxX = endX`n        maxY = endY`n    else`n        minY = endY`n        maxX = startX`n        maxY = startY`n    end`n`n    for x=minX,maxX do`n        for y=minY,maxY do`n            drawPixelInternal( x, y )`n        end`n    end`nend`n`nfunction drawImage( tImage, xPos, yPos )`n    if type( tImage ) ~= "table" or type( xPos ) ~= "number" or type( yPos ) ~= "number" then`n        error( "Expected image, x, y", 2 )`n    end`n    for y=1,#tImage do`n        local tLine = tImage[y]`n        for x=1,#tLine do`n            if tLine[x] > 0 then`n                term.setBackgroundColor( tLine[x] )`n                drawPixelInternal( x + xPos - 1, y + yPos - 1 )`n            end`n        end`n    end`nend`n`n/rom/apis/parallel/@/`nlocal function create( first, ... )`n	if first ~= nil then`n	    if type( first ) ~= "function" then`n    		error( "Expected function, got "..type( first ), 3 )`n    	end`n 		return coroutine.create(first), create( ... )`n    end`n    return nil`nend`n`nlocal function runUntilLimit( _routines, _limit )`n    local count = #_routines`n    local living = count`n    `n    local tFilters = {}`n    local eventData = {}`n    while true do`n    	for n=1,count do`n    		local r = _routines[n]`n    		if r then`n    			if tFilters[r] == nil or tFilters[r] == eventData[1] or eventData[1] == "terminate" then`n	    			local ok, param = coroutine.resume( r, unpack(eventData) )`n					if not ok then`n						error( param, 0 )`n					else`n						tFilters[r] = param`n					end`n					if coroutine.status( r ) == "dead" then`n						_routines[n] = nil`n						living = living - 1`n						if living <= _limit then`n							return n`n						end`n					end`n				end`n    		end`n    	end`n		for n=1,count do`n    		local r = _routines[n]`n			if r and coroutine.status( r ) == "dead" then`n				_routines[n] = nil`n				living = living - 1`n				if living <= _limit then`n					return n`n				end`n			end`n		end`n    	eventData = { os.pullEventRaw() }`n    end`nend`n`nfunction waitForAny( ... )`n    local routines = { create( ... ) }`n    return runUntilLimit( routines, #routines - 1 )`nend`n`nfunction waitForAll( ... )`n    local routines = { create( ... ) }`n	runUntilLimit( routines, 0 )`nend`n`n/rom/apis/peripheral/@/local native = peripheral`n`nfunction getNames()`n	local tResults = {}`n	for n,sSide in ipairs( rs.getSides() ) do`n		if native.isPresent( sSide ) then`n			table.insert( tResults, sSide )`n			if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then`n				local tRemote = native.call( sSide, "getNamesRemote" )`n				for n,sName in ipairs( tRemote ) do`n					table.insert( tResults, sName )`n				end`n			end`n		end`n	end`n	return tResults`nend`n`nfunction isPresent( _sSide )`n    if type( _sSide ) ~= "string" then`n        error( "Expected string", 2 )`n    end`n	if native.isPresent( _sSide ) then`n		return true`n	end`n	for n,sSide in ipairs( rs.getSides() ) do`n		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then`n			if native.call( sSide, "isPresentRemote", _sSide )  then`n				return true`n			end`n		end`n	end`n	return false`nend`n`nfunction getType( _sSide )`n    if type( _sSide ) ~= "string" then`n        error( "Expected string", 2 )`n    end`n	if native.isPresent( _sSide ) then`n		return native.getType( _sSide )`n	end`n	for n,sSide in ipairs( rs.getSides() ) do`n		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then`n			if native.call( sSide, "isPresentRemote", _sSide )  then`n				return native.call( sSide, "getTypeRemote", _sSide ) `n			end`n		end`n	end`n	return nil`nend`n`nfunction getMethods( _sSide )`n    if type( _sSide ) ~= "string" then`n        error( "Expected string", 2 )`n    end`n	if native.isPresent( _sSide ) then`n		return native.getMethods( _sSide )`n	end`n	for n,sSide in ipairs( rs.getSides() ) do`n		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then`n			if native.call( sSide, "isPresentRemote", _sSide )  then`n				return native.call( sSide, "getMethodsRemote", _sSide ) `n			end`n		end`n	end`n	return nil`nend`n`nfunction call( _sSide, _sMethod, ... )`n    if type( _sSide ) ~= "string" or type( _sMethod ) ~= "string" then`n        error( "Expected string, string", 2 )`n    end`n	if native.isPresent( _sSide ) then`n		return native.call( _sSide, _sMethod, ... )`n	end`n	for n,sSide in ipairs( rs.getSides() ) do`n		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then`n			if native.call( sSide, "isPresentRemote", _sSide )  then`n				return native.call( sSide, "callRemote", _sSide, _sMethod, ... ) `n			end`n		end`n	end`n	return nil`nend`n`nfunction wrap( _sSide )`n    if type( _sSide ) ~= "string"  then`n        error( "Expected string", 2 )`n    end`n	if peripheral.isPresent( _sSide ) then`n		local tMethods = peripheral.getMethods( _sSide )`n		local tResult = {}`n		for n,sMethod in ipairs( tMethods ) do`n			tResult[sMethod] = function( ... )`n				return peripheral.call( _sSide, sMethod, ... )`n			end`n		end`n		return tResult`n	end`n	return nil`nend`n`nfunction find( sType, fnFilter )`n    if type( sType ) ~= "string" or (fnFilter ~= nil and type( fnFilter ) ~= "function") then`n        error( "Expected string, [function]", 2 )`n    end`n	local tResults = {}`n	for n,sName in ipairs( peripheral.getNames() ) do`n		if peripheral.getType( sName ) == sType then`n			local wrapped = peripheral.wrap( sName )`n			if fnFilter == nil or fnFilter( sName, wrapped ) then`n				table.insert( tResults, wrapped )`n			end`n		end`n	end`n	return unpack( tResults )`nend`n`n/rom/apis/rednet/@/`nCHANNEL_BROADCAST = 65535`nCHANNEL_REPEAT = 65533`n`nlocal tReceivedMessages = {}`nlocal tReceivedMessageTimeouts = {}`nlocal tHostnames = {}`n`nfunction open( sModem )`n	if type( sModem ) ~= "string" then`n		error( "expected string", 2 )`n	end`n	if peripheral.getType( sModem ) ~= "modem" then	`n		error( "No such modem: "..sModem, 2 )`n	end`n	peripheral.call( sModem, "open", os.getComputerID() )`n	peripheral.call( sModem, "open", CHANNEL_BROADCAST )`nend`n`nfunction close( sModem )`n    if sModem then`n        -- Close a specific modem`n        if type( sModem ) ~= "string" then`n            error( "expected string", 2 )`n        end`n        if peripheral.getType( sModem ) ~= "modem" then`n            error( "No such modem: "..sModem, 2 )`n        end`n        peripheral.call( sModem, "close", os.getComputerID() )`n        peripheral.call( sModem, "close", CHANNEL_BROADCAST )`n    else`n        -- Close all modems`n        for n,sModem in ipairs( peripheral.getNames() ) do`n            if isOpen( sModem ) then`n                close( sModem )`n            end`n        end`n    end`nend`n`nfunction isOpen( sModem )`n    if sModem then`n        -- Check if a specific modem is open`n        if type( sModem ) ~= "string" then`n            error( "expected string", 2 )`n        end`n        if peripheral.getType( sModem ) == "modem" then`n            return peripheral.call( sModem, "isOpen", os.getComputerID() ) and peripheral.call( sModem, "isOpen", CHANNEL_BROADCAST )`n        end`n    else`n        -- Check if any modem is open`n        for n,sModem in ipairs( peripheral.getNames() ) do`n            if isOpen( sModem ) then`n                return true`n            end`n        end`n    end`n	return false`nend`n`nfunction send( nRecipient, message, sProtocol )`n    -- Generate a (probably) unique message ID`n    -- We could do other things to guarantee uniqueness, but we really don't need to`n    -- Store it to ensure we don't get our own messages back`n    local nMessageID = math.random( 1, 2147483647 )`n    tReceivedMessages[ nMessageID ] = true`n    tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID`n`n    -- Create the message`n    local nReplyChannel = os.getComputerID()`n    local tMessage = {`n        nMessageID = nMessageID,`n        nRecipient = nRecipient,`n        message = message,`n        sProtocol = sProtocol,`n    }`n`n    if nRecipient == os.getComputerID() then`n        -- Loopback to ourselves`n        os.queueEvent( "rednet_message", nReplyChannel, message, sProtocol )`n`n    else`n        -- Send on all open modems, to the target and to repeaters`n        local sent = false`n        for n,sModem in ipairs( peripheral.getNames() ) do`n            if isOpen( sModem ) then`n                peripheral.call( sModem, "transmit", nRecipient, nReplyChannel, tMessage );`n                peripheral.call( sModem, "transmit", CHANNEL_REPEAT, nReplyChannel, tMessage );`n                sent = true`n            end`n        end`n    end`nend`n`nfunction broadcast( message, sProtocol )`n	send( CHANNEL_BROADCAST, message, sProtocol )`nend`n`nfunction receive( sProtocolFilter, nTimeout )`n    -- The parameters used to be ( nTimeout ), detect this case for backwards compatibility`n    if type(sProtocolFilter) == "number" and nTimeout == nil then`n        sProtocolFilter, nTimeout = nil, sProtocolFilter`n    end`n`n    -- Start the timer`n	local timer = nil`n	local sFilter = nil`n	if nTimeout then`n		timer = os.startTimer( nTimeout )`n		sFilter = nil`n	else`n		sFilter = "rednet_message"`n	end`n`n	-- Wait for events`n	while true do`n		local sEvent, p1, p2, p3 = os.pullEvent( sFilter )`n		if sEvent == "rednet_message" then`n		    -- Return the first matching rednet_message`n			local nSenderID, message, sProtocol = p1, p2, p3`n			if sProtocolFilter == nil or sProtocol == sProtocolFilter then`n    			return nSenderID, message, sProtocol`n    	    end`n		elseif sEvent == "timer" then`n		    -- Return nil if we timeout`n		    if p1 == timer then`n    			return nil`n    		end`n		end`n	end`nend`n`nfunction host( sProtocol, sHostname )`n    if type( sProtocol ) ~= "string" or type( sHostname ) ~= "string" then`n        error( "expected string, string", 2 )`n    end`n    if sHostname == "localhost" then`n        error( "Reserved hostname", 2 )`n    end`n    if tHostnames[ sProtocol ] ~= sHostname then`n        if lookup( sProtocol, sHostname ) ~= nil then`n            error( "Hostname in use", 2 )`n        end`n        tHostnames[ sProtocol ] = sHostname`n    end`nend`n`nfunction unhost( sProtocol )`n    if type( sProtocol ) ~= "string" then`n        error( "expected string", 2 )`n    end`n    tHostnames[ sProtocol ] = nil`nend`n`nfunction lookup( sProtocol, sHostname )`n    if type( sProtocol ) ~= "string" then`n        error( "expected string", 2 )`n    end`n`n    -- Build list of host IDs`n    local tResults = nil`n    if sHostname == nil then`n        tResults = {}`n    end`n`n    -- Check localhost first`n    if tHostnames[ sProtocol ] then`n        if sHostname == nil then`n            table.insert( tResults, os.getComputerID() )`n        elseif sHostname == "localhost" or sHostname == tHostnames[ sProtocol ] then`n            return os.getComputerID()`n        end`n    end`n`n    if not isOpen() then`n        if tResults then`n            return unpack( tResults )`n        end`n        return nil`n    end`n`n    -- Broadcast a lookup packet`n    broadcast( {`n        sType = "lookup",`n        sProtocol = sProtocol,`n        sHostname = sHostname,`n    }, "dns" )`n`n    -- Start a timer`n    local timer = os.startTimer( 2 )`n`n    -- Wait for events`n    while true do`n        local event, p1, p2, p3 = os.pullEvent()`n        if event == "rednet_message" then`n            -- Got a rednet message, check if it's the response to our request`n            local nSenderID, tMessage, sMessageProtocol = p1, p2, p3`n            if sMessageProtocol == "dns" and tMessage.sType == "lookup response" then`n                if tMessage.sProtocol == sProtocol then`n                    if sHostname == nil then`n                        table.insert( tResults, nSenderID )`n                    elseif tMessage.sHostname == sHostname then`n                        return nSenderID`n                    end`n                end`n            end`n        else`n            -- Got a timer event, check it's the end of our timeout`n            if p1 == timer then`n                break`n            end`n        end`n    end`n    if tResults then`n        return unpack( tResults )`n    end`n    return nil`nend`n`nlocal bRunning = false`nfunction run()`n	if bRunning then`n		error( "rednet is already running", 2 )`n	end`n	bRunning = true`n	`n	while bRunning do`n		local sEvent, p1, p2, p3, p4 = os.pullEventRaw()`n		if sEvent == "modem_message" then`n			-- Got a modem message, process it and add it to the rednet event queue`n    		local sModem, nChannel, nReplyChannel, tMessage = p1, p2, p3, p4`n		    if isOpen( sModem ) and ( nChannel == os.getComputerID() or nChannel == CHANNEL_BROADCAST ) then`n    			if type( tMessage ) == "table" and tMessage.nMessageID then`n	    			if not tReceivedMessages[ tMessage.nMessageID ] then`n		    			tReceivedMessages[ tMessage.nMessageID ] = true`n                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID`n			    		os.queueEvent( "rednet_message", nReplyChannel, tMessage.message, tMessage.sProtocol )`n				    end`n			    end`n			end`n`n		elseif sEvent == "rednet_message" then`n		    -- Got a rednet message (queued from above), respond to dns lookup`n		    local nSenderID, tMessage, sProtocol = p1, p2, p3`n		    if sProtocol == "dns" and tMessage.sType == "lookup" then`n		        local sHostname = tHostnames[ tMessage.sProtocol ]`n		        if sHostname ~= nil and (tMessage.sHostname == nil or tMessage.sHostname == sHostname) then`n		            rednet.send( nSenderID, {`n		                sType = "lookup response",`n		                sHostname = sHostname,`n		                sProtocol = tMessage.sProtocol,`n		            }, "dns" )`n		        end`n		    end`n`n		elseif sEvent == "timer" then`n            -- Got a timer event, use it to clear the event queue`n            local nTimer = p1`n            local nMessage = tReceivedMessageTimeouts[ nTimer ]`n            if nMessage then`n                tReceivedMessageTimeouts[ nTimer ] = nil`n                tReceivedMessages[ nMessage ] = nil`n            end`n		end`n	end`nend`n`n/rom/apis/term/@/`nlocal native = (term.native and term.native()) or term`nlocal redirectTarget = native`n`nlocal function wrap( _sFunction )`n	return function( ... )`n		return redirectTarget[ _sFunction ]( ... )`n	end`nend`n`nlocal term = {}`n`nterm.redirect = function( target )`n	if target == nil or type( target ) ~= "table" then`n		error( "Invalid redirect target", 2 )`n	end`n    if target == term then`n        error( "term is not a recommended redirect target, try term.current() instead", 2 )`n    end`n	for k,v in pairs( native ) do`n		if type( k ) == "string" and type( v ) == "function" then`n			if type( target[k] ) ~= "function" then`n				target[k] = function()`n					error( "Redirect object is missing method "..k..".", 2 )`n				end`n			end`n		end`n	end`n	local oldRedirectTarget = redirectTarget`n	redirectTarget = target`n	return oldRedirectTarget`nend`n`nterm.current = function()`n    return redirectTarget`nend`n`nterm.native = function()`n    -- NOTE: please don't use this function unless you have to.`n    -- If you're running in a redirected or multitasked enviorment, term.native() will NOT be`n    -- the current terminal when your program starts up. It is far better to use term.current()`n    return native`nend`n`nfor k,v in pairs( native ) do`n	if type( k ) == "string" and type( v ) == "function" then`n		if term[k] == nil then`n			term[k] = wrap( k )`n		end`n	end`nend`n	`nlocal env = getfenv()`nfor k,v in pairs( term ) do`n	env[k] = v`nend`n`n/rom/apis/textutils/@/`nfunction slowWrite( sText, nRate )`n    nRate = nRate or 20`n    if nRate < 0 then`n        error( "Rate must be positive", 2 )`n    end`n    local nSleep = 1 / nRate`n        `n    sText = tostring( sText )`n    local x,y = term.getCursorPos(x,y)`n    local len = string.len( sText )`n    `n    for n=1,len do`n        term.setCursorPos( x, y )`n        sleep( nSleep )`n        local nLines = write( string.sub( sText, 1, n ) )`n        local newX, newY = term.getCursorPos()`n        y = newY - nLines`n    end`nend`n`nfunction slowPrint( sText, nRate )`n    slowWrite( sText, nRate)`n    print()`nend`n`nfunction formatTime( nTime, bTwentyFourHour )`n    local sTOD = nil`n    if not bTwentyFourHour then`n        if nTime >= 12 then`n            sTOD = "PM"`n        else`n            sTOD = "AM"`n        end`n        if nTime >= 13 then`n            nTime = nTime - 12`n        end`n    end`n`n    local nHour = math.floor(nTime)`n    local nMinute = math.floor((nTime - nHour)*60)`n    if sTOD then`n        return string.format( "%d:%02d %s", nHour, nMinute, sTOD )`n    else`n        return string.format( "%d:%02d", nHour, nMinute )`n    end`nend`n`nlocal function makePagedScroll( _term, _nFreeLines )`n    local nativeScroll = _term.scroll`n    local nFreeLines = _nFreeLines or 0`n    return function( _n )`n        for n=1,_n do`n            nativeScroll( 1 )`n            `n            if nFreeLines <= 0 then`n                local w,h = _term.getSize()`n                _term.setCursorPos( 1, h )`n                _term.write( "Press any key to continue" )`n                os.pullEvent( "key" )`n                _term.clearLine()`n                _term.setCursorPos( 1, h )`n            else`n                nFreeLines = nFreeLines - 1`n            end`n        end`n    end`nend`n`nfunction pagedPrint( _sText, _nFreeLines )`n    -- Setup a redirector`n    local oldTerm = term.current()`n    local newTerm = {}`n    for k,v in pairs( oldTerm ) do`n        newTerm[k] = v`n    end`n    newTerm.scroll = makePagedScroll( oldTerm, _nFreeLines )`n    term.redirect( newTerm )`n`n    -- Print the text`n    local result`n    local ok, err = pcall( function()`n        result = print( _sText )`n    end )`n`n    -- Removed the redirector`n    term.redirect( oldTerm )`n`n    -- Propogate errors`n    if not ok then`n        error( err, 0 )`n    end`n    return result`nend`n`nlocal function tabulateCommon( bPaged, ... )`n    local tAll = { ... }`n    `n    local w,h = term.getSize()`n    local nMaxLen = w / 8`n    for n, t in ipairs( tAll ) do`n        if type(t) == "table" then`n            for n, sItem in pairs(t) do`n                nMaxLen = math.max( string.len( sItem ) + 1, nMaxLen )`n            end`n        end`n    end`n    local nCols = math.floor( w / nMaxLen )`n    local nLines = 0`n    local function newLine()`n        if bPaged and nLines >= (h-3) then`n            pagedPrint()`n        else`n            print()`n        end`n        nLines = nLines + 1`n    end`n    `n    local function drawCols( _t )`n        local nCol = 1`n        for n, s in ipairs( _t ) do`n            if nCol > nCols then`n                nCol = 1`n                newLine()`n            end`n`n            local cx, cy = term.getCursorPos()`n            cx = 1 + ((nCol - 1) * nMaxLen)`n            term.setCursorPos( cx, cy )`n            term.write( s )`n`n            nCol = nCol + 1      `n        end`n        print()`n    end`n    for n, t in ipairs( tAll ) do`n        if type(t) == "table" then`n            if #t > 0 then`n                drawCols( t )`n            end`n        elseif type(t) == "number" then`n            term.setTextColor( t )`n        end`n    end    `nend`n`nfunction tabulate( ... )`n    tabulateCommon( false, ... )`nend`n`nfunction pagedTabulate( ... )`n    tabulateCommon( true, ... )`nend`n`nlocal function serializeImpl( t, tTracking, sIndent )`n    local sType = type(t)`n    if sType == "table" then`n        if tTracking[t] ~= nil then`n            error( "Cannot serialize table with recursive entries", 0 )`n        end`n        tTracking[t] = true`n`n        if next(t) == nil then`n            -- Empty tables are simple`n            return "{}"`n        else`n            -- Other tables take more work`n            local sResult = "{\n"`n            local sSubIndent = sIndent .. "  "`n            local tSeen = {}`n            for k,v in ipairs(t) do`n                tSeen[k] = true`n                sResult = sResult .. sSubIndent .. serializeImpl( v, tTracking, sSubIndent ) .. ",\n"`n            end`n            for k,v in pairs(t) do`n                if not tSeen[k] then`n                    local sEntry`n                    if type(k) == "string" and string.match( k, "^[%a_][%a%d_]*$" ) then`n                        sEntry = k .. " = " .. serializeImpl( v, tTracking, sSubIndent ) .. ",\n"`n                    else`n                        sEntry = "[ " .. serializeImpl( k, tTracking, sSubIndent ) .. " ] = " .. serializeImpl( v, tTracking, sSubIndent ) .. ",\n"`n                    end`n                    sResult = sResult .. sSubIndent .. sEntry`n                end`n            end`n            sResult = sResult .. sIndent .. "}"`n            return sResult`n        end`n        `n    elseif sType == "string" then`n        return string.format( "%q", t )`n    `n    elseif sType == "number" or sType == "boolean" or sType == "nil" then`n        return tostring(t)`n        `n    else`n        error( "Cannot serialize type "..sType, 0 )`n        `n    end`nend`n`nfunction serialize( t )`n    local tTracking = {}`n    return serializeImpl( t, tTracking, "" )`nend`n`nfunction unserialize( s )`n    local func = loadstring( "return "..s, "unserialize" )`n    if func then`n        setfenv( func, {} )`n        local ok, result = pcall( func )`n        if ok then`n            return result`n        end`n    end`n    return nil`nend`n`nfunction urlEncode( str )`n    if str then`n        str = string.gsub(str, "\n", "\r\n")`n        str = string.gsub(str, "([^%w ])", function(c)`n            return string.format("%%%02X", string.byte(c))`n        end )`n        str = string.gsub(str, " ", "+")`n    end`n    return str    `nend`n`n-- GB versions`nserialise = serialize`nunserialise = unserialize`n`n/rom/apis/vector/@/`nlocal vector = {`n	add = function( self, o )`n		return vector.new(`n			self.x + o.x,`n			self.y + o.y,`n			self.z + o.z`n		)`n	end,`n	sub = function( self, o )`n		return vector.new(`n			self.x - o.x,`n			self.y - o.y,`n			self.z - o.z`n		)`n	end,`n	mul = function( self, m )`n		return vector.new(`n			self.x * m,`n			self.y * m,`n			self.z * m`n		)`n	end,`n	dot = function( self, o )`n		return self.x*o.x + self.y*o.y + self.z*o.z`n	end,`n	cross = function( self, o )`n		return vector.new(`n			self.y*o.z - self.z*o.y,`n			self.z*o.x - self.x*o.z,`n			self.x*o.y - self.y*o.x`n		)`n	end,`n	length = function( self )`n		return math.sqrt( self.x*self.x + self.y*self.y + self.z*self.z )`n	end,`n	normalize = function( self )`n		return self:mul( 1 / self:length() )`n	end,`n	round = function( self, nTolerance )`n	    nTolerance = nTolerance or 1.0`n		return vector.new(`n			math.floor( (self.x + (nTolerance * 0.5)) / nTolerance ) * nTolerance,`n			math.floor( (self.y + (nTolerance * 0.5)) / nTolerance ) * nTolerance,`n			math.floor( (self.z + (nTolerance * 0.5)) / nTolerance ) * nTolerance`n		)`n	end,`n	tostring = function( self )`n		return self.x..","..self.y..","..self.z`n	end,`n}`n`nlocal vmetatable = {`n	__index = vector,`n	__add = vector.add,`n	__sub = vector.sub,`n	__mul = vector.mul,`n	__unm = function( v ) return v:mul(-1) end,`n	__tostring = vector.tostring,`n}`n`nfunction new( x, y, z )`n	local v = {`n		x = x or 0,`n		y = y or 0,`n		z = z or 0`n	}`n	setmetatable( v, vmetatable )`n	return v`nend`n`n/rom/apis/window/@/`nfunction create( parent, nX, nY, nWidth, nHeight, bStartVisible )`n`n    if type( parent ) ~= "table" or`n       type( nX ) ~= "number" or`n       type( nY ) ~= "number" or`n       type( nWidth ) ~= "number" or`n       type( nHeight ) ~= "number" or`n       (bStartVisible ~= nil and type( bStartVisible ) ~= "boolean") then`n        error( "Expected object, number, number, number, number, [boolean]", 2 )`n    end`n`n    if parent == term then`n        error( "term is not a recommended window parent, try term.current() instead", 2 )`n    end`n`n    -- Setup`n    local bVisible = (bStartVisible ~= false)`n    local nCursorX = 1`n    local nCursorY = 1`n    local bCursorBlink = false`n    local nTextColor = colors.white`n    local nBackgroundColor = colors.black`n    local sEmpty = string.rep( " ", nWidth )`n    local tLines = {}`n    do`n        local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }`n        for y=1,nHeight do`n            tLines[y] = tEmpty`n        end`n    end`n`n    -- Helper functions`n    local function updateCursorPos()`n        if nCursorX >= 1 and nCursorY >= 1 and`n           nCursorX <= nWidth and nCursorY <= nHeight then`n            parent.setCursorPos( nX + nCursorX - 1, nY + nCursorY - 1 )`n        else`n            parent.setCursorPos( 0, 0 )`n        end`n    end`n    `n    local function updateCursorBlink()`n        parent.setCursorBlink( bCursorBlink )`n    end`n    `n    local function updateCursorColor()`n        parent.setTextColor( nTextColor )`n    end`n    `n    local function redrawLine( n )`n        parent.setCursorPos( nX, nY + n - 1 )`n        local tLine = tLines[ n ]`n        for m=1,#tLine do`n            local tBit = tLine[ m ]`n            parent.setTextColor( tBit[2] )`n            parent.setBackgroundColor( tBit[3] )`n            parent.write( tBit[1] )`n        end`n    end`n`n    local function lineLen( tLine )`n        local nLength = 0`n        for n=1,#tLine do`n            nLength = nLength + string.len( tLine[n][1] )`n        end`n        return nLength`n    end`n`n    local function lineSub( tLine, nStart, nEnd )`n        --assert( math.floor(nStart) == nStart )`n        --assert( math.floor(nEnd) == nEnd )`n        --assert( nStart >= 1 )`n        --assert( nEnd >= nStart )`n        --assert( nEnd <= lineLen( tLine ) )`n        local tSubLine = {}`n        local nBitStart = 1`n        for n=1,#tLine do`n            local tBit = tLine[n]`n            local sBit = tBit[1]`n            local nBitEnd = nBitStart + string.len( sBit ) - 1`n            if nBitEnd >= nStart and nBitStart <= nEnd then`n                if nBitStart >= nStart and nBitEnd <= nEnd then`n                    -- Include bit wholesale`n                    table.insert( tSubLine, tBit )`n                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )`n                elseif nBitStart < nStart and nBitEnd <= nEnd then`n                    -- Include end of bit`n                    table.insert( tSubLine, {`n                        string.sub( sBit, nStart - nBitStart + 1 ),`n                        tBit[2], tBit[3]`n                    } )`n                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )`n                elseif nBitStart >= nStart and nBitEnd > nEnd then`n                    -- Include beginning of bit`n                    table.insert( tSubLine, {`n                        string.sub( sBit, 1, nEnd - nBitStart + 1 ),`n                        tBit[2], tBit[3]`n                    } )`n                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )`n                else`n                    -- Include middle of bit`n                    table.insert( tSubLine, {`n                        string.sub( sBit, nStart - nBitStart + 1, nEnd - nBitStart + 1 ),`n                        tBit[2], tBit[3]`n                    } )`n                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )`n                end`n            end`n            nBitStart = nBitEnd + 1`n        end`n        --assert( lineLen( tSubLine ) == (nEnd - nStart + 1) )`n        return tSubLine`n    end`n`n    local function lineJoin( tLine1, tLine2 )`n        local tNewLine = {}`n        if tLine1[#tLine1][2] == tLine2[1][2] and`n           tLine1[#tLine1][3] == tLine2[1][3] then`n            -- Merge middle bits`n            for n=1,#tLine1-1 do`n                table.insert( tNewLine, tLine1[n] )`n            end`n            table.insert( tNewLine, {`n                tLine1[#tLine1][1] .. tLine2[1][1],`n                tLine2[1][2], tLine2[1][3]`n            } )`n            for n=2,#tLine2 do`n                table.insert( tNewLine, tLine2[n] )`n            end`n            --assert( lineLen( tNewLine ) == lineLen(tLine1) + lineLen(tLine2) )`n        else`n            -- Just concatenate`n            for n=1,#tLine1 do`n                table.insert( tNewLine, tLine1[n] )`n            end`n            for n=1,#tLine2 do`n                table.insert( tNewLine, tLine2[n] )`n            end`n            --assert( lineLen( tNewLine ) == lineLen(tLine1) + lineLen(tLine2) )`n        end`n        return tNewLine`n    end`n`n    local function redraw()`n        for n=1,nHeight do`n            redrawLine( n )`n        end`n    end`n`n    local window = {}`n`n    -- Terminal implementation`n    function window.write( sText )`n        local nLen = string.len( sText )`n        local nStart = nCursorX`n        local nEnd = nStart + nLen - 1`n        if nCursorY >= 1 and nCursorY <= nHeight then`n            -- Work out where to put new line`n            --assert( math.floor(nStart) == nStart )`n            --assert( math.floor(nEnd) == nEnd )`n            if nStart <= nWidth and nEnd >= 1 then`n                -- Construct new line`n                local tLine = tLines[ nCursorY ]`n                if nStart == 1 and nEnd == nWidth then`n                    -- Exactly replace line`n                    tLine = {`n                        { sText, nTextColor, nBackgroundColor }`n                    }`n                    --assert( lineLen( tLine ) == nWidth )`n                elseif nStart <= 1 and nEnd >= nWidth then`n                    -- Overwrite line with subset`n                    tLine = {`n                        { string.sub( sText, 1 - nStart + 1, nWidth - nStart + 1 ), nTextColor, nBackgroundColor }`n                    }`n                    --assert( lineLen( tLine ) == nWidth )`n                elseif nStart <= 1 then`n                    -- Overwrite beginning of line`n                    tLine = lineJoin(`n                        { { string.sub( sText, 1 - nStart + 1 ), nTextColor, nBackgroundColor } },`n                        lineSub( tLine, nEnd + 1, nWidth )`n                    )`n                    --assert( lineLen( tLine ) == nWidth )`n                elseif nEnd >= nWidth then`n                    -- Overwrite end of line`n                    tLine = lineJoin(`n                        lineSub( tLine, 1, nStart - 1 ),`n                        { { string.sub( sText, 1, nWidth - nStart + 1 ), nTextColor, nBackgroundColor } }`n                    )`n                    --assert( lineLen( tLine ) == nWidth )`n                else`n                    -- Overwrite middle of line`n                    tLine = lineJoin(`n                        lineJoin(`n                            lineSub( tLine, 1, nStart - 1 ),`n                            { { sText, nTextColor, nBackgroundColor } }`n                        ),`n                        lineSub( tLine, nEnd + 1, nWidth )`n                    )`n                    --assert( lineLen( tLine ) == nWidth )`n                end`n`n                -- Store and redraw new line`n                tLines[ nCursorY ] = tLine`n                if bVisible then`n                    redrawLine( nCursorY )`n                end`n            end`n        end`n`n        -- Move and redraw cursor`n        nCursorX = nEnd + 1`n        if bVisible then`n            updateCursorColor()`n            updateCursorPos()`n        end`n    end`n`n    function window.clear()`n        local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }`n        for y=1,nHeight do`n            tLines[y] = tEmpty`n        end`n        if bVisible then`n            redraw()`n            updateCursorColor()`n            updateCursorPos()`n        end`n    end`n`n    function window.clearLine()`n        if nCursorY >= 1 and nCursorY <= nHeight then`n            tLines[ nCursorY ] = { { sEmpty, nTextColor, nBackgroundColor } }`n            if bVisible then`n                redrawLine( nCursorY )`n                updateCursorColor()`n                updateCursorPos()`n            end`n        end`n    end`n`n    function window.getCursorPos()`n        return nCursorX, nCursorY`n    end`n`n    function window.setCursorPos( x, y )`n        nCursorX = math.floor( x )`n        nCursorY = math.floor( y )`n        if bVisible then`n            updateCursorPos()`n        end`n    end`n`n    function window.setCursorBlink( blink )`n        bCursorBlink = blink`n        if bVisible then`n            updateCursorBlink()`n        end`n    end`n`n    function window.isColor()`n        return parent.isColor()`n    end`n`n    function window.isColour()`n        return parent.isColor()`n    end`n`n    local function setTextColor( color )`n        if not parent.isColor() then`n            if color ~= colors.white and color ~= colors.black then`n                error( "Colour not supported", 3 )`n            end`n        end`n        nTextColor = color`n        if bVisible then`n            updateCursorColor()`n        end`n    end`n`n    function window.setTextColor( color )`n        setTextColor( color )`n    end`n`n    function window.setTextColour( color )`n        setTextColor( color )`n    end`n`n    local function setBackgroundColor( color )`n        if not parent.isColor() then`n            if color ~= colors.white and color ~= colors.black then`n                error( "Colour not supported", 3 )`n            end`n        end`n        nBackgroundColor = color`n    end`n`n    function window.setBackgroundColor( color )`n        setBackgroundColor( color )`n    end`n`n    function window.setBackgroundColour( color )`n        setBackgroundColor( color )`n    end`n`n    function window.getSize()`n        return nWidth, nHeight`n    end`n`n    function window.scroll( n )`n        if n ~= 0 then`n            local tNewLines = {}`n            local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }`n            for newY=1,nHeight do`n                local y = newY + n`n                if y >= 1 and y <= nHeight then`n                    tNewLines[newY] = tLines[y]`n                else`n                    tNewLines[newY] = tEmpty`n                end`n            end`n            tLines = tNewLines`n            if bVisible then`n                redraw()`n                updateCursorColor()`n                updateCursorPos()`n            end`n        end`n    end`n`n    -- Other functions`n    function window.setVisible( bVis )`n        if bVisible ~= bVis then`n            bVisible = bVis`n            if bVisible then`n                window.redraw()`n            end`n        end`n    end`n`n    function window.redraw()`n        if bVisible then`n            redraw()`n            updateCursorBlink()`n            updateCursorColor()`n            updateCursorPos()`n        end`n    end`n`n    function window.restoreCursor()`n        if bVisible then`n            updateCursorBlink()`n            updateCursorColor()`n            updateCursorPos()`n        end`n    end`n`n    function window.getPosition()`n        return nX, nY`n    end`n`n    function window.reposition( nNewX, nNewY, nNewWidth, nNewHeight )`n        nX = nNewX`n        nY = nNewY`n        if nNewWidth and nNewHeight then`n            sEmpty = string.rep( " ", nNewWidth )`n            local tNewLines = {}`n            local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }`n            for y=1,nNewHeight do`n                if y > nHeight then`n                    tNewLines[y] = tEmpty`n                else`n                    if nNewWidth == nWidth then`n                        tNewLines[y] = tLines[y]`n                    elseif nNewWidth < nWidth then`n                        tNewLines[y] = lineSub( tLines[y], 1, nNewWidth )`n                    else`n                        tNewLines[y] = lineJoin( tLines[y], { { string.sub( sEmpty, nWidth + 1, nNewWidth ), nTextColor, nBackgroundColor } } )`n                    end`n                end`n            end`n            nWidth = nNewWidth`n            nHeight = nNewHeight`n            tLines = tNewLines`n        end`n        if bVisible then`n            window.redraw()`n        end`n    end`n`n    if bVisible then`n        window.redraw()`n    end`n    return window`nend`n`n/rom/apis/turtle/turtle/@/`nif not turtle then`n	error( "Cannot load turtle API on computer", 2 )`nend`nnative = turtle.native or turtle`n`nlocal function addCraftMethod( object )`n    if peripheral.getType( "left" ) == "workbench" then`n        object.craft = function( ... )`n            return peripheral.call( "left", "craft", ... )`n        end`n    elseif peripheral.getType( "right" ) == "workbench" then`n        object.craft = function( ... )`n            return peripheral.call( "right", "craft", ... )`n        end`n    else`n        object.craft = nil`n    end`nend`n`n-- Put commands into environment table`nlocal env = getfenv()`nfor k,v in pairs( native ) do`n    if k == "equipLeft" or k == "equipRight" then`n        env[k] = function( ... )`n            local result, err = v( ... )`n            addCraftMethod( turtle )`n            return result, err`n        end`n    else`n    	env[k] = v`n    end`nend`naddCraftMethod( env )`n/rom/apis/turtle`n/rom/apis`n`n/rom/autorun/.ignoreme/@/--[[`nAlright then, don't ignore me. This file is to ensure the existance of the "autorun" folder, files placed in this folder`nusing resource packs will always run when computers startup.`n]]`n/rom/autorun`n`n/rom/help/adventure/@/adventure is a text adventure game for CraftOS. To navigate around the world of adventure, type simple instructions to the interpreter, for example: "go north", "punch tree", "craft planks", "mine coal with pickaxe", "hit creeper with sword"`n`n/rom/help/alias/@/alias assigns shell commands to run other programs.`n`nex:`n"alias dir ls" will make the "dir" command run the "ls" program`n"alias dir" will remove the alias set on "dir"`n"alias" will list all current aliases.`n`n/rom/help/apis/@/apis lists the currently loaded APIs available to programs in CraftOS.`n`nType "help <api>" to see help for a specific api.`nCall os.loadAPI( path ) to load extra apis.`n`n/rom/help/bg/@/bg is a program for Advanced Computers which opens a new tab in the background.`n`nex:`n"bg" will open a background tab running the shell`n"bg worm" will open a background tab running the "worm" program`n`n/rom/help/bit/@/Functions in the bit manipulation API:`nbit.bnot(n)          -- bitwise not (~n)`nbit.band(m, n)       -- bitwise and (m & n)`nbit.bor(m, n)        -- bitwise or (m | n)`nbit.bxor(m, n)       -- bitwise xor (m ^ n)`nbit.brshift(n, bits) -- right shift (n >> bits)`nbit.blshift(n, bits) -- left shift (n << bits)`n`n/rom/help/bundled/@/To set bundled outputs:`nc = colors.combine( colors.red, colors.blue )`nrs.setBundledOutput( "left", c )`n`nc = colors.combine( c, colors.green )`nrs.setBundledOutput( "left", c )`n`nc = colors.subtract( c, colors.blue )`nrs.setBundledOutput( "left", c )`n`nTo get bundled inputs:`nc = rs.getBundledInput( "right" )`nred = colors.test( c, colors.red )`n`nType "help colors" for the list of wire colors.`n`n/rom/help/cd/@/cd changes the the directory you're in.`n`nex:`n"cd rom" will move to "rom" folder.`n"cd .." will move up one folder.`n"cd /" will move to the root.`n`n/rom/help/changelog/@/New Features in ComputerCraft 1.65:`n`n* Fixed a multiplayer-only crash with turtle.place()`n* Fixed some problems with http.post()`n* Fixed fs.getDrive() returning incorrect results on remote peripherals`n`nNew Features in ComputerCraft 1.64:`n`n* Ported to Minecraft 1.7.10`n* New turtle functions: turtle.inspect(), turtle.inspectUp(), turtle.inspectDown(), turtle.getItemDetail()`n* Lots of bug and crash fixes, a huge stability improvement over previous versions`n`nNew Features in ComputerCraft 1.63:`n`n* Turtles can now be painted with dyes, and cleaned with water buckets`n* Added a new game: Redirection - ComputerCraft Edition`n* Turtle label nameplates now only show when the Turtle is moused-over`n* The HTTP API is now enabled by default, and can be configured with a whitelist of permitted domains`n* http.get() and http.post() now accept parameters to control the request headers`n* New fs function: fs.getDir( path )`n* Fixed some bugs`n`nNew Features in ComputerCraft 1.62:`n`n* Added IRC-style commands to the "chat" program`n* Fixed some bugs and crashes`n`nNew Features in ComputerCraft 1.6:`n`n* Added Pocket Computers`n* Added a multi-tasking system for Advanced Computers and Turtles`n* Turtles can now swap out their tools and peripherals at runtime`n* Turtles can now carry two tools or peripherals at once in any combination`n* Turtles and Computers can now be labelled using Name Tags and Anvils`n* Added a configurable fuel limit for Turtles`n* Added hostnames, protocols and long distance routing to the rednet API`n* Added a peer-to-peer chat program to demonstrate new rednet capabilities`n* Added a new game, only on Pocket Computers: "falling" by GopherATL`n* File system commands in the shell now accept wildcard arguments`n* The shell now accepts long arguments in quotes`n* Terminal redirection now no longer uses a stack-based system. Instead: term.current() gets the current terminal object and term.redirect() replaces it. term.restore() has been removed.`n* Added a new Windowing API for addressing sub-areas of the terminal`n* New programs: fg, bg, multishell, chat, repeat, redstone, equip, unequip`n* Improved programs: copy, move, delete, rename, paint, shell`n* Removed programs: redset, redprobe, redpulse`n* New APIs: window, multishell`n* New turtle functions: turtle.equipLeft() and turtle.equipRight()`n* New peripheral functions: peripheral.find( [type] )`n* New rednet functions: rednet.host( protocol, hostname ), rednet.unhost( protocol ), rednet.locate( protocol, [hostname] )`n* New fs function: fs.find( wildcard )`n* New shell functions: shell.openTab(), shell.switchTab( [number] )`n* New event "term_resize" fired when the size of a terminal changes`n* Improved rednet functions: rednet.send(), rednet.broadcast() and rednet.receive() now take optional protocol parameters`n* turtle.craft(0) and turtle.refuel(0) now return true if there is a valid recipe or fuel item, but do not craft of refuel anything`n* turtle.suck( [limit] ) can now be used to limit the number of items picked up`n* Users of turtle.dig() and turtle.attack() can now specify which side of the turtle to look for a tool to use (by default, both will be considered)`n* textutils.serialise( text ) now produces human-readable output`n* Refactored most of the codebase and fixed many old bugs and instabilities, turtles should never ever lose their content now`n* Fixed the "turtle_inventory" event firing when it shouldn't have`n* Added error messages to many more turtle functions after they return false`n* Documented all new programs and API changes in the "help" system`n`nNew Features in ComputerCraft 1.58:`n`n* Fixed a long standing bug where turtles could lose their identify if they travel too far away`n* Fixed use of deprecated code, ensuring mod compatibility with the latest versions of Minecraft Forge, and world compatibility with future versions of Minecraft`n`nNew Features in ComputerCraft 1.57:`n`n* Ported to Minecraft 1.6.4`n* Added two new Treasure Disks: Conways Game of Life by vilsol and Protector by fredthead`n* Fixed a very nasty item duplication bug`n`nNew Features in ComputerCraft 1.56:`n`n* Added Treasure Disks: Floppy Disks in dungeons which contain interesting community made programs. Find them all!`n* All turtle functions now return additional error messages when they fail.`n* Resource Packs with Lua Programs can now be edited when extracted to a folder, for easier editing.`n`nNew Features in ComputerCraft 1.55:`n`n* Ported to Minecraft 1.6.2`n* Added Advanced Turtles`n* Added "turtle_inventory" event. Fires when any change is made to the inventory of a turtle`n* Added missing functions io.close, io.flush, io.input, io.lines, io.output`n* Tweaked the screen colours used by Advanced Computers, Monitors and Turtles`n* Added new features for Peripheral authors`n* Lua programs can now be included in Resource Packs`n`nNew Features in ComputerCraft 1.52:`n`n* Ported to Minecraft 1.5.1`n`nNew Features in ComputerCraft 1.51:`n`n* Ported to Minecraft 1.5`n* Added Wired Modems`n* Added Networking Cables`n* Made Wireless Modems more expensive to craft`n* New redstone API functions: getAnalogInput(), setAnalogOutput(), getAnalogOutput()`n* Peripherals can now be controlled remotely over wired networks. New peripheral API function: getNames()`n* New event: "monitor_resize" when the size of a monitor changes`n* Except for labelled computers and turtles, ComputerCraft blocks no longer drop items in creative mode`n* The pick block function works in creative mode now works for all ComputerCraft blocks`n* All blocks and items now use the IDs numbers assigned by FTB by default`n* Fixed turtles sometimes placing blocks with incorrect orientations`n* Fixed Wireless modems being able to send messages to themselves`n* Fixed turtle.attack() having a very short range`n* Various bugfixes`n`nNew Features in ComputerCraft 1.5:`n`n* Redesigned Wireless Modems; they can now send and receive on multiple channels, independent of the computer ID. To use these features, interface with modem peripherals directly. The rednet API still functions as before`n* Floppy Disks can now be dyed with multiple dyes, just like armour`n* The "excavate" program now retains fuel in it's inventory, so can run unattended`n* turtle.place() now tries all possible block orientations before failing`n* turtle.refuel(0) returns true if a fuel item is selected`n* turtle.craft(0) returns true if the inventory is a valid recipe`n* The in-game help system now has documentation for all the peripherals and their methods, including the new modem functionality`n* A romantic surprise`n`nNew Features in ComputerCraft 1.48:`n`n* Ported to Minecraft 1.4.6`n* Advanced Monitors now emit a "monitor_touch" event when right clicked`n* Advanced Monitors are now cheaper to craft`n* Turtles now get slightly less fuel from items`n* Computers can now interact with Command Blocks (if enabled in ComputerCraft.cfg)`n* New API function: os.day()`n* A christmas surprise`n`nNew Features in ComputerCraft 1.45:`n`n* Added Advanced Computers`n* Added Advanced Monitors`n* New program: paint by nitrogenfingers`n* New API: paintutils`n* New term functions: term.setBackgroundColor, term.setTextColor, term.isColor`n* New turtle function: turtle.transferTo`n`nNew Features in ComputerCraft 1.43:`n`n* Added Printed Pages`n* Added Printed Books`n* Fixed incompatibility with Forge 275 and above`n* Labelled Turtles now keep their fuel when broken`n`nNew Features in ComputerCraft 1.42:`n`n* Ported to Minecraft 1.3.2`n* Added Printers`n* Floppy Disks can be dyed different colours`n* Wireless Crafty Turtles can now be crafted`n* New textures`n* New forge config file`n* Bug fixes`n`nNew Features in ComputerCraft 1.4:`n`n* Ported to Forge Mod Loader. ComputerCraft can now be ran directly from the .zip without extraction`n* Added Farming Turtles`n* Added Felling Turtles`n* Added Digging Turtles`n* Added Melee Turtles`n* Added Crafty Turtles`n* Added 14 new Turtle Combinations accessible by combining the turtle upgrades above`n* Labelled computers and turtles can now be crafted into turtles or other turtle types without losing their ID, label and data`n* Added a "Turtle Upgrade API" for mod developers to create their own tools and peripherals for turtles`n* Turtles can now attack entities with turtle.attack(), and collect their dropped items`n* Turtles can now use turtle.place() with any item the player can, and can interact with entities`n* Turtles can now craft items with turtle.craft()`n* Turtles can now place items into inventories with turtle.drop()`n* Changed the behaviour of turtle.place() and turtle.drop() to only consider the currently selected slot`n* Turtles can now pick up items from the ground, or from inventories, with turtle.suck()`n* Turtles can now compare items in their inventories`n* Turtles can place signs with text on them with turtle.place( [signText] )`n* Turtles now optionally require fuel items to move, and can refuel themselves`n* The size of the the turtle inventory has been increased to 16`n* The size of the turtle screen has been increased`n* New turtle functions: turtle.compareTo( [slotNum] ), turtle.craft(), turtle.attack(), turtle.attackUp(), turtle.attackDown(), turtle.dropUp(), turtle.dropDown(), turtle.getFuelLevel(), turtle.refuel()`n* New disk function: disk.getID()`n* New turtle programs: craft, refuel`n* "excavate" program now much smarter: Will return items to a chest when full, attack mobs, and refuel itself automatically`n* New API: keys`n* Added optional Floppy Disk and Hard Drive space limits for computers and turtles`n* New fs function: fs.getFreeSpace( path ), also fs.getDrive() works again`n* The send and receive range of wireless modems now increases with altitude, allowing long range networking from high-altitude computers (great for GPS networks)`n* http.request() now supports https:// URLs`n* Right clicking a Disk Drive with a Floppy Disk or a Record when sneaking will insert the item into the Disk Drive automatically`n* The default size of the computer screen has been increased`n* Several stability and security fixes. LuaJ can now no longer leave dangling threads when a computer is unloaded, turtles can no longer be destroyed by tree leaves or walking off the edge of the loaded map. Computers no longer crash when used with RedPower frames.`n`nNew Features in ComputerCraft 1.31:`n`n* Ported to Minecraft 1.2.3`n* Added Monitors (thanks to Cloudy)`n* Updated LuaJ to a newer, less memory hungry version`n* rednet_message event now has a third parameter, "distance", to support position triangulation.`n* New programs: gps, monitor, pastebin.`n* Added a secret program. Use with large monitors!`n* New apis: gps, vector`n* New turtle functions: turtle.compare(), turtle.compareUp(), turtle.compareDown(), turtle.drop( quantity )`n* New http functions: http.post().`n* New term functions: term.redirect(), term.restore()`n* New textutils functions: textutils.urlEncode()`n* New rednet functions: rednet.isOpen()`n* New config options: modem_range, modem_rangeDuringStorm`n* Bug fixes, program tweaks, and help updates`n`nNew Features in ComputerCraft 1.3:`n`n* Ported to Minecraft Forge`n* Added Turtles`n* Added Wireless Modems`n* Added Mining Turtles`n* Added Wireless Turtles`n* Added Wireless Mining Turtles`n* Computers and Disk Drives no longer get destroyed by water.`n* Computers and Turtles can now be labelled with the label program, and labelled devices keep their state when destroyed.`n* Computers/Turtles can connect to adjacent devices, and turn them on and off`n* User programs now give line numbers in their error messages`n* New APIs: turtle, peripheral`n* New programs for turtles: tunnel, excavate, go, turn, dance`n* New os functions: os.getComputerLabel(), os.setComputerLabel()`n* Added "filter" parameter to os.pullEvent()`n* New shell function: shell.getCurrentProgram()`n* New textutils functions: textutils.serialize(), textutils.unserialize(), textutils.tabulate(), textutils.pagedTabulate(), textutils.slowWrite()`n* New io file function: file:lines()`n* New fs function: fs.getSize()`n* Disk Drives can now play records from other mods`n* Bug fixes, program tweaks, and help updates`n`nNew Features in ComputerCraft 1.2:`n`n* Added Disk Drives and Floppy Disks`n* Added Ctrl+T shortcut to terminate the current program (hold)`n* Added Ctrl+S shortcut to shutdown the computer (hold)`n* Added Ctrl+R shortcut to reboot the computer (hold)`n* New Programs: alias, apis, copy, delete, dj, drive, eject, id, label, list, move, reboot, redset, rename, time, worm.`n* New APIs: bit, colours, disk, help, rednet, parallel, textutils.`n* New color functions: colors.combine(), colors.subtract(), colors.test()`n* New fs functions: fs.getName(), new modes for fs.open()`n* New os functions: os.loadAPI(), os.unloadAPI(),`nos.clock(), os.time(), os.setAlarm(),`nos.reboot(), os.queueEvent()`n* New redstone function: redstone.getSides()`n* New shell functions: shell.setPath(), shell.programs(), shell.resolveProgram(), shell.setAlias()`n* Lots of updates to the help pages`n* Bug fixes`n`nNew Features in ComputerCraft 1.1:`n`n* Added Multiplayer support throughout.`n* Added connectivity with RedPower bundled cables`n* Added HTTP api, enabled via the mod config, to allow computers to access the real world internet`n* Added command history to the shell.`n* Programs which spin in an infinite loop without yielding will no longer freeze minecraft`n* Help updates and bug fixes`n`nNew Features in ComputerCraft 1.0:`n`n* First Release!`n`n/rom/help/chat/@/Surf the rednet superhighway with "chat", the networked chat program for CraftOS! Host chatrooms and invite your friends! Requires a Wired or Wireless Modem on each computer. When running chat, type "/help" to see a list of available commands.`n`nex:`n"chat host forgecraft" will create a chatroom with the name "forgecraft"`n"chat join forgecraft direwolf20" will connect to the chatroom with the name "forgecraft", using the nickname "direwolf20"`n`n/rom/help/clear/@/clear clears the screen.`n`n/rom/help/colors/@/Functions in the colors api`n(used for redstone.setBundledOutput):`ncolors.combine( color1, color2, color3, ... )`ncolors.subtract( colors, color1, color2, ... )`ncolors.test( colors, color )`n`nColor constants in the colors api, in ascending bit order:`ncolors.white, colors.orange, colors.magenta, colors.lightBlue, colors.yellow, colors.lime, colors.pink, colors.gray, colors.lightGray, colors.cyan, colors.purple, colors.blue, colors.brown, colors.green, colors.red, colors.black.`n`n/rom/help/colours/@/Functions in the colours api`n(used for redstone.setBundledOutput):`ncolours.combine( colour1, colour2, colour3, ...)`ncolours.subtract( colours, colour1, colour2, ...)`ncolours.test( colours, colour )`n`nColour constants in the colours api, in ascending bit order:`ncolours.white, colours.orange, colours.magenta, colours.lightBlue, colours.yellow, colours.lime, colours.pink, colours.grey, colours.lightGrey, colours.cyan, colours.purple, colours.blue, colours.brown, colours.green, colours.red, colours.black.`n`n/rom/help/copy/@/cp copies a file or directory from one location to another.`n`nex:`n"cp rom myrom" copies "rom" to "myrom".`n"cp rom mystuff/rom" copies "rom" to "mystuff/rom".`n"cp disk/* disk2" copies the contents of one disk to another`n`n/rom/help/coroutine/@/coroutine is a standard Lua5.1 API.`nRefer to http://www.lua.org/manual/5.1/ for more information.`n`n/rom/help/craft/@/craft is a program for Crafty Turtles. Craft will craft a stack of items using the current inventory.`n`nex:`n"craft" will craft as many items as possible`n"craft 5" will craft at most 5 times`n`n/rom/help/credits/@/ComputerCraft was created by Daniel "dan200" Ratcliffe, with additional code by Aaron "Cloudy" Mills.`nThanks to nitrogenfingers, GopherATL and RamiLego for program contributions.`nThanks to Mojang, the Forge team, and the MCP team.`nUses LuaJ from http://luaj.sourceforge.net/`n`nJoin the ComputerCraft community online at http://www.computercraft.info`nFollow @DanTwoHundred on Twitter!`n`n/rom/help/dance/@/dance is a program for Turtles. Turtles love to get funky.`n`n/rom/help/delete/@/rm deletes a file or a directory and its contents.`n`nex:`n"rm foo" will delete the file foo.`n"rm disk/*" will delete the contents of a disk.`n`n/rom/help/disk/@/Functions in the disk API. These functions are for interacting with disk drives:`ndisk.isPresent( drive )`ndisk.setLabel( drive, label )`ndisk.getLabel( drive )`ndisk.hasData( drive )`ndisk.getMountPath( drive )`ndisk.hasAudio( drive )`ndisk.getAudioTitle( drive )`ndisk.playAudio( drive )`ndisk.stopAudio( )`ndisk.eject( drive )`ndisk.getID( drive )`n`nEvents fired by the disk API:`n"disk" when a disk or other item is inserted into a disk drive. Argument is the name of the drive`n"disk_eject" when a disk is removed from a disk drive. Argument is the name of the drive`nType "help events" to learn about the event system.`n`n/rom/help/dj/@/dj plays Music Discs from disk drives attached to the computer.`n`nex:`n"dj" or "dj play" plays a random disc.`n"dj play left" plays the disc in the drive on the left of the computer.`n"dj stop" stops the current disc.`n`n/rom/help/drive/@/drive tells you which disk drive the current or specified directory is located in.`n`nex:`n"drive" tell you the disk drive of the current directory.`n"drive foo" tells you the disk drive of the subdirectory "foo"`n`n/rom/help/drives/@/The Disk Drive is a peripheral device available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Disk Drive is connected, peripheral.getType() will return "drive".`n`nMethods exposed by the Disk Drive:`nisDiskPresent()`ngetDiskLabel()`nsetDiskLabel( label )`nhasData()`ngetMountPath()`nhasAudio()`ngetAudioTitle()`nplayAudio()`nstopAudio()`nejectDisk()`ngetDiskID()`n`nEvents fired by the Disk Drive:`n"disk" when a disk or other item is inserted into the drive. Argument is the name of the drive.`n"disk_eject" when a disk is removed from a  drive. Argument is the name of the drive.`nType "help events" to learn about the event system.`n`n/rom/help/earth/@/Mostly harmless.`n`n/rom/help/edit/@/edit is a text editor for creating or modifying programs or text files. After creating a program with edit, type its filename in the shell to run it. You can open any of the builtin programs with edit to learn how to program.`n`nex:`n"edit hello" opens a file called "hello" for editing.`n`n/rom/help/eject/@/eject ejects the contents of an attached disk drive.`n`nex:`n"eject left" ejects the contents of the disk drive to the left of the computer.`n`n/rom/help/equip/@/equip is a program for Turtles. equip will equip an item from the Turtle's inventory for use as a tool of peripheral.`n`nex:`n"equip 5 left" will equip the item from slot 5 of the turtle onto the left side of the turtle`n`n/rom/help/events/@/The function os.pullEvent() will yield the program until a system event occurs. The first return value is the event name, followed by any arguments.`n`nSome events which can occur are:`n"char" when text is typed on the keyboard. Argument is the letter typed.`n"key" when a key is pressed on the keyboard. Argument is the numerical keycode. Compare to the values in keys API to see which key was pressed.`n"paste" when text is pasted from the users keyboard. Argument is the line of text pasted.`n`nEvents only on advanced computers:`n"mouse_click" when a user clicks the mouse. Arguments are button, xPos, yPos.`n"mouse_drag" when a user moves the mouse when held. Arguments are button, xPos, yPos.`n"mouse_scroll" when a user uses the scrollwheel on the mouse. Arguments are direction, xPos, yPos.`n`nOther APIs and peripherals will emit their own events. See their respective help pages for details.`n`n/rom/help/excavate/@/excavate is a program for Mining Turtles. When excavate is run, the turtle will mine a rectangular shaft into the ground, collecting blocks as it goes, and return to the surface once bedrock is hit.`n`nex:`n"excavate 3" will mine a 3x3 shaft.`n`n/rom/help/exit/@/exit will exit the current shell.`n`n/rom/help/falling/@/"From Russia with Fun" comes a fun, new, suspiciously-familiar falling block game for CraftOS. Only on Pocket Computers!`n`n/rom/help/fg/@/fg is a program for Advanced Computers which opens a new tab in the foreground.`n`nex:`n"fg" will open a foreground tab running the shell`n"fg worm" will open a foreground tab running the "worm" program`n`n/rom/help/fs/@/Functions in the Filesystem API:`nfs.list( path )`nfs.find( wildcard )`nfs.exists( path )`nfs.isDir( path )`nfs.isReadOnly( path )`nfs.getDir( path )`nfs.getName( path )`nfs.getSize( path )`nfs.getDrive( path )`nfs.getFreeSpace( path )`nfs.makeDir( path )`nfs.move( path, path )`nfs.copy( path, path )`nfs.delete( path )`nfs.combine( path, localpath )`nfs.open( path, mode )`nAvailable fs.open() modes are "r", "w", "a", "rb", "wb" and "ab".`n`nFunctions on files opened with mode "r":`nreadLine()`nreadAll()`nclose()`n`nFunctions on files opened with mode "w" or "a":`nwrite( string )`nwriteLine( string )`nflush()`nclose()`n`nFunctions on files opened with mode "rb":`nread()`nclose()`n`nFunctions on files opened with mode "wb" or "ab":`nwrite( byte )`nflush()`nclose()`n`n/rom/help/go/@/go is a program for Turtles, used to control the turtle without programming. It accepts one or more commands as a direction followed by a distance.`n`nex:`n"go forward" moves the turtle 1 space forward.`n"go forward 3" moves the turtle 3 spaces forward.`n"go forward 3 up left 2" moves the turtle 3 spaces forward, 1 spaces up, then left 180 degrees.`n`n/rom/help/gps/@/gps can be used to host a GPS server, or to determine a position using trilateration.`nType "help gpsapi" for help using GPS functions in lua programs.`n`nex:`n"gps locate" will connect to nearby GPS servers, and try to determine the position of the computer or turtle.`n"gps host" will try to determine the position, and host a GPS server if successful.`n"gps host 10 20 30" will host a GPS server, using the manually entered position 10,20,30. `n`nTake care when manually entering host positions. If the positions entered into multiple GPS hosts`nare not consistent, the results of locate calls will be incorrect.`n`n/rom/help/gpsapi/@/Functions in the GPS API:`ngps.locate( timeout )`n`nThe locate function will send a signal to nearby gps servers, and wait for responses before the timeout. If it receives enough responses to determine this computers position then x, y and z co-ordinates will be returned, otherwise it will return nil. If GPS hosts do not have their positions configured correctly, results will be inaccurate.`n`n/rom/help/hello/@/hello prints the text "Hello World!" to the screen.`n`n/rom/help/help/@/help is the help tool you're currently using.`nType "help index" to see all help topics.`nType "help" to see the help intro.`nType "help helpapi" for information on the help Lua API.`n`n/rom/help/helpapi/@/Functions in the help API:`nhelp.setPath( path )`nhelp.lookup( topic )`nhelp.topics()`n`n/rom/help/http/@/Functions in the HTTP API:`nhttp.checkURL( url )`nhttp.request( url, [postData], [headers] )`nhttp.get( url, [headers] )`nhttp.post( url, postData, [headers] )`n`nThe HTTP API may be disabled in ComputerCraft.cfg`nA period of time after a http.request() call is made, a "http_success" or "http_failure" event will be raised. Arguments are the url and a file handle if successful. http.get() and http.post() block until this event fires instead.`n`n/rom/help/id/@/id prints the unique identifier of this computer, or a Disk in an attached Disk Drive.`n`nex:`n"id" will print this Computers ID and label`n"id left" will print the ID and label of the disk in the Disk Drive on the left`n`n/rom/help/intro/@/Welcome to CraftOS!`nType "programs" to see the programs you can run.`nType "help <program>" to see help for a specific program.`nType "help programming" to learn about programming.`nType "help whatsnew" to find out about new features.`nType "help credits" to learn who made all this.`nType "help index" to see all help topics.`n`n/rom/help/io/@/io is a standard Lua5.1 API, reimplemented for CraftOS. Not all the features are availiable.`nRefer to http://www.lua.org/manual/5.1/ for more information.`n`n/rom/help/keys/@/The keys API contains constants for all the key codes that can be returned by the "key" event:`n`nExample usage:`nlocal sEvent, nKey = os.pullEvent()`nif sEvent == "key" and nKey == keys.enter then`n   -- Do something  `nend`n`nSee http://www.minecraftwiki.net/wiki/Key_codes, or the source code, for a complete reference.`n`n/rom/help/label/@/label gets or sets the label of the Computer, or of Floppy Disks in attached disk drives.`n`nex:`n"label get" prints the label of the computer.`n"label get left" prints the label of the disk in the left drive.`n"label set "My Computer"" set the label of the computer to "My Computer".`n"label set left "My Programs"" - sets the label of the disk in the left drive to "My Programs".`n"label clear" clears the label of the computer.`n"label clear left" clears the label of the disk in the left drive.`n`n/rom/help/list/@/ls will list all the directories and files in the current location. Use "type" to find out if an item is a file or a directory.`n`n/rom/help/lua/@/lua is an interactive prompt for the lua programming language. It's a useful tool for learning the language.`n`n/rom/help/math/@/math is a standard Lua5.1 API.`nRefer to http://www.lua.org/manual/5.1/ for more information.`n`n/rom/help/mkdir/@/mkdir creates a directory in the current location.`n`nex:`n"mkdir foo" creates a directory named "foo".`n"mkdir ../foo" creates a directory named "foo" in the directory above the current directory.`n`n/rom/help/modems/@/Wired and Wireless Modems are peripheral devices available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Modem is connected, peripheral.getType() will return "modem".`n`nMethods exposed by Modems:`nopen( channel )`nisOpen( channel )`nclose( channel )`ncloseAll()`ntransmit( channel, replyChannel, message )`nisWireless()`n`nEvents fired by Modems:`n"modem_message" when a message is received on an open channel. Arguments are name, channel, replyChannel, message, distance`n`n/rom/help/monitor/@/monitor will connect to an attached Monitor peripheral, and run a program on its display.`n`nex:`n"monitor left hello" will run the "hello" program on the monitor to the left of the computer.`n"monitor top edit foo" will run the edit program on the top monitor, editing the file "foo".`n`n/rom/help/monitors/@/The Monitor is a peripheral device available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Monitor is connected, peripheral.getType() will return "monitor". A wrapped monitor can be used with term.redirect() to send all terminal output to the monitor.`n`nMethods exposed by the Monitor:`nwrite( text )`nclear()`nclearLine()`ngetCursorPos()`nsetCursorPos( x, y )`nsetCursorBlink( blink )`nisColor()`nsetTextColor( color )`nsetBackgroundColor( color )`ngetSize()`nscroll( n )`n`nEvents fired by the Monitor:`n"monitor_touch" when an Advanced Monitor is touched by the player. Arguments are name, x, y`n"monitor_resize" when the size of a Monitor changes. Argument is the name of the monitor.`n`n/rom/help/move/@/mv moves a file or directory from one location to another.`n`nex:`n"mv foo bar" renames the file "foo" to "bar".`n"mv foo bar/foo" moves the file "foo" to a folder called "bar".`n"mv disk/* disk2" moves the contents of one disk to another`n`n/rom/help/multishell/@/multishell is the toplevel program on Advanced Computers which manages background tabs.`nType "help shellapi" for information about the shell lua api.`n`n/rom/help/os/@/Functions in the os (Operating System) API:`nos.version()`nos.getComputerID()`nos.getComputerLabel()`nos.setComputerLabel()`nos.run( environment, programpath, arguments )`nos.loadAPI( path )`nos.unloadAPI( name )`nos.pullEvent( [filter] )`nos.queueEvent( event, arguments )`nos.clock()`nos.startTimer( timeout )`nos.cancelTimer( token )`nos.sleep( timeout )`nos.time()`nos.day()`nos.setAlarm( time )`nos.cancelAlarm( token )`nos.shutdown()`nos.reboot()`n`nEvents emitted by the os API:`n"timer" when a timeout started by os.startTimer() completes. Argument is the token returned by os.startTimer().`n"alarm" when a time passed to os.setAlarm() is reached. Argument is the token returned by os.setAlarm().`nType "help events" to learn about the event system.`n`n/rom/help/paint/@/paint is a program for creating images on Advanced Computers. Select colors from the color pallette on the right, and click on the canvas to draw. Press Ctrl to access the menu and save your pictures.`n`nex:`n"edit mario" opens an image called "mario" for editing.`n`n/rom/help/paintutils/@/Functions in the Paint Utilities API:`npaintutils.drawPixel( x, y, colour )`npaintutils.drawLine( startX, startY, endX, endY, colour )`npaintutils.drawBox( startX, startY, endX, endY, colour )`npaintutils.drawFilledBox( startX, startY, endX, endY, colour )`npaintutils.loadImage( path )`npaintutils.drawImage( image, x, y )`n`n/rom/help/parallel/@/Functions in the Parallel API:`nparallel.waitForAny( function1, function2, ... )`nparallel.waitForAll( function1, function2, ... )`nThese methods provide an easy way to run multiple lua functions simultaneously.`n`n/rom/help/pastebin/@/pastebin is a program for uploading files to and downloading files from pastebin.com. This is useful for sharing programs with other players.`nThe HTTP API must be enabled in ComputerCraft.cfg to use this program.`n`nex:`n"pastebin put foo" will upload the file "foo" to pastebin.com, and print the URL.`n"pastebin get xq5gc7LB foo" will download the file from the URL http://pastebin.com/xq5gc7LB, and save it as "foo".`n"pastebin run CxaWmPrX" will download the file from the URL http://pastebin.com/CxaWmPrX, and immediately run it.`n`n/rom/help/peripheral/@/The peripheral API is for interacting with external peripheral devices. Type "help peripherals" to learn about the peripherals available.`n`nFunctions in the peripheral API:`nperipheral.getNames()`nperipheral.isPresent( name )`nperipheral.getType( name )`nperipheral.getMethods( name )`nperipheral.call( name, methodName, param1, param2, etc )`nperipheral.wrap( name )`nperipheral.find( type, [fnFilter] )`n`nEvents fired by the peripheral API:`n"peripheral" when a new peripheral is attached. Argument is the name.`n"peripheral_detach" when a peripheral is removed. Argument is the name.`nType "help events" to learn about the event system.`n`n/rom/help/peripherals/@/Peripherals are external devices which CraftOS Computers and Turtles can interact with using the peripheral API.`nType "help peripheral" to learn about using the peripheral API.`nType "help drives" to learn about using Disk Drives.`nType "help modems" to learn about using Wireless Modems.`nType "help monitors" to learn about using Monitors.`nType "help printers" to learn about using Printers.`n`n/rom/help/printers/@/The Printer is a peripheral device available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Printer is connected, peripheral.getType() will return "printer".`n`nMethods exposed by the Printer:`ngetInkLevel()`ngetPaperLevel()`nnewPage()`nsetPageTitle( title )`ngetPageSize()`nsetCursorPos( x, y )`ngetCursorPos()`nwrite( text )`nendPage()`n`n/rom/help/programming/@/To learn the lua programming language, visit http://lua-users.org/wiki/TutorialDirectory.`n`nTo experiment with lua in CraftOS, run the "lua" program and start typing code.`nTo create programs, use "edit" to create files, then type their names in the shell to run them. If you name a program "startup" and place it in the root or on a disk drive, it will run automatically when the computer starts.`n`nTo terminate a program stuck in a loop, hold Ctrl+T for 1 second.`nTo quickly shutdown a computer, hold Ctrl+S for 1 second.`nTo quickly reboot a computer, hold Ctrl+R for 1 second.`n`nTo learn about the programming APIs availiable, type "apis" or "help apis".`nIf you get stuck, visit the forums at http://www.computercraft.info/ for advice and tutorials.`n`n/rom/help/programs/@/programs lists all the programs on the rom of the computer.`n`n/rom/help/reboot/@/reboot will turn the computer off and on again.`nYou can also hold Ctrl+R at any time to quickly reboot.`n`n/rom/help/redirection/@/Redirection ComputerCraft Edition is the CraftOS version of a fun new puzzle game by Dan200, the author of ComputerCraft.`nPlay it on any Advanced Computer, then visit http://www.redirectiongame.com to play the full game!`n`n/rom/help/rednet/@/The rednet API provides a simple computer networking model using modems.`n`nFunctions in the rednet API:`nrednet.open( side )`nrednet.close( [side] )`nrednet.isOpen( [side] )`nrednet.send( receiverID, message, [protocol] ) -- Send to a specific computer`nrednet.broadcast( message, [protocol] ) -- Send to all computers`nrednet.receive( [protocol], [timeout] ) -- Returns: senderID, message, protocol`nrednet.host( protocol, hostname )`nrednet.unhost( protocol )`nrednet.lookup( protocol, [hostname] ) -- Returns: ID`n`nEvents fired by the rednet API:`n"rednet_message" when a message is received. Arguments are senderID, message, protocol`nType "help events" to learn about the event system.`n`nRednet is not the only way to use modems for networking. Interfacing with the modem directly using the peripheral API and listening for the "modem_message" event allows for lower level control, at the expense of powerful high level networking features.`n`n/rom/help/redstone/@/The redstone program can be used to get, set or pulse redstone inputs and outputs from the computer.`n`nex:`n"redstone probe" will list all the redstone inputs to the computer`n"redstone set left true" turns on the left redstone output.`n"redstone set right blue false" turns off the blue wire in the bundled cable on the right redstone output.`n"redstone pulse front 10 1" emits 10 one second redstone pulses on the front redstone output.`n`nType "help redstoneapi" or "help rs" for information on the redstone Lua API.`n`n/rom/help/redstoneapi/@/Functions in the Redstone API:`nredstone.getSides( )`nredstone.getInput( side )`nredstone.setOutput( side, boolean )`nredstone.getOutput( side )`nredstone.getAnalogInput( side )`nredstone.setAnalogOutput( side, number )`nredstone.getAnalogOutput( side )`n`nFunctions in the Redstone API for working with bundled cables:`nredstone.getBundledInput( side )`nredstone.testBundledInput( side, color )`nredstone.setBundledOutput( side, colors )`nredstone.getBundledOutput( side )`nType "help bundled" for usage examples.`n`nEvents emitted by the redstone API:`n"redstone", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes`nType "help events" to learn about the event system.`n`n/rom/help/refuel/@/refuel is a program for Turtles. Refuel will consume items from the inventory as fuel for turtle.`n`nex:`n"refuel" will refuel with at most one fuel item`n"refuel 10" will refuel with at most 10 fuel items`n"refuel all" will refuel with as many fuel items as possible`n`n/rom/help/rename/@/rename renames a file or directory.`n`nex:`n"rename foo bar" renames the file "foo" to "bar".`n`n/rom/help/repeat/@/repeat is a program for repeating rednet messages across long distances. To use, connect 2 or more modems to a computer and run the "repeat" program; from then on, any rednet message sent from any computer in wireless range or connected by networking cable to either of the modems will be repeated to those on the other side.`n`n/rom/help/rs/@/Functions in the Redstone API:`nrs.getSides( )`nrs.getInput( side )`nrs.setOutput( side, boolean )`nrs.getOutput( side )`nrs.getAnalogInput( side )`nrs.setAnalogOutput( side, number )`nrs.getAnalogOutput( side )`n`nFunctions in the Redstone API for working with RedPower bundled cables:`nrs.getBundledInput( side )`nrs.testBundledInput( side, color )`nrs.setBundledOutput( side, colors )`nrs.getBundledOutput( side )`nType "help bundled" for usage examples.`n`nEvents emitted by the redstone API:`n"redstone", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes`nType "help events" to learn about the event system.`n`n/rom/help/shell/@/shell is the toplevel program which interprets commands and runs program.`nType "help shellapi" for information about the shell lua api.`n`n/rom/help/shellapi/@/Functions in the Shell API:`nshell.exit()`nshell.dir()`nshell.setDir( path )`nshell.path()`nshell.setPath( path )`nshell.resolve( localpath )`nshell.resolveProgram( name )`nshell.aliases()`nshell.setAlias( alias, command )`nshell.clearAlias( alias )`nshell.programs()`nshell.run( program, arguments )`nshell.getRunningProgram()`nshell.openTab( program, arguments ) (Advanced Computer required)`nshell.switchTab( n ) (Advanced Computer required)`n`n/rom/help/shutdown/@/shutdown will turn off the computer.`n`n/rom/help/sleep/@/sleep makes the computer idle for a specific number of seconds.`n`nex:`n"sleep 10" puts the computer to sleep for 10 seconds`n`n/rom/help/string/@/string is a standard Lua5.1 API.`nRefer to http://www.lua.org/manual/5.1/ for more information.`n`n/rom/help/table/@/table is a standard Lua5.1 API.`nRefer to http://www.lua.org/manual/5.1/ for more information.`n`n/rom/help/term/@/Functions in the Terminal API:`nterm.write( text )`nterm.clear()`nterm.clearLine()`nterm.getCursorPos()`nterm.setCursorPos( x, y )`nterm.setCursorBlink( blink )`nterm.isColor()`nterm.setTextColor( color )`nterm.setBackgroundColor( color )`nterm.getSize()`nterm.scroll( n )`nterm.redirect( object )`nterm.current()`n`nEvents emitted by the terminals:`n"term_resize", when the size of a terminal changes. This can happen in multitasking environments, or when the terminal out is being redirected by the "monitor" program.`n`n/rom/help/textutils/@/Functions in the Text Utilities API:`ntextutils.slowPrint( text )`ntextutils.tabulate( table, table2, ... )`ntextutils.pagedTabulate( table, table2, ... )`ntextutils.formatTime( time, bTwentyFourHour )`ntextutils.serialize( table )`ntextutils.unserialize( string )`ntextutils.urlEncode( string )`n`n/rom/help/time/@/time prints the current time of day.`n`n/rom/help/tunnel/@/tunnel is a program for Mining Turtles. Tunnel will mine a 3x2 tunnel of the depth specified.`n`nex:`n"tunnel 20" will tunnel a tunnel 20 blocks long.`n`n/rom/help/turn/@/turn is a program for Turtles, used to turn the turtle around without programming. It accepts one or more commands as a direction and a number of turns. The "go" program can also be used for turning.`n`nex:`n"turn left" turns the turtle 90 degrees left.`n"turn right 2" turns the turtle 180 degrees right.`n"turn left 2 right" turns left 180 degrees, then right 90 degrees.`n`n/rom/help/turtle/@/turtle is an api availiable on Turtles, which controls their movement.`nFunctions in the Turtle API:`nturtle.forward()`nturtle.back()`nturtle.up()`nturtle.down()`nturtle.turnLeft()`nturtle.turnRight()`nturtle.select( slotNum )`nturtle.getSelectedSlot()`nturtle.getItemCount( [slotNum] )`nturtle.getItemSpace( [slotNum] )`nturtle.getItemDetail( [slotNum] )`nturtle.equipLeft()`nturtle.equipRight()`nturtle.dig( [toolSide] )`nturtle.digUp( [toolSide] )`nturtle.digDown( [toolSide] )`nturtle.place()`nturtle.placeUp()`nturtle.placeDown()`nturtle.attack( [toolSide] )`nturtle.attackUp( [toolSide] )`nturtle.attackDown( [toolSide] )`nturtle.detect()`nturtle.detectUp()`nturtle.detectDown()`nturtle.compare()`nturtle.compareUp()`nturtle.compareDown()`nturtle.inspect()`nturtle.inspectUp()`nturtle.inspectDown()`nturtle.inspectSlot( [slotNum] )`nturtle.compareTo( slotNum )`nturtle.transferTo( slotNum, [quantity] )`nturtle.drop( [quantity] )`nturtle.dropUp( [quantity] )`nturtle.dropDown( [quantity] )`nturtle.suck( [quantity] )`nturtle.suckUp( [quantity] )`nturtle.suckDown( [quantity] )`nturtle.getFuelLevel()`nturtle.getFuelLimit()`nturtle.refuel( [quantity] )`nturtle.craft( [quantity] ) (requires Crafty Turtle)`n`nEvents fired by the Turtle API:`n"turtle_inventory" when any of the items in the inventory are changed. Use comparison operations to inspect the changes.`n`n/rom/help/type/@/type determines the type of a file or directory. Prints "file", "directory" or "does not exist".`n`n/rom/help/unequip/@/unequip is a program for Turtles. unequip will remove tools of peripherals from the specified side of the turtle.`n`nex:`n"unequip left" will remove the item on the left side of the turtle`n`n/rom/help/vector/@/Functions in the 3D Vector Math API:`nvector.new( x,y,z )`n`nVectors returned by vector.new() have the following fields and methods:`nvector.x`nvector.y`nvector.z`nvector:add( vector )`nvector:sub( vector )`nvector:mul( number )`nvector:dot( vector )`nvector:cross( vector )`nvector:length()`nvector:normalize()`nvector:round()`nvector:tostring()`nThe +, - and * operators can also be used on vectors.`n`n/rom/help/whatsnew/@/New Features in ComputerCraft 1.65:`n`n* Fixed a multiplayer-only crash with turtle.place()`n* Fixed some problems with http.post()`n* Fixed fs.getDrive() returning incorrect results on remote peripherals`n`nType "help changelog" to see the full version history.`n`n/rom/help/window/@/Functions in the window API:`nwindow.create( parent, x, y, width, height, visible )`n`nWindows created with the window API have the following methods:`nwrite( text )`nclear()`nclearLine()`ngetCursorPos()`nsetCursorPos( x, y )`nsetCursorBlink( blink )`nisColor()`nsetTextColor( color )`nsetBackgroundColor( color )`ngetSize()`nscroll( n )`nsetVisible( bVisible )`nredraw()`nrestoreCursor()`ngetPosition()`nreposition( x, y, width, height )`n`n/rom/help/workbench/@/Workbenches are peripheral devices found on Crafty Turtles running CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a workbench is attached to a turtle, peripheral.getType() will return "workbench".`n`nMethods exposed by Workbenches:`ncraft( channel )`n`n/rom/help/worm/@/You've played it in the arcades, now experience the high-octane thrills of the hit game "WORM!" on your home computer! Only on CraftOS!`n`n/rom/help/licenses/luaj/@/Copyright (c) 2007 LuaJ. All rights reserved.`n`nPermission is hereby granted, free of charge, to any person obtaining a copy`nof this software and associated documentation files (the "Software"), to deal`nin the Software without restriction, including without limitation the rights`nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell`ncopies of the Software, and to permit persons to whom the Software is`nfurnished to do so, subject to the following conditions:`n`nThe above copyright notice and this permission notice shall be included in`nall copies or substantial portions of the Software.`n`nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR`nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,`nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE`nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER`nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,`nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN`nTHE SOFTWARE.`n/rom/help/licenses`n/rom/help`n`n/rom/programs/alias/@/`nlocal tArgs = { ... }`nif #tArgs > 2 then`n	print( "Usage: alias <alias> <program>" )`n	return`nend`n`nlocal sAlias = tArgs[1]`nlocal sProgram = tArgs[2]`n`nif sAlias and sProgram then`n	-- Set alias`n	shell.setAlias( sAlias, sProgram )`nelseif sAlias then`n	-- Clear alias`n	shell.clearAlias( sAlias )`nelse`n	-- List aliases`n	local tAliases = shell.aliases()`n	local tList = {}`n	for sAlias, sCommand in pairs( tAliases ) do`n		table.insert( tList, sAlias )`n	end`n	table.sort( tList )`n	textutils.pagedTabulate( tList )`nend`n	`n`n/rom/programs/apis/@/`nlocal tApis = {}`nfor k,v in pairs( _G ) do`n	if type(k) == "string" and type(v) == "table" and k ~= "_G" then`n		table.insert( tApis, k )`n	end`nend`ntable.insert( tApis, "shell" )`ntable.sort( tApis )`n`ntextutils.pagedTabulate( tApis )`n`n/rom/programs/cd/@/`nlocal tArgs = { ... }`nif #tArgs < 1 then`n	print( "Usage: cd <path>" )`n	return`nend`n`nlocal sNewDir = shell.resolve( tArgs[1] )`nif fs.isDir( sNewDir ) then`n	shell.setDir( sNewDir )`nelse`n  	print( "Not a directory" )`n  	return`nend`n`n/rom/programs/clear/@/term.clear()`nterm.setCursorPos( 1, 1 )`n`n/rom/programs/copy/@/`nlocal tArgs = { ... }`nif #tArgs < 2 then`n	print( "Usage: cp <source> <destination>" )`n	return`nend`n`nlocal sSource = shell.resolve( tArgs[1] )`nlocal sDest = shell.resolve( tArgs[2] )`nlocal tFiles = fs.find( sSource )`nif #tFiles > 0 then`n    for n,sFile in ipairs( tFiles ) do`n        if fs.isDir( sDest ) then`n            fs.copy( sFile, fs.combine( sDest, fs.getName(sFile) ) )`n        elseif #tFiles == 1 then`n            fs.copy( sFile, sDest )`n        else`n            printError( "Cannot overwrite file multiple times" )`n            return`n        end`n    end`nelse`n    printError( "No matching files" )`nend`n`n/rom/programs/delete/@/`nlocal tArgs = { ... }`nif #tArgs < 1 then`n	print( "Usage: rm <path>" )`n	return`nend`n`nlocal sPath = shell.resolve( tArgs[1] )`nlocal tFiles = fs.find( sPath )`nif #tFiles > 0 then`n    for n,sFile in ipairs( tFiles ) do`n        fs.delete( sFile )`n    end`nelse`n    printError( "No matching files" )`nend`n`n/rom/programs/drive/@/local tArgs = { ... }`n`n-- Get where a directory is mounted`nlocal sPath = shell.dir()`nif tArgs[1] ~= nil then`n	sPath = shell.resolve( tArgs[1] )`nend`n`nif fs.exists( sPath ) then`n	write( fs.getDrive( sPath ) .. " (" )`n	local nSpace = fs.getFreeSpace( sPath )`n	if nSpace > 1024 * 1024 then`n		print( (math.floor( nSpace / (100 * 1000) ) / 10) .. "MB remaining)" )`n	elseif nSpace > 1024 then`n		print( math.floor( nSpace / 1000 ) .. "KB remaining)" )`n	else`n		print ( nSpace .. "B remaining)" )`n	end`nelse`n	print( "No such path" )`nend`n`n/rom/programs/edit/@/-- Get file to edit`nlocal tArgs = { ... }`nif #tArgs == 0 then`n	print( "Usage: edit <path>" )`n	return`nend`n`n-- Error checking`nlocal sPath = shell.resolve( tArgs[1] )`nlocal bReadOnly = fs.isReadOnly( sPath )`nif fs.exists( sPath ) and fs.isDir( sPath ) then`n	print( "Cannot edit a directory." )`n	return`nend`n`nlocal x,y = 1,1`nlocal w,h = term.getSize()`nlocal scrollX, scrollY = 0,0`n`nlocal tLines = {}`nlocal bRunning = true`n`n-- Colours`nlocal highlightColour, keywordColour, commentColour, textColour, bgColour`nif term.isColour() then`n	bgColour = colours.black`n	textColour = colours.white`n	highlightColour = colours.yellow`n	keywordColour = colours.yellow`n	commentColour = colours.green`n	stringColour = colours.red`nelse`n	bgColour = colours.black`n	textColour = colours.white`n	highlightColour = colours.white`n	keywordColour = colours.white`n	commentColour = colours.white`n	stringColour = colours.white`nend`n`n-- Menus`nlocal bMenu = false`nlocal nMenuItem = 1`nlocal tMenuItems`nif bReadOnly then`n	tMenuItems = { "Exit", "Print" }`nelse`n	tMenuItems = { "Save", "Exit", "Print" }`nend`n	`nlocal sStatus = "Press Ctrl to access menu"`n`nlocal function load( _sPath )`n	tLines = {}`n	if fs.exists( _sPath ) then`n		local file = io.open( _sPath, "r" )`n		local sLine = file:read()`n		while sLine do`n			table.insert( tLines, sLine )`n			sLine = file:read()`n		end`n		file:close()`n	end`n	`n	if #tLines == 0 then`n		table.insert( tLines, "" )`n	end`nend`n`nlocal function save( _sPath )`n	-- Create intervening folder`n	local sDir = sPath:sub(1, sPath:len() - fs.getName(sPath):len() )`n	if not fs.exists( sDir ) then`n		fs.makeDir( sDir )`n	end`n`n	-- Save`n	local file = nil`n	local function innerSave()`n		file = fs.open( _sPath, "w" )`n		if file then`n			for n, sLine in ipairs( tLines ) do`n				file.write( sLine .. "\n" )`n			end`n		else`n			error( "Failed to open ".._sPath )`n		end`n	end`n	`n	local ok = pcall( innerSave )`n	if file then `n		file.close()`n	end`n	return ok`nend`n`nlocal tKeywords = {`n	["and"] = true,`n	["break"] = true,`n	["do"] = true,`n	["else"] = true,`n	["elseif"] = true,`n	["end"] = true,`n	["false"] = true,`n	["for"] = true,`n	["function"] = true,`n	["if"] = true,`n	["in"] = true,`n	["local"] = true,`n	["nil"] = true,`n	["not"] = true,`n	["or"] = true,`n	["repeat"] = true,`n	["return"] = true,`n	["then"] = true,`n	["true"] = true,`n	["until"]= true,`n	["while"] = true,`n}`n`nlocal function tryWrite( sLine, regex, colour )`n	local match = string.match( sLine, regex )`n	if match then`n		if type(colour) == "number" then`n			term.setTextColour( colour )`n		else`n			term.setTextColour( colour(match) )`n		end`n		term.write( match )`n		term.setTextColour( textColour )`n		return string.sub( sLine, string.len(match) + 1 )`n	end`n	return nil`nend`n`nlocal function writeHighlighted( sLine )`n	while string.len(sLine) > 0 do	`n		sLine = `n			tryWrite( sLine, "^%-%-%[%[.-%]%]", commentColour ) or`n			tryWrite( sLine, "^%-%-.*", commentColour ) or`n			tryWrite( sLine, "^\".-[^\\]\"", stringColour ) or`n			tryWrite( sLine, "^\'.-[^\\]\'", stringColour ) or`n			tryWrite( sLine, "^%[%[.-%]%]", stringColour ) or`n			tryWrite( sLine, "^[%w_]+", function( match )`n				if tKeywords[ match ] then`n					return keywordColour`n				end`n				return textColour`n			end ) or`n			tryWrite( sLine, "^[^%w_]", textColour )`n	end`nend`n`nlocal function redrawText()`n	for y=1,h-1 do`n		term.setCursorPos( 1 - scrollX, y )`n		term.clearLine()`n`n		local sLine = tLines[ y + scrollY ]`n		if sLine ~= nil then`n			writeHighlighted( sLine )`n		end`n	end`n	term.setCursorPos( x - scrollX, y - scrollY )`nend`n`nlocal function redrawLine(_nY)`n	local sLine = tLines[_nY]`n	term.setCursorPos( 1 - scrollX, _nY - scrollY )`n	term.clearLine()`n	writeHighlighted( sLine )`n	term.setCursorPos( x - scrollX, _nY - scrollY )`nend`n`nlocal function redrawMenu()`n    -- Clear line`n    term.setCursorPos( 1, h )`n	term.clearLine()`n`n    -- Draw line numbers`n    term.setCursorPos( w - string.len( "Ln "..y ) + 1, h )`n    term.setTextColour( highlightColour )`n    term.write( "Ln " )`n    term.setTextColour( textColour )`n    term.write( y )`n`n    term.setCursorPos( 1, h )`n	if bMenu then`n        -- Draw menu`n		term.setTextColour( textColour )`n		for nItem,sItem in pairs( tMenuItems ) do`n			if nItem == nMenuItem then`n				term.setTextColour( highlightColour )`n				term.write( "[" )`n				term.setTextColour( textColour )`n				term.write( sItem )`n				term.setTextColour( highlightColour )`n				term.write( "]" )`n        		term.setTextColour( textColour )`n			else`n				term.write( " "..sItem.." " )`n			end`n		end`n    else`n        -- Draw status`n        term.setTextColour( highlightColour )`n        term.write( sStatus )`n        term.setTextColour( textColour )`n    end`n`n	-- Reset cursor`n	term.setCursorPos( x - scrollX, y - scrollY )`nend`n`nlocal tMenuFuncs = { `n	Save=function()`n		if bReadOnly then`n			sStatus = "Access denied"`n		else`n			local ok, err = save( sPath )`n			if ok then`n				sStatus="Saved to "..sPath`n			else`n				sStatus="Error saving to "..sPath`n			end`n		end`n		redrawMenu()`n	end,`n	Print=function()`n		local printer = peripheral.find( "printer" )`n		if not printer then`n			sStatus = "No printer attached"`n			return`n		end`n`n		local nPage = 0`n		local sName = fs.getName( sPath )`n		if printer.getInkLevel() < 1 then`n			sStatus = "Printer out of ink"`n			return`n		elseif printer.getPaperLevel() < 1 then`n			sStatus = "Printer out of paper"`n			return`n		end`n`n		local screenTerminal = term.current()`n		local printerTerminal = {`n			getCursorPos = printer.getCursorPos,`n			setCursorPos = printer.setCursorPos,`n			getSize = printer.getPageSize,`n			write = printer.write,`n		}`n		printerTerminal.scroll = function()`n			if nPage == 1 then`n				printer.setPageTitle( sName.." (page "..nPage..")" )			`n			end`n			`n			while not printer.newPage()	do`n				if printer.getInkLevel() < 1 then`n					sStatus = "Printer out of ink, please refill"`n				elseif printer.getPaperLevel() < 1 then`n					sStatus = "Printer out of paper, please refill"`n				else`n					sStatus = "Printer output tray full, please empty"`n				end`n	`n				term.redirect( screenTerminal )`n				redrawMenu()`n				term.redirect( printerTerminal )`n				`n				local timer = os.startTimer(0.5)`n				sleep(0.5)`n			end`n`n			nPage = nPage + 1`n			if nPage == 1 then`n				printer.setPageTitle( sName )`n			else`n				printer.setPageTitle( sName.." (page "..nPage..")" )`n			end`n		end`n		`n		bMenu = false`n		term.redirect( printerTerminal )`n		local ok, error = pcall( function()`n			term.scroll()`n			for n, sLine in ipairs( tLines ) do`n				print( sLine )`n			end`n		end )`n        term.redirect( screenTerminal )`n		if not ok then`n			print( error )`n		end`n		`n		while not printer.endPage() do`n			sStatus = "Printer output tray full, please empty"`n			redrawMenu()`n			sleep( 0.5 )`n		end`n		bMenu = true`n			`n		if nPage > 1 then`n			sStatus = "Printed "..nPage.." Pages"`n		else`n			sStatus = "Printed 1 Page"`n		end`n		redrawMenu()`n	end,`n	Exit=function()`n		bRunning = false`n	end`n}`n`nlocal function doMenuItem( _n )`n	tMenuFuncs[tMenuItems[_n]]()`n	if bMenu then`n		bMenu = false`n		term.setCursorBlink( true )`n	end`n	redrawMenu()`nend`n`nlocal function setCursor( x, y )`n	local screenX = x - scrollX`n	local screenY = y - scrollY`n	`n	local bRedraw = false`n	if screenX < 1 then`n		scrollX = x - 1`n		screenX = 1`n		bRedraw = true`n	elseif screenX > w then`n		scrollX = x - w`n		screenX = w`n		bRedraw = true`n	end`n	`n	if screenY < 1 then`n		scrollY = y - 1`n		screenY = 1`n		bRedraw = true`n	elseif screenY > h-1 then`n		scrollY = y - (h-1)`n		screenY = h-1`n		bRedraw = true`n	end`n	`n	if bRedraw then`n		redrawText()`n	end`n	term.setCursorPos( screenX, screenY )`n	`n	-- Statusbar now pertains to menu, it would probably be safe to redraw the menu on every key event.`n	redrawMenu()`nend`n`n-- Actual program functionality begins`nload(sPath)`n`nterm.setBackgroundColour( bgColour )`nterm.clear()`nterm.setCursorPos(x,y)`nterm.setCursorBlink( true )`n`nredrawText()`nredrawMenu()`n`n-- Handle input`nwhile bRunning do`n	local sEvent, param, param2, param3 = os.pullEvent()`n	if sEvent == "key" then`n		if param == keys.up then`n			-- Up`n			if not bMenu then`n				if y > 1 then`n					-- Move cursor up`n					y = y - 1`n					x = math.min( x, string.len( tLines[y] ) + 1 )`n					setCursor( x, y )`n				end`n			end`n		elseif param == keys.down then`n			-- Down`n			if not bMenu then`n				-- Move cursor down`n				if y < #tLines then`n					y = y + 1`n					x = math.min( x, string.len( tLines[y] ) + 1 )`n					setCursor( x, y )`n				end`n			end`n		elseif param == keys.tab then`n			-- Tab`n			if not bMenu and not bReadOnly then`n				-- Indent line`n				tLines[y]="  "..tLines[y]`n				x = x + 2`n				setCursor( x, y )`n				redrawLine(y)`n			end`n		elseif param == keys.pageUp then`n			-- Page Up`n			if not bMenu then`n				-- Move up a page`n				if y - (h - 1) >= 1 then`n					y = y - (h - 1)`n				else`n					y = 1`n				end`n				x = math.min( x, string.len( tLines[y] ) + 1 )`n				setCursor( x, y )`n			end`n		elseif param == keys.pageDown then`n			-- Page Down`n			if not bMenu then`n				-- Move down a page`n				if y + (h - 1) <= #tLines then`n					y = y + (h - 1)`n				else`n					y = #tLines`n				end`n				x = math.min( x, string.len( tLines[y] ) + 1 )`n				setCursor( x, y )`n			end`n		elseif param == keys.home then`n			-- Home`n			if not bMenu then`n				-- Move cursor to the beginning`n				x=1`n				setCursor(x,y)`n			end`n		elseif param == keys["end"] then`n			-- End`n			if not bMenu then`n				-- Move cursor to the end`n				x = string.len( tLines[y] ) + 1`n				setCursor(x,y)`n			end`n		elseif param == keys.left then`n			-- Left`n			if not bMenu then`n				if x > 1 then`n					-- Move cursor left`n					x = x - 1`n				elseif x==1 and y>1 then`n					x = string.len( tLines[y-1] ) + 1`n					y = y - 1`n				end`n				setCursor( x, y )`n			else`n				-- Move menu left`n				nMenuItem = nMenuItem - 1`n				if nMenuItem < 1 then`n					nMenuItem = #tMenuItems`n				end`n				redrawMenu()`n			end`n		elseif param == keys.right then`n			-- Right`n			if not bMenu then`n				if x < string.len( tLines[y] ) + 1 then`n					-- Move cursor right`n					x = x + 1`n				elseif x==string.len( tLines[y] ) + 1 and y<#tLines then`n					x = 1`n					y = y + 1`n				end`n				setCursor( x, y )`n			else`n				-- Move menu right`n				nMenuItem = nMenuItem + 1`n				if nMenuItem > #tMenuItems then`n					nMenuItem = 1`n				end`n				redrawMenu()`n			end`n		elseif param == keys.delete then`n			-- Delete`n			if not bMenu and not bReadOnly then`n				if  x < string.len( tLines[y] ) + 1 then`n					local sLine = tLines[y]`n					tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)`n					redrawLine(y)`n				elseif y<#tLines then`n					tLines[y] = tLines[y] .. tLines[y+1]`n					table.remove( tLines, y+1 )`n					redrawText()`n					redrawMenu()`n				end`n			end`n		elseif param == keys.backspace then`n			-- Backspace`n			if not bMenu and not bReadOnly then`n				if x > 1 then`n					-- Remove character`n					local sLine = tLines[y]`n					tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)`n					redrawLine(y)`n			`n					x = x - 1`n					setCursor( x, y )`n				elseif y > 1 then`n					-- Remove newline`n					local sPrevLen = string.len( tLines[y-1] )`n					tLines[y-1] = tLines[y-1] .. tLines[y]`n					table.remove( tLines, y )`n					redrawText()`n				`n					x = sPrevLen + 1`n					y = y - 1`n					setCursor( x, y )`n				end`n			end`n		elseif param == keys.enter then`n			-- Enter`n			if not bMenu and not bReadOnly then`n				-- Newline`n				local sLine = tLines[y]`n				local _,spaces=string.find(sLine,"^[ ]+")`n				if not spaces then`n					spaces=0`n				end`n				tLines[y] = string.sub(sLine,1,x-1)`n				table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )`n				redrawText()`n			`n				x = spaces+1`n				y = y + 1`n				setCursor( x, y )`n			elseif bMenu then`n				-- Menu selection`n				doMenuItem( nMenuItem )`n			end`n		elseif param == keys.leftCtrl or param == keys.rightCtrl then`n			-- Menu toggle`n			bMenu = not bMenu`n			if bMenu then`n				term.setCursorBlink( false )`n			else`n				term.setCursorBlink( true )`n			end`n			redrawMenu()`n		end`n		`n	elseif sEvent == "char" then`n		if not bMenu and not bReadOnly then`n			-- Input text`n			local sLine = tLines[y]`n			tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)`n			redrawLine(y)`n		`n			x = x + 1`n			setCursor( x, y )`n		elseif bMenu then`n			-- Select menu items`n			for n,sMenuItem in ipairs( tMenuItems ) do`n				if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then`n					doMenuItem( n )`n					break`n				end`n			end`n		end`n`n	elseif sEvent == "paste" then`n		if not bMenu and not bReadOnly then`n			-- Input text`n			local sLine = tLines[y]`n			tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)`n			redrawLine(y)`n`n			x = x + string.len( param )`n			setCursor( x, y )`n		end`n		`n	elseif sEvent == "mouse_click" then`n		if not bMenu then`n			if param == 1 then`n				-- Left click`n				local cx,cy = param2, param3`n				if cy < h then`n					y = math.min( math.max( scrollY + cy, 1 ), #tLines )`n					x = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[y] ) + 1 )`n					setCursor( x, y )`n				end`n			end`n		end`n		`n	elseif sEvent == "mouse_scroll" then`n		if not bMenu then`n			if param == -1 then`n				-- Scroll up`n				if scrollY > 0 then`n					-- Move cursor up`n					scrollY = scrollY - 1`n					redrawText()`n				end`n			`n			elseif param == 1 then`n				-- Scroll down`n				local nMaxScroll = #tLines - (h-1)`n				if scrollY < nMaxScroll then`n					-- Move cursor down`n					scrollY = scrollY + 1`n					redrawText()`n				end`n				`n			end`n		end`n`n	elseif sEvent == "term_resize" then`n	    w,h = term.getSize()`n        setCursor( x, y )`n        redrawMenu()`n        redrawText()`n`n	end`nend`n`n-- Cleanup`nterm.clear()`nterm.setCursorBlink( false )`nterm.setCursorPos( 1, 1 )`n`n/rom/programs/eject/@/`n-- Get arguments`nlocal tArgs = { ... }`nif #tArgs == 0 then`n	print( "Usage: eject <drive>" )`n	return`nend`n`nlocal sDrive = tArgs[1]`n`n-- Check the disk exists`nlocal bPresent = disk.isPresent( sDrive )`nif not bPresent then`n	print( "Nothing in "..sDrive.." drive" )`n	return`nend`n`ndisk.eject( sDrive )`n`n/rom/programs/exit/@/shell.exit()`n`n/rom/programs/gps/@/`nlocal function printUsage()`n	print( "Usages:" )`n	print( "gps host" )`n	print( "gps host <x> <y> <z>" )`n	print( "gps locate" )`nend`n`nlocal tArgs = { ... }`nif #tArgs < 1 then`n	printUsage()`n	return`nend`n	`nlocal sCommand = tArgs[1]`nif sCommand == "locate" then`n	-- "gps locate"`n	-- Just locate this computer (this will print the results)`n	gps.locate( 2, true )`n	`nelseif sCommand == "host" then`n	-- "gps host"`n	-- Act as a GPS host`n	if pocket then`n	    print( "GPS Hosts must be stationary" )`n	    return`n	end`n`n	-- Find a modem`n	local sModemSide = nil`n	for n,sSide in ipairs( rs.getSides() ) do`n		if peripheral.getType( sSide ) == "modem" and peripheral.call( sSide, "isWireless" ) then	`n			sModemSide = sSide`n			break`n		end`n	end`n`n	if sModemSide == nil then`n		print( "No wireless modems found. 1 required." )`n		return`n	end`n	`n	-- Open a channel`n	local modem = peripheral.wrap( sModemSide )`n    print( "Opening channel on modem "..sModemSide )`n    modem.open( gps.CHANNEL_GPS )`n`n	-- Determine position`n	local x,y,z`n	if #tArgs >= 4 then`n		-- Position is manually specified`n		x = tonumber(tArgs[2])`n		y = tonumber(tArgs[3])`n		z = tonumber(tArgs[4])`n		if x == nil or y == nil or z == nil then`n			printUsage()`n			return`n		end`n		print( "Position is "..x..","..y..","..z )`n	else`n		-- Position is to be determined using locate		`n		x,y,z = gps.locate( 2, true )`n		if x == nil then`n			print( "Run \"gps host <x> <y> <z>\" to set position manually" )`n			if bCloseChannel then`n				print( "Closing GPS channel" )`n				modem.close( gps.CHANNEL_GPS )`n			end`n			return`n		end`n	end`n	`n	-- Serve requests indefinately`n	local nServed = 0`n	while true do`n		local e, p1, p2, p3, p4, p5 = os.pullEvent( "modem_message" )`n		if e == "modem_message" then`n			-- We received a message from a modem`n			local sSide, sChannel, sReplyChannel, sMessage, nDistance = p1, p2, p3, p4, p5`n			if sSide == sModemSide and sChannel == gps.CHANNEL_GPS and sMessage == "PING" then`n				-- We received a ping message on the GPS channel, send a response`n				modem.transmit( sReplyChannel, gps.CHANNEL_GPS, { x, y, z } )`n			`n				-- Print the number of requests handled`n				nServed = nServed + 1`n				if nServed > 1 then`n					local x,y = term.getCursorPos()`n					term.setCursorPos(1,y-1)`n				end`n				print( nServed.." GPS requests served" )`n			end`n		end`n	end`n	`n    print( "Closing channel" )`n    modem.close( gps.CHANNEL_GPS )`n`nelse`n	-- "gps somethingelse"`n	-- Error`n	printUsage()`n	`nend`n`n/rom/programs/help/@/tArgs = { ... }`nif #tArgs > 0 then`n	sTopic = tArgs[1]`nelse`n	sTopic = "intro"`nend`n`nif sTopic == "index" then`n	print( "Help topics availiable:" )`n	local tTopics = help.topics()`n	textutils.pagedTabulate( tTopics )`n	return`nend`n	`nlocal w,h = term.getSize()`nlocal sFile = help.lookup( sTopic )`nlocal file = ((sFile ~= nil) and io.open( sFile )) or nil`nlocal nLinesPrinted = 0`nif file then`n	local sLine = file:read()`n	local nLines = 0`n	while sLine do`n		nLines = nLines + textutils.pagedPrint( sLine, (h-3) - nLines )`n    	sLine = file:read()`n    end`n	file:close()`nelse`n	print( "No help available" )`nend`n`n/rom/programs/id/@/`nlocal sDrive = nil`nlocal tArgs = { ... }`nif #tArgs > 0 then`n	sDrive = tostring( tArgs[1] )`nend`n`nif sDrive == nil then`n	print( "This is computer #"..os.getComputerID() )`n	`n	local label = os.getComputerLabel()`n	if label then`n		print( "This computer is labelled \""..label.."\"" )`n	end`n`nelse`n	local bData = disk.hasData( sDrive )`n	if not bData then`n		print( "No disk in drive "..sDrive )`n		return`n	end`n	`n	print( "The disk is #"..disk.getID( sDrive ) )`n`n	local label = disk.getLabel( sDrive )`n	if label then`n		print( "The disk is labelled \""..label.."\"" )`n	end`nend`n`n`n/rom/programs/label/@/`nlocal function printUsage()`n	print( "Usages:" )`n	print( "label get" )`n	print( "label get <drive>" )`n	print( "label set <text>" )`n	print( "label set <drive> <text>" )`n	print( "label clear" )`n	print( "label clear <drive>" )`nend`n`nlocal function checkDrive( sDrive )`n    if peripheral.getType( sDrive ) == "drive" then`n        -- Check the disk exists`n        local bData = disk.hasData( sDrive )`n        if not bData then`n            print( "No disk in "..sDrive.." drive" )`n            return false`n        end`n    else`n	    print( "No disk drive named "..sDrive )`n        return false`n	end`n	return true`nend`n`nlocal function get( sDrive )`n	if sDrive ~= nil then`n	    if checkDrive( sDrive ) then`n            local sLabel = disk.getLabel( sDrive )`n            if sLabel then`n                print( "Disk label is \""..sLabel.."\"" )`n            else`n                print( "No Disk label" )`n            end`n        end`n	else`n		local sLabel = os.getComputerLabel()`n		if sLabel then`n			print( "Computer label is \""..sLabel.."\"" )`n		else`n			print( "No Computer label" )`n		end`n	end`nend`n`nlocal function set( sDrive, sText )`n	if sDrive ~= nil then`n	    if checkDrive( sDrive ) then`n            disk.setLabel( sDrive, sText )`n            local sLabel = disk.getLabel( sDrive )`n            if sLabel then`n                print( "Disk label set to \""..sLabel.."\"" )`n            else`n                print( "Disk label cleared" )`n            end`n        end`n	else`n		os.setComputerLabel( sText )`n		local sLabel = os.getComputerLabel()`n		if sLabel then`n			print( "Computer label set to \""..sLabel.."\"" )`n		else`n			print( "Computer label cleared" )`n		end`n	end`nend`n`nlocal tArgs = { ... }`nlocal sCommand = tArgs[1]`nif sCommand == "get" then`n    -- Get a label`n    if #tArgs == 1 then`n        get( nil )`n    elseif #tArgs == 2 then`n        get( tArgs[2] )`n    else`n        printUsage()`n    end`nelseif sCommand == "set" then`n    -- Set a label`n    if #tArgs == 2 then`n        set( nil, tArgs[2] )`n    elseif #tArgs == 3 then`n        set( tArgs[2], tArgs[3] )`n    else`n        printUsage()`n    end`nelseif sCommand == "clear" then`n    -- Clear a label`n    if #tArgs == 1 then`n        set( nil, nil )`n    elseif #tArgs == 2 then`n        set( tArgs[2], nil )`n    else`n        printUsage()`n    end`nelse`n    printUsage()`nend`n`n/rom/programs/list/@/`nlocal tArgs = { ... }`n`n-- Get all the files in the directory`nlocal sDir = shell.dir()`nif tArgs[1] ~= nil then`n	sDir = shell.resolve( tArgs[1] )`nend`n`n-- Sort into dirs/files, and calculate column count`nlocal tAll = fs.list( sDir )`nlocal tFiles = {}`nlocal tDirs = {}`n`nfor n, sItem in pairs( tAll ) do`n	if string.sub( sItem, 1, 1 ) ~= "." then`n		local sPath = fs.combine( sDir, sItem )`n		if fs.isDir( sPath ) then`n			table.insert( tDirs, sItem )`n		else`n			table.insert( tFiles, sItem )`n		end`n	end`nend`ntable.sort( tDirs )`ntable.sort( tFiles )`n`nif term.isColour() then`n	textutils.pagedTabulate( colors.green, tDirs, colors.white, tFiles )`nelse`n	textutils.pagedTabulate( tDirs, tFiles )`nend`n`n/rom/programs/lua/@/`nlocal tArgs = { ... }`nif #tArgs > 0 then`n	print( "This is an interactive Lua prompt." )`n	print( "To run a lua program, just type its name." )`n	return`nend`n`nlocal bRunning = true`nlocal tCommandHistory = {}`nlocal tEnv = {`n	["exit"] = function()`n		bRunning = false`n	end,`n	["_echo"] = function( ... )`n	    return ...`n	end,`n}`nsetmetatable( tEnv, { __index = getfenv() } )`n`nif term.isColour() then`n	term.setTextColour( colours.yellow )`nend`nprint( "Interactive Lua prompt." )`nprint( "Call exit() to exit." )`nterm.setTextColour( colours.white )`n`nwhile bRunning do`n	--if term.isColour() then`n	--	term.setTextColour( colours.yellow )`n	--end`n	write( "lua> " )`n	--term.setTextColour( colours.white )`n	`n	local s = read( nil, tCommandHistory )`n	table.insert( tCommandHistory, s )`n	`n	local nForcePrint = 0`n	local func, e = loadstring( s, "lua" )`n	local func2, e2 = loadstring( "return _echo("..s..");", "lua" )`n	if not func then`n		if func2 then`n			func = func2`n			e = nil`n			nForcePrint = 1`n		end`n	else`n		if func2 then`n			func = func2`n		end`n	end`n	`n	if func then`n        setfenv( func, tEnv )`n        local tResults = { pcall( func ) }`n        if tResults[1] then`n        	local n = 1`n        	while (tResults[n + 1] ~= nil) or (n <= nForcePrint) do`n        	    local value = tResults[ n + 1 ]`n        	    if type( value ) == "table" then`n            	    local ok, serialised = pcall( textutils.serialise, value )`n            	    if ok then`n            	        print( serialised )`n            	    else`n            	        print( tostring( value ) )`n            	    end`n            	else`n            	    print( tostring( value ) )`n            	end`n        		n = n + 1`n        	end`n        else`n        	printError( tResults[2] )`n        end`n    else`n    	printError( e )`n    end`n    `nend`n`n/rom/programs/mkdir/@/local tArgs = { ... }`nif #tArgs < 1 then`n	print( "Usage: mkdir <path>" )`n	return`nend`n`nlocal sNewDir = shell.resolve( tArgs[1] )`nfs.makeDir( sNewDir )`n`n`n/rom/programs/monitor/@/`nfunction printUsage()`n	print( "Usage: monitor <name> <program> <arguments>" )`n	return`nend`n`nlocal tArgs = { ... }`nif #tArgs < 2 then`n	printUsage()`n	return`nend`n`nlocal sName = tArgs[1]`nif peripheral.getType( sName ) ~= "monitor" then`n	print( "No monitor named ".. sName )`n	return`nend`n`nlocal sProgram = tArgs[2]`nlocal sPath = shell.resolveProgram( sProgram )`nif sPath == nil then`n	print( "No such program: "..sProgram )`n	return`nend`n`nprint( "Running "..sProgram.." on monitor "..sName )`n`nlocal monitor = peripheral.wrap( sName )`nlocal previousTerm = term.redirect( monitor )`n`nlocal co = coroutine.create( function()`n    shell.run( sProgram, unpack( tArgs, 3 ) )`nend )`n`nlocal function resume( ... )`n    local ok, param = coroutine.resume( co, ... )`n    if not ok then`n    	printError( param )`n    end`n    return param`nend`n`nlocal ok, param = pcall( function()`n	local sFilter = resume()`n	while coroutine.status( co ) ~= "dead" do`n		local tEvent = { os.pullEventRaw() }`n		if sFilter == nil or tEvent[1] == sFilter or tEvent[1] == "terminate" then`n			sFilter = resume( unpack( tEvent ) )`n		end`n		if coroutine.status( co ) ~= "dead" and (sFilter == nil or sFilter == "mouse_click") then`n			if tEvent[1] == "monitor_touch" and tEvent[2] == sName then`n				sFilter = resume( "mouse_click", 1, unpack( tEvent, 3 ) )`n			end`n		end`n		if coroutine.status( co ) ~= "dead" and (sFilter == nil or sFilter == "term_resize") then`n			if tEvent[1] == "monitor_resize" and tEvent[2] == sName then`n				sFilter = resume( "term_resize" )`n			end`n		end`n	end`nend )`n`nterm.redirect( previousTerm )`nif not ok then`n	printError( param )`nend`n	`n`n/rom/programs/move/@/`nlocal tArgs = { ... }`nif #tArgs < 2 then`n	print( "Usage: mv <source> <destination>" )`n	return`nend`n`nlocal sSource = shell.resolve( tArgs[1] )`nlocal sDest = shell.resolve( tArgs[2] )`nlocal tFiles = fs.find( sSource )`nif #tFiles > 0 then`n    for n,sFile in ipairs( tFiles ) do`n        if fs.isDir( sDest ) then`n            fs.move( sFile, fs.combine( sDest, fs.getName(sFile) ) )`n        elseif #tFiles == 1 then`n            fs.move( sFile, sDest )`n        else`n            printError( "Cannot overwrite file multiple times" )`n            return`n        end`n    end`nelse`n    printError( "No matching files" )`nend`n`n/rom/programs/programs/@/`nlocal bAll = false`nlocal tArgs = { ... }`nif #tArgs > 0 and tArgs[1] == "all" then`n	bAll = true`nend`n`nlocal tPrograms = shell.programs( bAll )`ntextutils.pagedTabulate( tPrograms )`n`n/rom/programs/reboot/@/if term.isColour() then`n	term.setTextColour( colours.yellow )`nend`nprint( "Goodbye" )`nterm.setTextColour( colours.white )`n`nsleep( 1 )`nos.reboot()`n`n/rom/programs/redstone/@/`nlocal tArgs = { ... }`n`nlocal function printUsage()`n    print( "Usages:" )`n    print( "redstone probe" )`n    print( "redstone set <side> <value>" )`n    print( "redstone set <side> <color> <value>" )`n    print( "redstone pulse <side> <count> <period>" )`nend`n`nlocal sCommand = tArgs[1]`nif sCommand == "probe" then`n    -- "redstone probe"`n    -- Regular input`n    print( "Redstone inputs: " )`n`n    local count = 0`n    local bundledCount = 0`n    for n,sSide in ipairs( redstone.getSides() ) do`n        if redstone.getBundledInput( sSide ) > 0 then`n            bundledCount = bundledCount + 1`n        end`n        if redstone.getInput( sSide ) then`n            if count > 0 then`n                io.write( ", " )`n            end`n            io.write( sSide )`n            count = count + 1`n        end`n    end`n    if count > 0 then`n        print( "." )`n    else`n        print( "None." )`n    end`n`n    -- Bundled input`n    if bundledCount > 0 then`n        print()`n        print( "Bundled inputs:" )`n        for i,sSide in ipairs( redstone.getSides() ) do`n            local nInput = redstone.getBundledInput( sSide )`n            if nInput ~= 0 then`n                write( sSide..": " )`n                local count = 0`n                for sColour,nColour in pairs( colors ) do`n                    if type( nColour ) == "number" and colors.test( nInput, nColour ) then`n                        if count > 0 then`n                            write( ", " )`n                        end`n                        if term.isColour() then`n                            term.setTextColour( nColour )`n                        end`n                        write( sColour )`n                        if term.isColour() then`n                            term.setTextColour( colours.white )`n                        end`n                        count = count + 1`n                    end`n                end`n                print( "." )`n            end`n        end`n    end`n`nelseif sCommand == "pulse" then`n    -- "redstone pulse"`n    local sSide = tArgs[2]`n    local nCount = tonumber( tArgs[3] ) or 1`n    local nPeriod = tonumber( tArgs[4] ) or 0.5`n    for n=1,nCount do`n        redstone.setOutput( sSide, true )`n        sleep( nPeriod / 2 )`n        redstone.setOutput( sSide, false )`n        sleep( nPeriod / 2 )`n    end`n`nelseif sCommand == "set" then`n    -- "redstone set"`n    local sSide = tArgs[2]`n    if #tArgs > 3 then`n        -- Bundled cable output`n        local sColour = tArgs[3]`n        local nColour = colors[sColour] or colours[sColour]`n        if type(nColour) ~= "number" then`n            printError( "No such color" )`n            return`n        end`n`n        local sValue = tArgs[4]`n        if sValue == "true" then`n            rs.setBundledOutput( sSide, colors.combine( rs.getBundledOutput( sSide ), nColour ) )`n        elseif sValue == "false" then`n            rs.setBundledOutput( sSide, colors.subtract( rs.getBundledOutput( sSide ), nColour ) )`n        else`n            print( "Value must be boolean" )`n        end`n    else`n        -- Regular output`n        local sValue = tArgs[3]`n        local nValue = tonumber(sValue)`n        if sValue == "true" then`n            rs.setOutput( sSide, true )`n        elseif sValue == "false" then`n            rs.setOutput( sSide, false )`n        elseif nValue and nValue >= 0 and nValue <= 15 then`n            rs.setAnalogOutput( sSide, nValue )`n        else`n            print( "Value must be boolean or 0-15" )`n        end`n    end`n`nelse`n    -- Something else`n    printUsage()`n`nend`n`n/rom/programs/rename/@/local tArgs = { ... }`nif #tArgs < 2 then`n	print( "Usage: rename <source> <destination>" )`n	return`nend`n`nlocal sSource = shell.resolve( tArgs[1] )`nlocal sDest = shell.resolve( tArgs[2] )`nfs.move( sSource, sDest )`n`n/rom/programs/shell/@/`nlocal multishell = multishell`nlocal parentShell = shell`nlocal parentTerm = term.current()`n`nif multishell then`n    multishell.setTitle( multishell.getCurrent(), "shell" )`nend`n`nlocal bExit = false`nlocal sDir = (parentShell and parentShell.dir()) or ""`nlocal sPath = (parentShell and parentShell.path()) or ".:/rom/programs"`nlocal tAliases = (parentShell and parentShell.aliases()) or {}`nlocal tProgramStack = {}`n`nlocal shell = {}`nlocal tEnv = {`n	[ "shell" ] = shell,`n	[ "multishell" ] = multishell,`n}`n`n-- Colours`nlocal promptColour, textColour, bgColour`nif term.isColour() then`n	promptColour = colours.yellow`n	textColour = colours.white`n	bgColour = colours.black`nelse`n	promptColour = colours.white`n	textColour = colours.white`n	bgColour = colours.black`nend`n`nlocal function run( _sCommand, ... )`n	local sPath = shell.resolveProgram( _sCommand )`n	if sPath ~= nil then`n		tProgramStack[#tProgramStack + 1] = sPath`n		if multishell then`n		    multishell.setTitle( multishell.getCurrent(), fs.getName( sPath ) )`n		end`n   		local result = os.run( tEnv, sPath, ... )`n		tProgramStack[#tProgramStack] = nil`n		if multishell then`n		    if #tProgramStack > 0 then`n    		    multishell.setTitle( multishell.getCurrent(), fs.getName( tProgramStack[#tProgramStack] ) )`n    		else`n    		    multishell.setTitle( multishell.getCurrent(), "shell" )`n    		end`n		end`n		return result`n   	else`n    	printError( "No such program" )`n    	return false`n    end`nend`n`nlocal function tokenise( ... )`n    local sLine = table.concat( { ... }, " " )`n	local tWords = {}`n    local bQuoted = false`n    for match in string.gmatch( sLine .. "\"", "(.-)\"" ) do`n        if bQuoted then`n            table.insert( tWords, match )`n        else`n            for m in string.gmatch( match, "[^ \t]+" ) do`n                table.insert( tWords, m )`n            end`n        end`n        bQuoted = not bQuoted`n    end`n    return tWords`nend`n`n-- Install shell API`nfunction shell.run( ... )`n	local tWords = tokenise( ... )`n	local sCommand = tWords[1]`n	if sCommand then`n		return run( sCommand, unpack( tWords, 2 ) )`n	end`n	return false`nend`n`nfunction shell.exit()`n    bExit = true`nend`n`nfunction shell.dir()`n	return sDir`nend`n`nfunction shell.setDir( _sDir )`n	sDir = _sDir`nend`n`nfunction shell.path()`n	return sPath`nend`n`nfunction shell.setPath( _sPath )`n	sPath = _sPath`nend`n`nfunction shell.resolve( _sPath )`n	local sStartChar = string.sub( _sPath, 1, 1 )`n	if sStartChar == "/" or sStartChar == "\\" then`n		return fs.combine( "", _sPath )`n	else`n		return fs.combine( sDir, _sPath )`n	end`nend`n`nfunction shell.resolveProgram( _sCommand )`n	-- Substitute aliases firsts`n	if tAliases[ _sCommand ] ~= nil then`n		_sCommand = tAliases[ _sCommand ]`n	end`n`n    -- If the path is a global path, use it directly`n    local sStartChar = string.sub( _sCommand, 1, 1 )`n    if sStartChar == "/" or sStartChar == "\\" then`n    	local sPath = fs.combine( "", _sCommand )`n    	if fs.exists( sPath ) and not fs.isDir( sPath ) then`n			return sPath`n    	end`n		return nil`n    end`n    `n 	-- Otherwise, look on the path variable`n    for sPath in string.gmatch(sPath, "[^:]+") do`n    	sPath = fs.combine( shell.resolve( sPath ), _sCommand )`n    	if fs.exists( sPath ) and not fs.isDir( sPath ) then`n			return sPath`n    	end`n    end`n	`n	-- Not found`n	return nil`nend`n`nfunction shell.programs( _bIncludeHidden )`n	local tItems = {}`n	`n	-- Add programs from the path`n    for sPath in string.gmatch(sPath, "[^:]+") do`n    	sPath = shell.resolve( sPath )`n		if fs.isDir( sPath ) then`n			local tList = fs.list( sPath )`n			for n,sFile in pairs( tList ) do`n				if not fs.isDir( fs.combine( sPath, sFile ) ) and`n				   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= ".") then`n					tItems[ sFile ] = true`n				end`n			end`n		end`n    end	`n`n	-- Sort and return`n	local tItemList = {}`n	for sItem, b in pairs( tItems ) do`n		table.insert( tItemList, sItem )`n	end`n	table.sort( tItemList )`n	return tItemList`nend`n`nfunction shell.getRunningProgram()`n	if #tProgramStack > 0 then`n		return tProgramStack[#tProgramStack]`n	end`n	return nil`nend`n`nfunction shell.setAlias( _sCommand, _sProgram )`n	tAliases[ _sCommand ] = _sProgram`nend`n`nfunction shell.clearAlias( _sCommand )`n	tAliases[ _sCommand ] = nil`nend`n`nfunction shell.aliases()`n	-- Add aliases`n	local tCopy = {}`n	for sAlias, sCommand in pairs( tAliases ) do`n		tCopy[sAlias] = sCommand`n	end`n	return tCopy`nend`n`nif multishell then`n    function shell.openTab( ... )`n        local tWords = tokenise( ... )`n        local sCommand = tWords[1]`n        if sCommand then`n        	local sPath = shell.resolveProgram( sCommand )`n        	if sPath == "rom/programs/shell" then`n                return multishell.launch( tEnv, sPath, unpack( tWords, 2 ) )`n            elseif sPath ~= nil then`n                return multishell.launch( tEnv, "rom/programs/shell", sPath, unpack( tWords, 2 ) )`n            else`n                printError( "No such program" )`n            end`n        end`n    end`n`n    function shell.switchTab( nID )`n        multishell.setFocus( nID )`n    end`nend`n`nlocal tArgs = { ... }`nif #tArgs > 0 then`n    -- "shell x y z"`n    -- Run the program specified on the commandline`n    shell.run( ... )`n`nelse`n    -- "shell"`n    -- Print the header`n    term.setBackgroundColor( bgColour )`n    term.setTextColour( promptColour )`n    print( os.version() )`n    term.setTextColour( textColour )`n`n    -- Run the startup program`n    if parentShell == nil then`n        shell.run( "/rom/startup" )`n    end`n`n    -- Read commands and execute them`n    local tCommandHistory = {}`n    while not bExit do`n        term.redirect( parentTerm )`n        term.setBackgroundColor( bgColour )`n        term.setTextColour( promptColour )`n        write( shell.dir() .. "> " )`n        term.setTextColour( textColour )`n`n        local sLine = read( nil, tCommandHistory )`n        table.insert( tCommandHistory, sLine )`n        shell.run( sLine )`n    end`nend`n`n/rom/programs/shutdown/@/if term.isColour() then`n	term.setTextColour( colours.yellow )`nend`nprint( "Goodbye" )`nterm.setTextColour( colours.white )`n`nsleep( 1 )`nos.shutdown()`n`n/rom/programs/time/@/local nTime = os.time()`nlocal nDay = os.day()`nprint( "The time is "..textutils.formatTime( nTime, false ).." on Day "..nDay )`n`n/rom/programs/type/@/`nlocal tArgs = { ... }`nif #tArgs < 1 then`n	print( "Usage: type <path>" )`n  	return`nend`n`nlocal sPath = shell.resolve( tArgs[1] )`nif fs.exists( sPath ) then`n	if fs.isDir( sPath ) then`n		print( "directory" )`n	else`n		print( "file" )`n	end`nelse`n	print( "No such path" )`nend`n`n`n/rom/programs/advanced/bg/@/`nlocal tArgs = { ... }`nif #tArgs > 0 then`n    shell.openTab( unpack( tArgs ) )`nelse`n    shell.openTab( "shell" )`nend`n`n/rom/programs/advanced/fg/@/`nlocal tArgs = { ... }`nif #tArgs > 0 then`n    local nTask = shell.openTab( unpack( tArgs ) )`n    if nTask then`n        shell.switchTab( nTask )`n    end`nelse`n    local nTask = shell.openTab( "shell" )`n    if nTask then`n        shell.switchTab( nTask )`n    end`nend`n`n/rom/programs/advanced/multishell/@/`n-- Setup process switching`nlocal parentTerm = term.current()`nlocal w,h = parentTerm.getSize()`n`nlocal tProcesses = {}`nlocal nCurrentProcess = nil`nlocal nRunningProcess = nil`nlocal bShowMenu = false`nlocal bWindowsResized = false`n`nlocal function selectProcess( n )`n    if nCurrentProcess ~= n then`n        if nCurrentProcess then`n            local tOldProcess = tProcesses[ nCurrentProcess ]`n            tOldProcess.window.setVisible( false )`n        end`n        nCurrentProcess = n`n        if nCurrentProcess then`n            local tNewProcess = tProcesses[ nCurrentProcess ]`n            tNewProcess.window.setVisible( true )`n            tNewProcess.bInteracted = true`n        end`n    end`nend`n`nlocal function setProcessTitle( n, sTitle )`n    tProcesses[ n ].sTitle = sTitle`nend`n`nlocal function resumeProcess( nProcess, sEvent, ... )`n    local tProcess = tProcesses[ nProcess ]`n    local sFilter = tProcess.sFilter`n    if sFilter == nil or sFilter == sEvent or sEvent == "terminate" then`n        local nPreviousProcess = nRunningProcess`n        nRunningProcess = nProcess`n        term.redirect( tProcess.terminal )`n        local ok, result = coroutine.resume( tProcess.co, sEvent, ... )`n        tProcess.terminal = term.current()`n        if ok then`n            tProcess.sFilter = result`n        else`n            printError( result )`n        end`n        nRunningProcess = nPreviousProcess`n    end`nend`n`nlocal function launchProcess( tProgramEnv, sProgramPath, ... )`n    local tProgramArgs = { ... }`n    local nProcess = #tProcesses + 1`n    local tProcess = {}`n    tProcess.sTitle = fs.getName( sProgramPath )`n    if bShowMenu then`n        tProcess.window = window.create( parentTerm, 1, 2, w, h-1, false )`n    else`n        tProcess.window = window.create( parentTerm, 1, 1, w, h, false )`n    end`n    tProcess.co = coroutine.create( function()`n        os.run( tProgramEnv, sProgramPath, unpack( tProgramArgs ) )`n        if not tProcess.bInteracted then`n            term.setCursorBlink( false )`n            print( "Press any key to continue" )`n            os.pullEvent( "char" )`n        end`n    end )`n    tProcess.sFilter = nil`n    tProcess.terminal = tProcess.window`n    tProcess.bInteracted = false`n    tProcesses[ nProcess ] = tProcess`n    resumeProcess( nProcess )`n    return nProcess`nend`n`nlocal function cullProcess( nProcess )`n    local tProcess = tProcesses[ nProcess ]`n    if coroutine.status( tProcess.co ) == "dead" then`n        if nCurrentProcess == nProcess then`n            selectProcess( nil )`n        end`n        table.remove( tProcesses, nProcess )`n        if nCurrentProcess == nil then`n            if nProcess > 1 then`n                selectProcess( nProcess - 1 )`n            elseif #tProcesses > 0 then`n                selectProcess( 1 )`n            end`n        end`n        return true`n    end`n    return false`nend`n`nlocal function cullProcesses()`n    local culled = false`n    for n=#tProcesses,1,-1 do`n        culled = culled or cullProcess( n )`n    end`n    return culled`nend`n`n-- Setup the main menu`nlocal menuMainTextColor, menuMainBgColor, menuOtherTextColor, menuOtherBgColor`nif parentTerm.isColor() then`n    menuMainTextColor, menuMainBgColor = colors.yellow, colors.black`n    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray`nelse`n    menuMainTextColor, menuMainBgColor = colors.white, colors.black`n    menuOtherTextColor, menuOtherBgColor = colors.black, colors.white`nend`n`nlocal function redrawMenu()`n    if bShowMenu then`n        -- Draw menu`n        parentTerm.setCursorPos( 1, 1 )`n        parentTerm.setBackgroundColor( menuOtherBgColor )`n        parentTerm.clearLine()`n        for n=1,#tProcesses do`n            if n == nCurrentProcess then`n                parentTerm.setTextColor( menuMainTextColor )`n                parentTerm.setBackgroundColor( menuMainBgColor )`n            else`n                parentTerm.setTextColor( menuOtherTextColor )`n                parentTerm.setBackgroundColor( menuOtherBgColor )`n            end`n            parentTerm.write( " " .. tProcesses[n].sTitle .. " " )`n        end`n`n        -- Put the cursor back where it should be`n        local tProcess = tProcesses[ nCurrentProcess ]`n        if tProcess then`n            tProcess.window.restoreCursor()`n        end`n    end`nend`n`nlocal function resizeWindows()`n    local windowY, windowHeight`n    if bShowMenu then`n        windowY = 2`n        windowHeight = h-1`n    else`n        windowY = 1`n        windowHeight = h`n    end`n    for n=1,#tProcesses do`n        local tProcess = tProcesses[n]`n        local window = tProcess.window`n        local x,y = tProcess.window.getCursorPos()`n        if y > windowHeight then`n            tProcess.window.scroll( y - windowHeight )`n            tProcess.window.setCursorPos( x, windowHeight )`n        end`n        tProcess.window.reposition( 1, windowY, w, windowHeight )`n    end`n    bWindowsResized = true`nend`n`nlocal function setMenuVisible( bVis )`n    if bShowMenu ~= bVis then`n        bShowMenu = bVis`n        resizeWindows()`n        redrawMenu()`n    end`nend`n`nlocal multishell = {}`n`nfunction multishell.getFocus()`n    return nCurrentProcess`nend`n`nfunction multishell.setFocus( n )`n    if n >= 1 and n <= #tProcesses then`n        selectProcess( n )`n        redrawMenu()`n        return true`n    end`n    return false`nend`n`nfunction multishell.getTitle( n )`n    if n >= 1 and n <= #tProcesses then`n        return tProcesses[n].sTitle`n    end`n    return nil`nend`n`nfunction multishell.setTitle( n, sTitle )`n    if n >= 1 and n <= #tProcesses then`n        setProcessTitle( n, sTitle )`n        redrawMenu()`n    end`nend`n`nfunction multishell.getCurrent()`n    return nRunningProcess`nend`n`nfunction multishell.launch( tProgramEnv, sProgramPath, ... )`n    local previousTerm = term.current()`n    setMenuVisible( (#tProcesses + 1) >= 2 )`n    local nResult = launchProcess( tProgramEnv, sProgramPath, ... )`n    redrawMenu()`n    term.redirect( previousTerm )`n    return nResult`nend`n`nfunction multishell.getCount()`n    return #tProcesses`nend`n`n-- Begin`nparentTerm.clear()`nsetMenuVisible( false )`nselectProcess( launchProcess( {`n    ["shell"] = shell,`n    ["multishell"] = multishell,`n}, "/rom/programs/shell" ) )`nredrawMenu()`n`n-- Run processes`nwhile #tProcesses > 0 do`n    -- Get the event`n    local tEventData = { os.pullEventRaw() }`n    local sEvent = tEventData[1]`n    if sEvent == "term_resize" then`n        -- Resize event`n        w,h = parentTerm.getSize()`n        resizeWindows()`n        redrawMenu()`n`n    elseif sEvent == "char" or sEvent == "key" or sEvent == "paste" or sEvent == "terminate" then`n        -- Keyboard event`n        -- Passthrough to current process`n        resumeProcess( nCurrentProcess, unpack( tEventData ) )`n        if cullProcess( nCurrentProcess ) then`n            setMenuVisible( #tProcesses >= 2 )`n            redrawMenu()`n        end`n`n    elseif sEvent == "mouse_click" then`n        -- Click event`n        local button, x, y = tEventData[2], tEventData[3], tEventData[4]`n        if bShowMenu and y == 1 then`n            -- Switch process`n            local tabStart = 1`n            for n=1,#tProcesses do`n                tabEnd = tabStart + string.len( tProcesses[n].sTitle ) + 1`n                if x >= tabStart and x <= tabEnd then`n                    selectProcess( n )`n                    redrawMenu()`n                    break`n                end`n                tabStart = tabEnd + 1`n            end`n        else`n            -- Passthrough to current process`n            resumeProcess( nCurrentProcess, sEvent, button, x, (bShowMenu and y-1) or y )`n            if cullProcess( nCurrentProcess ) then`n                setMenuVisible( #tProcesses >= 2 )`n                redrawMenu()`n            end`n        end`n`n    elseif sEvent == "mouse_drag" or sEvent == "mouse_scroll" then`n        -- Other mouse event`n        local p1, x, y = tEventData[2], tEventData[3], tEventData[4]`n        if not (bShowMenu and y == 1) then`n            -- Passthrough to current process`n            resumeProcess( nCurrentProcess, sEvent, p1, x, (bShowMenu and y-1) or y )`n            if cullProcess( nCurrentProcess ) then`n                setMenuVisible( #tProcesses >= 2 )`n                redrawMenu()`n            end`n        end`n`n    else`n        -- Other event`n        -- Passthrough to all processes`n        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event`n        for n=1,nLimit do`n            resumeProcess( n, unpack( tEventData ) )`n        end`n        if cullProcesses() then`n            setMenuVisible( #tProcesses >= 2 )`n            redrawMenu()`n        end`n    end`n`n    if bWindowsResized then`n        -- Pass term_resize to all processes`n        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event`n        for n=1,nLimit do`n            resumeProcess( n, "term_resize" )`n        end`n        bWindowsResized = false`n        if cullProcesses() then`n            setMenuVisible( #tProcesses >= 2 )`n            redrawMenu()`n        end`n    end`nend`n`n-- Shutdown`nterm.redirect( parentTerm )`n/rom/programs/advanced`n`n/rom/programs/fun/adventure/@/`nlocal tBiomes = {`n	"in a forest",`n	"in a pine forest",`n	"knee deep in a swamp",`n	"in a mountain range",`n	"in a desert",`n	"in a grassy plain",`n	"in frozen tundra",`n}`n`nlocal function hasTrees( _nBiome )`n	return _nBiome <= 3`nend`n`nlocal function hasStone( _nBiome )`n	return _nBiome == 4`nend`n`nlocal function hasRivers( _nBiome )`n	return _nBiome ~= 3 and _nBiome ~= 5`nend`n`nlocal items = {`n	["no tea"] = {`n		droppable = false,`n		desc = "Pull yourself together man.",`n	},`n	["a pig"] = {`n		heavy = true,`n		creature = true,`n		drops = { "some pork" },`n		aliases = { "pig" },`n		desc = "The pig has a square nose.",`n	},`n	["a cow"] = {`n		heavy = true,`n		creature = true,`n		aliases = { "cow" },`n		desc = "The cow stares at you blankly.",`n	},`n	["a sheep"] = {`n		heavy = true,`n		creature = true,`n		hitDrops = { "some wool" },`n		aliases = { "sheep" },`n		desc = "The sheep is fluffy.",`n	},`n	["a chicken"] = {`n		heavy = true,`n		creature = true,`n		drops = { "some chicken" },`n		aliases = { "chicken" },`n		desc = "The chicken looks delicious.",`n	},`n	["a creeper"] = {`n		heavy = true,`n		creature = true,`n		monster = true,`n		aliases = { "creeper" },`n		desc = "The creeper needs a hug.",`n	},`n	["a skeleton"] = {`n		heavy = true,`n		creature = true,`n		monster = true,`n		aliases = { "skeleton" },`n		nocturnal = true,`n		desc = "The head bone's connected to the neck bone, the neck bone's connected to the chest bone, the chest bone's connected to the arm bone, the arm bone's connected to the bow, and the bow is pointed at you.",`n	},`n	["a zombie"] = {`n		heavy = true,`n		creature = true,`n		monster = true,`n		aliases = { "zombie" },`n		nocturnal = true,`n		desc = "All he wants to do is eat your brains.",`n	},`n	["a spider"] = {`n		heavy = true,`n		creature = true,`n		monster = true,`n		aliases = { "spider" },`n		desc = "Dozens of eyes stare back at you.",`n	},`n	["a cave entrance"] = {`n		heavy = true,`n		aliases = { "cave entance", "cave", "entrance" },`n		desc = "The entrance to the cave is dark, but it looks like you can climb down.",`n	},`n	["an exit to the surface"] = {`n		heavy = true,`n		aliases = { "exit to the surface", "exit", "opening" },`n		desc = "You can just see the sky through the opening.",`n	},`n	["a river"] = {`n		heavy = true,`n		aliases = { "river" },`n		desc = "The river flows majestically towards the horizon. It doesn't do anything else.",`n	},`n	["some wood"] = {`n		aliases = { "wood" },`n		material = true,`n		desc = "You could easilly craft this wood into planks.",`n	},`n	["some planks"] = {`n		aliases = { "planks", "wooden planks", "wood planks" },`n		desc = "You could easilly craft these planks into sticks.",`n	},`n	["some sticks"] = {`n		aliases = { "sticks", "wooden sticks", "wood sticks" },`n		desc = "A perfect handle for torches or a pickaxe.",`n	},`n	["a crafting table"] = {`n		aliases = { "crafting table", "craft table", "work bench", "workbench", "crafting bench", "table", },`n		desc = "It's a crafting table. I shouldn't tell you this, but these don't actually do anything in this game, you can craft tools whenever you like.",`n	},`n	["a furnace"] = {`n		aliases = { "furnace" },`n		desc = "It's a furnace. Between you and me, these don't actually do anything in this game.",`n	},`n	["a wooden pickaxe"] = {`n		aliases = { "pickaxe", "pick", "wooden pick", "wooden pickaxe", "wood pick", "wood pickaxe" },`n		tool = true,`n		toolLevel = 1,`n		toolType = "pick",`n		desc = "The pickaxe looks good for breaking stone and coal.",`n	},`n	["a stone pickaxe"] = {`n		aliases = { "pickaxe", "pick", "stone pick", "stone pickaxe" },`n		tool = true,`n		toolLevel = 2,`n		toolType = "pick",`n		desc = "The pickaxe looks good for breaking iron.",`n	},`n	["an iron pickaxe"] = {`n		aliases = { "pickaxe", "pick", "iron pick", "iron pickaxe" },`n		tool = true,`n		toolLevel = 3,`n		toolType = "pick",`n		desc = "The pickaxe looks strong enough to break diamond.",`n	},`n	["a diamond pickaxe"] = {`n		aliases = { "pickaxe", "pick", "diamond pick", "diamond pickaxe" },`n		tool = true,`n		toolLevel = 4,`n		toolType = "pick",`n		desc = "Best. Pickaxe. Ever.",`n	},`n	["a wooden sword"] = {`n		aliases = { "sword", "wooden sword", "wood sword" },`n		tool = true,`n		toolLevel = 1,`n		toolType = "sword",`n		desc = "Flimsy, but better than nothing.",`n	},`n	["a stone sword"] = {`n		aliases = { "sword", "stone sword" },`n		tool = true,`n		toolLevel = 2,`n		toolType = "sword",`n		desc = "A pretty good sword.",`n	},`n	["an iron sword"] = {`n		aliases = { "sword", "iron sword" },`n		tool = true,`n		toolLevel = 3,`n		toolType = "sword",`n		desc = "This sword can slay any enemy.",`n	},`n	["a diamond sword"] = {`n		aliases = { "sword", "diamond sword" },`n		tool = true,`n		toolLevel = 4,`n		toolType = "sword",`n		desc = "Best. Sword. Ever.",`n	},`n	["a wooden shovel"] = {`n		aliases = { "shovel", "wooden shovel", "wood shovel" },`n		tool = true,`n		toolLevel = 1,`n		toolType = "shovel",`n		desc = "Good for digging holes.",`n	},`n	["a stone shovel"] = {`n		aliases = { "shovel", "stone shovel" },`n		tool = true,`n		toolLevel = 2,`n		toolType = "shovel",`n		desc = "Good for digging holes.",`n	},`n	["an iron shovel"] = {`n		aliases = { "shovel", "iron shovel" },`n		tool = true,`n		toolLevel = 3,`n		toolType = "shovel",`n		desc = "Good for digging holes.",`n	},`n	["a diamond shovel"] = {`n		aliases = { "shovel", "diamond shovel" },`n		tool = true,`n		toolLevel = 4,`n		toolType = "shovel",`n		desc = "Good for digging holes.",`n	},`n	["some coal"] = {`n		aliases = { "coal" },`n		ore = true,`n		toolLevel = 1,`n		toolType = "pick",`n		desc = "That coal looks useful for building torches, if only you had a pickaxe to mine it.",`n	},`n	["some dirt"] = {`n		aliases = { "dirt" },`n		material = true,`n		desc = "Why not build a mud hut?",`n	},`n	["some stone"] = {`n		aliases = { "stone", "cobblestone" },`n		material = true,`n		ore = true,`n		infinite = true,`n		toolLevel = 1,`n		toolType = "pick",`n		desc = "Stone is useful for building things, and making stone pickaxes.",`n	},`n	["some iron"] = {`n		aliases = { "iron" },`n		material = true,`n		ore = true,`n		toolLevel = 2,`n		toolType = "pick",`n		desc = "That iron looks mighty strong, you'll need a stone pickaxe to mine it.",`n	},`n	["some diamond"] = {`n		aliases = { "diamond", "diamonds" },`n		material = true,`n		ore = true,`n		toolLevel = 3,`n		toolType = "pick",`n		desc = "Sparkly, rare, and impossible to mine without an iron pickaxe.",`n	},`n	["some torches"] = {`n		aliases = { "torches", "torch" },`n		desc = "These won't run out for a while.",`n	},`n	["a torch"] = {`n		aliases = { "torch" },`n		desc = "Fire, fire, burn so bright, won't you light my cave tonight?",`n	},`n	["some wool"] = {`n		aliases = { "wool" },`n		material = true,`n		desc = "Soft and good for building.",`n	},`n	["some pork"] = {`n		aliases = { "pork", "porkchops" },`n		food = true,`n		desc = "Delicious and nutricious.",`n	},`n	["some chicken"] = {`n		aliases = { "chicken" },`n		food = true,`n		desc = "Finger licking good.",`n	},`n}`n`nlocal tAnimals = {`n	"a pig", "a cow", "a sheep", "a chicken",`n}`n`nlocal tMonsters = {`n	"a creeper", "a skeleton", "a zombie", "a spider"`n}`n`nlocal tRecipes = {`n	["some planks"] = { "some wood" },`n	["some sticks"] = { "some planks" },`n	["some sticks"] = { "some planks" },`n	["a crafting table"] = { "some planks" },`n	["a furnace"] = { "some stone" },`n	["some torches"] = { "some sticks", "some coal" },`n	`n	["a wooden pickaxe"] = { "some planks", "some sticks" },`n	["a stone pickaxe"] = { "some stone", "some sticks" },`n	["an iron pickaxe"] = { "some iron", "some sticks" },`n	["a diamond pickaxe"] = { "some diamond", "some sticks" },`n`n	["a wooden sword"] = { "some planks", "some sticks" },`n	["a stone sword"] = { "some stone", "some sticks" },`n	["an iron sword"] = { "some iron", "some sticks" },`n	["a diamond sword"] = { "some diamond", "some sticks" },`n`n	["a wooden shovel"] = { "some planks", "some sticks" },`n	["a stone shovel"] = { "some stone", "some sticks" },`n	["an iron shovel"] = { "some iron", "some sticks" },`n	["a diamond shovel"] = { "some diamond", "some sticks" },`n}`n`nlocal tGoWest = {`n	"(life is peaceful there)",`n	"(lots of open air)",`n	"(to begin life anew)",`n	"(this is what we'll do)",`n	"(sun in winter time)",`n	"(we will do just fine)",`n	"(where the skies are blue)",`n	"(this and more we'll do)",`n}`nlocal nGoWest = 0`n`nlocal bRunning = true`nlocal tMap = { { {}, }, }`nlocal x,y,z = 0,0,0`nlocal inventory = {`n	["no tea"] = items["no tea"],`n}`n`nlocal nTurn = 0`nlocal nTimeInRoom = 0`nlocal bInjured = false`n`nlocal tDayCycle = {`n	"It is daytime.",`n	"It is daytime.",`n	"It is daytime.",`n	"It is daytime.",`n	"It is daytime.",`n	"It is daytime.",`n	"It is daytime.",`n	"It is daytime.",`n	"The sun is setting.",`n	"It is night.",`n	"It is night.",`n	"It is night.",`n	"It is night.",`n	"It is night.",`n	"The sun is rising.",`n}`n`nlocal function getTimeOfDay()`n	return math.fmod( math.floor(nTurn/3), #tDayCycle ) + 1`nend`n`nlocal function isSunny()`n	return (getTimeOfDay() < 10)`nend`n`nlocal function getRoom( x, y, z, dontCreate )`n	tMap[x] = tMap[x] or {}`n	tMap[x][y] = tMap[x][y] or {}`n	if not tMap[x][y][z] and dontCreate ~= true then`n 		local room = {`n 			items = {},`n 			exits = {},`n 			nMonsters = 0,`n 		}`n		tMap[x][y][z] = room`n		`n		if y == 0 then`n			-- Room is above ground`n`n			-- Pick biome`n			room.nBiome = math.random( 1, #tBiomes )`n			room.trees = hasTrees( room.nBiome )`n		`n			-- Add animals`n			if math.random(1,3) == 1 then`n				for n = 1,math.random(1,2) do`n					local sAnimal = tAnimals[ math.random( 1, #tAnimals ) ]`n					room.items[ sAnimal ] = items[ sAnimal ]`n				end`n			end`n			`n			-- Add surface ore`n			if math.random(1,5) == 1 or hasStone( room.nBiome ) then`n				room.items[ "some stone" ] = items[ "some stone" ]`n			end`n			if math.random(1,8) == 1 then`n				room.items[ "some coal" ] = items[ "some coal" ]`n			end`n			if math.random(1,8) == 1 and hasRivers( room.nBiome ) then`n				room.items[ "a river" ] = items[ "a river" ]`n			end`n`n			-- Add exits`n			room.exits = {`n				["north"] = true,`n				["south"] = true,`n				["east"] = true,`n				["west"] = true,`n			}`n			if math.random(1,8) == 1 then`n				room.exits["down"] = true`n				room.items["a cave entrance"] = items["a cave entrance"]`n			end`n						`n		else`n			-- Room is underground`n			-- Add exits`n			local function tryExit( sDir, sOpp, x, y, z )`n				local adj = getRoom( x, y, z, true )`n				if adj then`n					if adj.exits[sOpp] then`n						room.exits[sDir] = true`n					end`n				else`n					if math.random(1,3) == 1 then`n						room.exits[sDir] = true`n					end`n				end`n			end`n			`n			if y == -1 then`n				local above = getRoom( x, y + 1, z )`n				if above.exits["down"] then`n					room.exits["up"] = true`n					room.items["an exit to the surface"] = items["an exit to the surface"]`n				end`n			else`n				tryExit( "up", "down", x, y + 1, z )`n			end`n			`n			if y > -3 then`n				tryExit( "down", "up", x, y - 1, z )`n			end`n			`n			tryExit( "east", "west", x - 1, y, z )`n			tryExit( "west", "east", x + 1, y, z )`n			tryExit( "north", "south", x, y, z + 1 )`n			tryExit( "south", "north", x, y, z - 1 )	`n			`n			-- Add ores`n			room.items[ "some stone" ] = items[ "some stone" ]`n			if math.random(1,3) == 1 then`n				room.items[ "some coal" ] = items[ "some coal" ]`n			end`n			if math.random(1,8) == 1 then`n				room.items[ "some iron" ] = items[ "some iron" ]`n			end`n			if y == -3 and math.random(1,15) == 1 then`n				room.items[ "some diamond" ] = items[ "some diamond" ]`n			end`n			`n			-- Turn out the lights`n			room.dark = true`n		end`n	end`n	return tMap[x][y][z]`nend`n`nlocal function itemize( t )`n	local item = next( t )`n	if item == nil then`n		return "nothing"`n	end`n	`n	local text = ""`n	while item do`n		text = text .. item`n		`n		local nextItem = next( t, item )`n		if nextItem ~= nil then`n			local nextNextItem = next( t, nextItem )`n			if nextNextItem == nil then`n				text = text .. " and "`n			else`n				text = text .. ", "`n			end`n		end`n		item = nextItem`n	end`n	return text`nend`n`nfunction findItem( _tList, _sQuery )`n	for sItem, tItem in pairs( _tList ) do`n		if sItem == _sQuery then`n			return sItem`n		end`n		if tItem.aliases ~= nil then`n			for n, sAlias in pairs( tItem.aliases ) do`n				if sAlias == _sQuery then`n					return sItem`n				end`n			end`n		end`n	end`n	return nil`nend`n`nlocal tMatches = {`n	["wait"] = {`n		"wait",`n	},`n	["look"] = {`n		"look at the ([%a ]+)",`n		"look at ([%a ]+)",`n		"look",`n		"inspect ([%a ]+)",`n		"inspect the ([%a ]+)",`n		"inspect",`n	},`n	["inventory"] = {`n		"check self",`n		"check inventory",`n		"inventory",`n		"i",`n	},`n	["go"] = {`n		"go (%a+)",`n		"travel (%a+)",`n		"walk (%a+)",`n		"run (%a+)",`n		"go",`n	},`n	["dig"] = {`n		"dig (%a+) using ([%a ]+)",`n		"dig (%a+) with ([%a ]+)",`n		"dig (%a+)",`n		"dig",`n	},`n	["take"] = {`n		"pick up the ([%a ]+)",`n		"pick up ([%a ]+)",`n		"pickup ([%a ]+)",`n		"take the ([%a ]+)",`n		"take ([%a ]+)",`n		"take",`n	},`n	["drop"] = {`n		"put down the ([%a ]+)",`n		"put down ([%a ]+)",`n		"drop the ([%a ]+)",`n		"drop ([%a ]+)",`n		"drop",`n	},`n	["place"] = {`n		"place the ([%a ]+)",`n		"place ([%a ]+)",`n		"place",`n	},`n	["cbreak"] = {`n		"punch the ([%a ]+)",`n		"punch ([%a ]+)",`n		"punch",`n		"break the ([%a ]+) with the ([%a ]+)",`n		"break ([%a ]+) with ([%a ]+) ",`n		"break the ([%a ]+)",`n		"break ([%a ]+)",`n		"break",`n	},`n	["mine"] = {`n		"mine the ([%a ]+) with the ([%a ]+)",`n		"mine ([%a ]+) with ([%a ]+)",`n		"mine ([%a ]+)",`n		"mine",`n	},`n	["attack"] = {`n		"attack the ([%a ]+) with the ([%a ]+)",`n		"attack ([%a ]+) with ([%a ]+)",`n		"attack ([%a ]+)",`n		"attack",`n		"kill the ([%a ]+) with the ([%a ]+)",`n		"kill ([%a ]+) with ([%a ]+)",`n		"kill ([%a ]+)",`n		"kill",`n		"hit the ([%a ]+) with the ([%a ]+)",`n		"hit ([%a ]+) with ([%a ]+)",`n		"hit ([%a ]+)",`n		"hit",`n	},`n	["craft"] = {`n		"craft a ([%a ]+)",`n		"craft some ([%a ]+)",`n		"craft ([%a ]+)",`n		"craft",`n		"make a ([%a ]+)",`n		"make some ([%a ]+)",`n		"make ([%a ]+)",`n		"make",`n	},`n	["build"] = {`n		"build ([%a ]+) out of ([%a ]+)",`n		"build ([%a ]+) from ([%a ]+)",`n		"build ([%a ]+)",`n		"build",`n	},`n	["eat"] = {`n		"eat a ([%a ]+)",`n		"eat the ([%a ]+)",`n		"eat ([%a ]+)",`n		"eat",`n	},`n	["help"] = {`n		"help me",`n		"help",`n	},`n	["exit"] = {`n		"exit",`n		"quit",`n		"goodbye",`n		"good bye",`n		"bye",`n		"farewell",`n	},`n}`n`nlocal commands = {}`nfunction doCommand( text )`n	if text == "" then`n		commands[ "noinput" ]()`n		return`n	end`n	`n	for sCommand, t in pairs( tMatches ) do`n		for n, sMatch in pairs( t ) do`n			local tCaptures = { string.match( text, "^" .. sMatch .. "$" ) }`n			if #tCaptures ~= 0 then`n				local fnCommand = commands[ sCommand ]`n				if #tCaptures == 1 and tCaptures[1] == sMatch then`n					fnCommand()`n				else`n					fnCommand( unpack( tCaptures ) )`n				end`n				return`n			end`n		end`n	end`n	commands[ "badinput" ]()`nend`n`nfunction commands.wait()`n	print( "Time passes..." )`nend`n`nfunction commands.look( _sTarget )`n	local room = getRoom( x,y,z )`n	if room.dark then`n		print( "It is pitch dark." )`n		return`n	end`n`n	if _sTarget == nil then`n		-- Look at the world`n		if y == 0 then`n			io.write( "You are standing " .. tBiomes[room.nBiome] .. ". " )`n			print( tDayCycle[ getTimeOfDay() ] )`n		else`n			io.write( "You are underground. " )`n			if next( room.exits ) ~= nil then`n				print( "You can travel "..itemize( room.exits ).."." )`n			else`n				print()`n			end`n		end`n		if next( room.items ) ~= nil then`n			print( "There is " .. itemize( room.items ) .. " here." )`n		end`n		if room.trees then`n			print( "There are trees here." )`n		end`n		`n	else`n		-- Look at stuff`n		if room.trees and (_sTarget == "tree" or _sTarget == "trees") then`n			print( "The trees look easy to break." )`n		elseif _sTarget == "self" or _sTarget == "myself" then`n			print( "Very handsome." )`n		else`n			local tItem = nil`n			local sItem = findItem( room.items, _sTarget )`n			if sItem then`n				tItem = room.items[sItem]`n			else`n				sItem = findItem( inventory, _sTarget )`n				if sItem then`n					tItem = inventory[sItem]`n				end`n			end`n			`n			if tItem then`n				print( tItem.desc or ("You see nothing special about "..sItem..".") )`n			else`n				print( "You don't see any ".._sTarget.." here." )`n			end`n		end`n	end`nend`n`nfunction commands.go( _sDir )`n	local room = getRoom( x,y,z )`n	if _sDir == nil then`n		print( "Go where?" )`n		return`n	end`n	`n	if nGoWest ~= nil then`n		if _sDir == "west" then`n			nGoWest = nGoWest + 1`n			if nGoWest > #tGoWest then`n				nGoWest = 1`n			end`n			print( tGoWest[ nGoWest ] )`n		else`n			if nGoWest > 0 or nTurn > 6 then`n				nGoWest = nil`n			end`n		end`n	end`n	`n	if room.exits[_sDir] == nil then`n		print( "You can't go that way." )`n		return`n	end`n	`n	if _sDir == "north" then`n		z = z + 1`n	elseif _sDir == "south" then`n		z = z - 1`n	elseif _sDir == "east" then`n		x = x - 1`n	elseif _sDir == "west" then`n		x = x + 1`n	elseif _sDir == "up" then`n		y = y + 1`n	elseif _sDir == "down" then`n		y = y - 1`n	else`n		print( "I don't understand that direction." )`n		return`n	end`n	`n	nTimeInRoom = 0`n	doCommand( "look" )`nend`n`nfunction commands.dig( _sDir, _sTool )`n	local room = getRoom( x,y,z )`n	if _sDir == nil then`n		print( "Dig where?" )`n		return`n	end`n	`n	local sTool = nil`n	local tTool = nil`n	if _sTool ~= nil then`n		sTool = findItem( inventory, _sTool )`n		if not sTool then`n			print( "You're not carrying a ".._sTool.."." )`n			return`n		end`n		tTool = inventory[ sTool ]`n	end`n	`n	local room = getRoom( x, y, z )`n	local bActuallyDigging = (room.exits[ _sDir ] ~= true)`n	if bActuallyDigging then`n		if sTool == nil or tTool.toolType ~= "pick" then`n			print( "You need to use a pickaxe to dig through stone." )`n			return`n		end`n	end`n	`n	if _sDir == "north" then`n		room.exits["north"] = true`n		z = z + 1`n		getRoom( x, y, z ).exits["south"] = true`n`n	elseif _sDir == "south" then`n		room.exits["south"] = true`n		z = z - 1`n		getRoom( x, y, z ).exits["north"] = true`n		`n	elseif _sDir == "east" then`n		room.exits["east"] = true`n		x = x - 1`n		getRoom( x, y, z ).exits["west"] = true`n		`n	elseif _sDir == "west" then`n		room.exits["west"] = true`n		x = x + 1`n		getRoom( x, y, z ).exits["east"] = true`n		`n	elseif _sDir == "up" then`n		if y == 0 then`n			print( "You can't dig that way." )`n			return`n		end`n`n		room.exits["up"] = true`n		if y == -1 then`n			room.items[ "an exit to the surface" ] = items[ "an exit to the surface" ]`n		end`n		y = y + 1`n		`n		room = getRoom( x, y, z )`n		room.exits["down"] = true`n		if y == 0 then`n			room.items[ "a cave entrance" ] = items[ "a cave entrance" ]`n		end`n		`n	elseif _sDir == "down" then`n		if y <= -3 then`n			print( "You hit bedrock." )`n			return`n		end`n`n		room.exits["down"] = true`n		if y == 0 then`n			room.items[ "a cave entrance" ] = items[ "a cave entrance" ]`n		end`n		y = y - 1`n		`n		room = getRoom( x, y, z )`n		room.exits["up"] = true`n		if y == -1 then`n			room.items[ "an exit to the surface" ] = items[ "an exit to the surface" ]`n		end`n		`n	else`n		print( "I don't understand that direction." )`n		return`n	end`n	`n	--`n	if bActuallyDigging then`n		if _sDir == "down" and y == -1 or`n		   _sDir == "up" and y == 0 then`n			inventory[ "some dirt" ] = items[ "some dirt" ]`n			inventory[ "some stone" ] = items[ "some stone" ]`n			print( "You dig ".._sDir.." using "..sTool.." and collect some dirt and stone." )`n		else`n			inventory[ "some stone" ] = items[ "some stone" ]`n			print( "You dig ".._sDir.." using "..sTool.." and collect some stone." )`n		end`n	end`n	`n	nTimeInRoom = 0`n	doCommand( "look" )`nend`n`nfunction commands.inventory()`n	print( "You are carrying " .. itemize( inventory ) .. "." )`nend`n`nfunction commands.drop( _sItem )`n	if _sItem == nil then`n		print( "Drop what?" )`n		return`n	end`n	`n	local room = getRoom( x,y,z )`n	local sItem = findItem( inventory, _sItem )`n	if sItem then`n		local tItem = inventory[ sItem ]`n		if tItem.droppable == false then`n			print( "You can't drop that." )`n		else`n			room.items[ sItem ] = tItem`n			inventory[ sItem ] = nil`n			print( "Dropped." )`n		end`n	else`n		print( "You don't have a ".._sItem.."." )`n	end`nend`n`nfunction commands.place( _sItem )`n	if _sItem == nil then`n		print( "Place what?" )`n		return`n	end`n	`n	if _sItem == "torch" or _sItem == "a torch" then`n		local room = getRoom( x,y,z )`n		if inventory["some torches"] or inventory["a torch"] then`n			inventory["a torch"] = nil`n			room.items["a torch"] = items["a torch"]`n			if room.dark then`n				print( "The cave lights up under the torchflame." )`n				room.dark = false`n			elseif y == 0 and not isSunny() then`n				print( "The night gets a little brighter." )`n			else`n				print( "Placed." )`n			end`n		else`n			print( "You don't have torches." )`n		end`n		return`n	end`n	`n	commands.drop( _sItem )`nend`n`nfunction commands.take( _sItem )`n	if _sItem == nil then`n		print( "Take what?" )`n		return`n	end`n`n	local room = getRoom( x,y,z )`n	local sItem = findItem( room.items, _sItem )`n	if sItem then`n		local tItem = room.items[ sItem ]`n		if tItem.heavy == true then`n			print( "You can't carry "..sItem.."." )`n		elseif tItem.ore == true then`n			print( "You need to mine this ore." )`n		else`n			if tItem.infinite ~= true then`n				room.items[ sItem ] = nil`n			end`n			inventory[ sItem ] = tItem`n			`n			if inventory["some torches"] and inventory["a torch"] then`n				inventory["a torch"] = nil`n			end`n			if sItem == "a torch" and y < 0 then`n				room.dark = true`n				print( "The cave plunges into darkness." )`n			else`n				print( "Taken." )`n			end`n		end`n	else`n		print( "You don't see a ".._sItem.." here." )`n	end`nend`n`nfunction commands.mine( _sItem, _sTool )`n	if _sItem == nil then`n		print( "Mine what?" )`n		return`n	end`n	if _sTool == nil then`n		print( "Mine ".._sItem.." with what?" )`n		return`n	end	`n	commands.cbreak( _sItem, _sTool )`nend`n`nfunction commands.attack( _sItem, _sTool )`n	if _sItem == nil then`n		print( "Attack what?" )`n		return`n	end`n	commands.cbreak( _sItem, _sTool )`nend`n`nfunction commands.cbreak( _sItem, _sTool )`n	if _sItem == nil then`n		print( "Break what?" )`n		return`n	end`n	`n	local sTool = nil`n	if _sTool ~= nil then`n		sTool = findItem( inventory, _sTool )`n		if sTool == nil then`n			print( "You're not carrying a ".._sTool.."." )`n			return`n		end`n	end`n`n	local room = getRoom( x,y,z )`n	if _sItem == "tree" or _sItem == "trees" or _sItem == "a tree" then`n		print( "The tree breaks into blocks of wood, which you pick up." )`n		inventory[ "some wood" ] = items[ "some wood" ]`n		return`n	elseif _sItem == "self" or _sItem == "myself" then`n		if term.isColour() then`n			term.setTextColour( colours.red )`n		end`n		print( "You have died." )`n		print( "Score: &e0" )`n		term.setTextColour( colours.white )`n		bRunning = false`n		return`n	end`n	`n	local sItem = findItem( room.items, _sItem )`n	if sItem then`n		local tItem = room.items[ sItem ]`n		if tItem.ore == true then`n			-- Breaking ore`n			if not sTool then`n				print( "You need a tool to break this ore." )`n				return`n			end`n			local tTool = inventory[ sTool ]`n			if tTool.tool then`n				if tTool.toolLevel < tItem.toolLevel then`n					print( sTool .." is not strong enough to break this ore." )`n				elseif tTool.toolType ~= tItem.toolType then`n					print( "You need a different kind of tool to break this ore." )`n				else`n					print( "The ore breaks, dropping "..sItem..", which you pick up." )`n					inventory[ sItem ] = items[ sItem ]`n					if tItem.infinite ~= true then`n						room.items[ sItem ] = nil`n					end`n				end`n			else`n				print( "You can't break "..sItem.." with "..sTool..".")`n			end`n			`n		elseif tItem.creature == true then`n			-- Fighting monsters (or pigs)`n			local toolLevel = 0`n			local tTool = nil`n			if sTool then`n				tTool = inventory[ sTool ]`n				if tTool.toolType == "sword" then`n					toolLevel = tTool.toolLevel`n				end`n			end`n						`n			local tChances = { 0.2, 0.4, 0.55, 0.8, 1 }`n			if math.random() <= tChances[ toolLevel + 1 ] then`n				room.items[ sItem ] = nil`n				print( "The "..tItem.aliases[1].." dies." )`n	`n				if tItem.drops then`n					for n, sDrop in pairs( tItem.drops ) do`n						if not room.items[sDrop] then`n							print( "The "..tItem.aliases[1].." dropped "..sDrop.."." )`n							room.items[sDrop] = items[sDrop]`n						end`n					end`n				end`n				`n				if tItem.monster then`n					room.nMonsters = room.nMonsters - 1`n				end`n			else`n				print( "The "..tItem.aliases[1].." is injured by your blow." )`n			end`n			`n			if tItem.hitDrops then`n				for n, sDrop in pairs( tItem.hitDrops ) do`n					if not room.items[sDrop] then`n						print( "The "..tItem.aliases[1].." dropped "..sDrop.."." )`n						room.items[sDrop] = items[sDrop]`n					end`n				end`n			end`n		`n		else`n			print( "You can't break "..sItem.."." )`n		end`n	else`n		print( "You don't see a ".._sItem.." here." )`n	end`nend`n`nfunction commands.craft( _sItem )`n	if _sItem == nil then`n		print( "Craft what?" )`n		return`n	end`n	`n	if _sItem == "computer" or _sItem == "a computer" then`n		print( "By creating a computer in a computer in a computer, you tear a hole in the spacetime continuum from which no mortal being can escape." )`n		if term.isColour() then`n			term.setTextColour( colours.red )`n		end`n		print( "You have died." )`n		print( "Score: &e0" )`n		term.setTextColour( colours.white )`n		bRunning = false`n		return`n	end`n	`n	local room = getRoom( x,y,z )`n	local sItem = findItem( items, _sItem )`n	local tRecipe = (sItem and tRecipes[ sItem ]) or nil`n	if tRecipe then`n		for n,sReq in ipairs( tRecipe ) do`n			if inventory[sReq] == nil then`n				print( "You don't have the items you need to craft "..sItem.."." )`n				return`n			end`n		end`n		`n		for n,sReq in ipairs( tRecipe ) do`n			inventory[sReq] = nil`n		end`n		inventory[ sItem ] = items[ sItem ]`n		if inventory["some torches"] and inventory["a torch"] then`n			inventory["a torch"] = nil`n		end`n		print( "Crafted." )`n	else`n		print( "You don't know how to make "..(sItem or _sItem).."." )`n	end	`nend`n`nfunction commands.build( _sThing, _sMaterial )`n	if _sThing == nil then`n		print( "Build what?" )`n		return`n	end`n		`n	local sMaterial = nil`n	if _sMaterial == nil then`n		for sItem, tItem in pairs( inventory ) do`n			if tItem.material then`n				sMaterial = sItem`n				break`n			end`n		end`n		if sMaterial == nil then`n			print( "You don't have any building materials." )`n			return`n		end`n	else`n		sMaterial = findItem( inventory, _sMaterial )`n		if not sMaterial then`n			print( "You don't have any ".._sMaterial )`n			return`n		end`n		`n		if inventory[sMaterial].material ~= true then`n			print( sMaterial.." is not a good building material." )`n			return`n		end`n	end`n	`n	local alias = nil`n	if string.sub(_sThing, 1, 1) == "a" then`n		alias = string.match( _sThing, "a ([%a ]+)" )`n	end`n	`n	local room = getRoom( x,y,z )`n	inventory[sMaterial] = nil`n	room.items[ _sThing ] = {`n		heavy = true,`n		aliases = { alias },`n		desc = "As you look at your creation (made from "..sMaterial.."), you feel a swelling sense of pride.",`n	}`n`n	print( "Your construction is complete." )`nend`n`nfunction commands.help()`n	local sText = `n		"Welcome to adventure, the greatest text adventure game on CraftOS. " ..`n		"To get around the world, type actions, and the adventure will " ..`n		"be read back to you. The actions availiable to you are go, look, inspect, inventory, " ..`n		"take, drop, place, punch, attack, mine, dig, craft, build, eat and exit."`n	print( sText )`nend`n`nfunction commands.eat( _sItem )`n	if _sItem == nil then`n		print( "Eat what?" )`n		return`n	end`n`n	local sItem = findItem( inventory, _sItem )`n	if not sItem then`n		print( "You don't have any ".._sItem.."." )`n		return`n	end`n	`n	local tItem = inventory[sItem]`n	if tItem.food then`n		print( "That was delicious!" )`n		inventory[sItem] = nil`n		`n		if bInjured then`n			print( "You are no longer injured." )`n			bInjured = false`n		end`n	else`n		print( "You can't eat "..sItem.."." )`n	end`nend`n`nfunction commands.exit()`n	bRunning = false`nend`n`nfunction commands.badinput()`n	local tResponses = {`n		"I don't understand.",`n		"I don't understand you.",`n		"You can't do that.",`n		"Nope.",`n		"Huh?",`n		"Say again?",`n		"That's crazy talk.",`n		"Speak clearly.",`n		"I'll think about it.",`n		"Let me get back to you on that one.",`n		"That doesn't make any sense.",`n		"What?",`n	}`n	print( tResponses[ math.random(1,#tResponses) ] )`nend`n`nfunction commands.noinput()`n	local tResponses = {`n		"Speak up.",`n		"Enunciate.",`n		"Project your voice.",`n		"Don't be shy.",`n		"Use your words.",`n	}`n	print( tResponses[ math.random(1,#tResponses) ] )`nend`n`nlocal function simulate()`n	local bNewMonstersThisRoom = false`n	`n	-- Spawn monsters in nearby rooms`n	for sx = -2,2 do`n		for sy = -1,1 do`n			for sz = -2,2 do`n				local h = y + sy`n				if h >= -3 and h <= 0 then`n					local room = getRoom( x + sx, h, z + sz )`n					`n					-- Spawn monsters`n					if room.nMonsters < 2 and`n					   ((h == 0 and not isSunny() and not room.items["a torch"]) or room.dark) and`n					   math.random(1,6) == 1 then`n					   `n						local sMonster = tMonsters[ math.random(1,#tMonsters) ]`n						if room.items[ sMonster ] == nil then`n					   		room.items[ sMonster ] = items[ sMonster ]`n					   		room.nMonsters = room.nMonsters + 1`n					   		`n					   		if sx == 0 and sy == 0 and sz == 0 and not room.dark then`n					   			print( "From the shadows, "..sMonster.." appears." )`n					   			bNewMonstersThisRoom = true`n					   		end`n						end	`n					end`n					`n					-- Burn monsters`n					if h == 0 and isSunny() then`n						for n,sMonster in ipairs( tMonsters ) do`n							if room.items[sMonster] and items[sMonster].nocturnal then`n								room.items[sMonster] = nil`n						   		if sx == 0 and sy == 0 and sz == 0 and not room.dark then`n						   			print( "With the sun high in the sky, the "..items[sMonster].aliases[1].." bursts into flame and dies." )`n						   		end`n						   		room.nMonsters = room.nMonsters - 1`n						   	end`n						end`n					end	`n				end`n			end`n		end`n	end`n`n	-- Make monsters attack`n	local room = getRoom( x, y, z )`n	if nTimeInRoom >= 2 and not bNewMonstersThisRoom then`n		for n,sMonster in ipairs( tMonsters ) do`n			if room.items[sMonster] then`n				if math.random(1,4) == 1 and`n				   not (y == 0 and isSunny() and (sMonster == "a spider")) then`n					if sMonster == "a creeper" then`n						if room.dark then`n							print( "A creeper explodes." )`n						else`n							print( "The creeper explodes." )`n						end`n						room.items[sMonster] = nil`n						room.nMonsters = room.nMonsters - 1`n					else`n						if room.dark then`n							print( "A "..items[sMonster].aliases[1].." attacks you." )`n						else`n							print( "The "..items[sMonster].aliases[1].." attacks you." )`n						end`n					end`n					`n					if bInjured then`n						if term.isColour() then`n							term.setTextColour( colours.red )`n						end`n						print( "You have died." )`n						print( "Score: &e0" )`n						term.setTextColour( colours.white )`n						bRunning = false`n						return`n					else`n						bInjured = true`n					end`n					`n					break`n				end`n			end`n		end`n	end`n	`n	-- Always print this`n	if bInjured then`n		if term.isColour() then`n			term.setTextColour( colours.red )`n		end`n		print( "You are injured." )`n		term.setTextColour( colours.white )`n	end`n	`n	-- Advance time`n	nTurn = nTurn + 1`n	nTimeInRoom = nTimeInRoom + 1`nend`n`ndoCommand( "look" )`nsimulate()`n`nlocal tCommandHistory = {}`nwhile bRunning do`n	if term.isColour() then`n		term.setTextColour( colours.yellow )`n	end`n    write( "? " )`n	term.setTextColour( colours.white )`n		`n    local sRawLine = read( nil, tCommandHistory )`n    table.insert( tCommandHistory, sRawLine )`n    `n    local sLine = nil`n	for match in string.gmatch(sRawLine, "%a+") do`n		if sLine then`n			sLine = sLine .. " " .. string.lower(match)`n		else`n			sLine = string.lower(match)`n		end`n	end`n	`n	doCommand( sLine or "" )`n    if bRunning then`n	    simulate()`n	end`nend`n`n/rom/programs/fun/dj/@/local tArgs = { ... }`n`nlocal function printUsage()`n	print( "Usages:")`n	print( "dj play" )`n	print( "dj play <drive>" )`n	print( "dj stop" )`nend`n`nif #tArgs > 2 then`n	printUsage()`n	return`nend`n`nlocal sCommand = tArgs[1]`nif sCommand == "stop" then`n	-- Stop audio`n	disk.stopAudio()`n`nelseif sCommand == "play" or sCommand == nil then`n	-- Play audio`n	local sName = tArgs[2]`n	if sName == nil then`n		-- No disc specified, pick one at random`n		local tNames = {}`n		for n,sName in ipairs( peripheral.getNames() ) do`n			if disk.isPresent( sName ) and disk.hasAudio( sName ) then`n				table.insert( tNames, sName )`n			end`n		end`n		if #tNames == 0 then`n			print( "No Music Discs in attached disk drives" )`n			return`n		end`n		sName = tNames[ math.random(1,#tNames) ]`n	end`n`n	-- Play the disc`n	if disk.isPresent( sName ) and disk.hasAudio( sName ) then`n		print( "Playing "..disk.getAudioTitle( sName ) )`n		disk.playAudio( sName )`n	else`n		print( "No Music Disc in disk drive: "..sName )`n		return`n	end`n	`nelse`n	printUsage()`n	`nend`n`n/rom/programs/fun/hello/@/if term.isColour() then`n	term.setTextColour( 2^math.random(0,15) )`nend`ntextutils.slowPrint( "Hello World!" )`nterm.setTextColour( colours.white )`n`n/rom/programs/fun/worm/@/`n-- Display the start screen`nlocal w,h = term.getSize()`n`nlocal titleColour, headingColour, textColour, wormColour, fruitColour`nif term.isColour() then`n    titleColour = colours.red`n	headingColour = colours.yellow`n	textColour = colours.white`n	wormColour = colours.green`n	fruitColour = colours.red`nelse`n    titleColour = colours.white`n	headingColour = colours.white`n	textColour = colours.white`n	wormColour = colours.white`n	fruitColour = colours.white`nend`n`nfunction printCentred( y, s )`n	local x = math.floor((w - string.len(s)) / 2)`n	term.setCursorPos(x,y)`n	--term.clearLine()`n	term.write( s )`nend`n`nlocal xVel,yVel = 1,0`nlocal xPos, yPos = math.floor(w/2), math.floor(h/2)`nlocal pxVel, pyVel = nil, nil`n`nlocal nLength = 1`nlocal nExtraLength = 6`nlocal bRunning = true`n`nlocal tailX,tailY = xPos,yPos`nlocal nScore = 0`nlocal nDifficulty = 2`nlocal nSpeed, nInterval`n`n-- Setup the screen`nlocal screen = {}`nfor x=1,w do`n	screen[x] = {}`n	for y=1,h do`n		screen[x][y] = {}`n	end`nend`nscreen[xPos][yPos] = { snake = true }`n`nlocal nFruit = 1`nlocal tFruits = {`n	"A", "B", "C", "D", "E", "F", "G", "H",`n	"I", "J", "K", "L", "M", "N", "O", "P",`n	"Q", "R", "S", "T", "U", "V", "W", "X",`n	"Y", "Z",`n	"a", "b", "c", "d", "e", "f", "g", "h",`n	"i", "j", "k", "l", "m", "n", "o", "p",`n	"q", "r", "s", "t", "u", "v", "w", "x",`n	"y", "z",`n	"1", "2", "3", "4", "5", "6", "7", "8", "9", "0",`n	"@", "$", "%", "#", "&", "!", "?", "+", "*", "~"`n}`n`nlocal function addFruit()`n	while true do`n		local x = math.random(1,w)`n		local y = math.random(2,h)`n		local fruit = screen[x][y]`n		if fruit.snake == nil and fruit.wall == nil and fruit.fruit == nil then`n			screen[x][y] = { fruit = true }`n			term.setCursorPos(x,y)`n			term.setBackgroundColour( fruitColour )`n			term.write(" ")`n			term.setBackgroundColour( colours.black )`n			break`n		end`n	end`n	`n	nFruit = nFruit + 1`n	if nFruit > #tFruits then`n		nFruit = 1`n	end`nend`n`nlocal function drawMenu()`n	term.setTextColour( headingColour )`n	term.setCursorPos(1,1)`n	term.write( "SCORE " )`n	`n	term.setTextColour( textColour )`n	term.setCursorPos(7,1)`n	term.write( tostring(nScore) )`n`n	term.setTextColour( headingColour )`n	term.setCursorPos(w-11,1)`n	term.write( "DIFFICULTY ")`n`n	term.setTextColour( textColour )`n	term.setCursorPos(w,1)`n	term.write( tostring(nDifficulty or "?") ) `n`n	term.setTextColour( colours.white )`nend`n`nlocal function update( )`n	local x,y = xPos,yPos`n	if pxVel and pyVel then`n		xVel, yVel = pxVel, pyVel`n		pxVel, pyVel = nil, nil`n	end`n`n	-- Remove the tail`n	if nExtraLength == 0 then`n		local tail = screen[tailX][tailY]`n		screen[tailX][tailY] = {}`n		term.setCursorPos(tailX,tailY)`n		term.write(" ")`n		tailX = tail.nextX`n		tailY = tail.nextY`n	else`n		nExtraLength = nExtraLength - 1`n	end`n	`n	-- Update the head`n	local head = screen[xPos][yPos]`n	local newXPos = xPos + xVel`n	local newYPos = yPos + yVel`n	if newXPos < 1 then`n		newXPos = w`n	elseif newXPos > w then`n		newXPos = 1`n	end`n	if newYPos < 2 then`n		newYPos = h`n	elseif newYPos > h then`n		newYPos = 2`n	end`n	`n	local newHead = screen[newXPos][newYPos]`n	term.setCursorPos(1,1);`n	print( newHead.snake )`n	if newHead.snake == true or newHead.wall == true then`n		bRunning = false`n		`n	else`n		if newHead.fruit == true then`n			nScore = nScore + 10`n			nExtraLength = nExtraLength + 1`n			addFruit()`n		end`n		xPos = newXPos`n		yPos = newYPos`n		head.nextX = newXPos`n		head.nextY = newYPos`n		screen[newXPos][newYPos] = { snake = true }`n		`n	end`n	`n	term.setCursorPos(xPos,yPos)`n	term.setBackgroundColour( wormColour )`n	term.write(" ")`n	term.setBackgroundColour( colours.black )`n`n	drawMenu()`nend`n`n-- Display the frontend`nterm.clear()`nlocal function drawFrontend()`n	--term.setTextColour( titleColour )`n    --printCentred( math.floor(h/2) - 4, " W O R M " )`n`n	term.setTextColour( headingColour )`n	printCentred( math.floor(h/2) - 3, "" )`n	printCentred( math.floor(h/2) - 2, " SELECT DIFFICULTY " )`n	printCentred( math.floor(h/2) - 1, "" )`n	`n	printCentred( math.floor(h/2) + 0, "            " )`n	printCentred( math.floor(h/2) + 1, "            " )`n	printCentred( math.floor(h/2) + 2, "            " )`n	printCentred( math.floor(h/2) - 1 + nDifficulty, " [        ] " )`n`n	term.setTextColour( textColour )`n	printCentred( math.floor(h/2) + 0, "EASY" )`n	printCentred( math.floor(h/2) + 1, "MEDIUM" )`n	printCentred( math.floor(h/2) + 2, "HARD" )`n	printCentred( math.floor(h/2) + 3, "" )`n`n	term.setTextColour( colours.white )`nend`n`ndrawMenu()`ndrawFrontend()`nwhile true do`n	local e,key = os.pullEvent( "key" )`n	if key == keys.up or key == keys.w then`n		-- Up`n		if nDifficulty > 1 then`n			nDifficulty = nDifficulty - 1`n			drawMenu()`n			drawFrontend()`n		end`n	elseif key == keys.down or key == keys.s then`n		-- Down`n		if nDifficulty < 3 then`n			nDifficulty = nDifficulty + 1`n			drawMenu()`n			drawFrontend()`n		end`n	elseif key == keys.enter then`n		-- Enter`n		break`n	end`nend`n`nlocal tSpeeds = { 5, 10, 25 }`nnSpeed = tSpeeds[nDifficulty]`nnInterval = 1 / nSpeed`n`n-- Grow the snake to its intended size`nterm.clear()`ndrawMenu()`nscreen[tailX][tailY].snake = true`nwhile nExtraLength > 0 do`n	update()`nend`naddFruit()`naddFruit()`n`n-- Play the game`nlocal timer = os.startTimer(0)`nwhile bRunning do`n	local event, p1, p2 = os.pullEvent()`n	if event == "timer" and p1 == timer then`n		timer = os.startTimer(nInterval)`n		update( false )`n	`n	elseif event == "key" then`n		local key = p1`n		if key == keys.up or key == keys.w then`n			-- Up`n			if yVel == 0 then`n				pxVel,pyVel = 0,-1`n			end`n		elseif key == keys.down or key == keys.s then`n			-- Down`n			if yVel == 0 then`n				pxVel,pyVel = 0,1`n			end`n		elseif key == keys.left or key == keys.a then`n			-- Left`n			if xVel == 0 then`n				pxVel,pyVel = -1,0`n			end`n		`n		elseif key == keys.right or key == keys.d then`n			-- Right`n			if xVel == 0 then`n				pxVel,pyVel = 1,0`n			end`n		`n		end	`n	end`nend`n`n-- Display the gameover screen`nterm.setTextColour( headingColour )`nprintCentred( math.floor(h/2) - 2, "                   " )`nprintCentred( math.floor(h/2) - 1, " G A M E   O V E R " )`n`nterm.setTextColour( textColour )`nprintCentred( math.floor(h/2) + 0, "                 " )`nprintCentred( math.floor(h/2) + 1, " FINAL SCORE "..nScore.." " )`nprintCentred( math.floor(h/2) + 2, "                 " )`nterm.setTextColour( colours.white )`n`nlocal timer = os.startTimer(2.5)`nrepeat`n	local e,p = os.pullEvent()`n	if e == "timer" and p == timer then`n		term.setTextColour( textColour )`n		printCentred( math.floor(h/2) + 2, " PRESS ANY KEY " )`n		printCentred( math.floor(h/2) + 3, "               " )`n		term.setTextColour( colours.white )`n	end`nuntil e == "char"`n`nterm.clear()`nterm.setCursorPos(1,1)`n`n		`n`n/rom/programs/fun/advanced/paint/@/-- Paint created by nitrogenfingers (edited by dan200)`n-- http://www.youtube.com/user/NitrogenFingers`n`n------------`n-- Fields --`n------------`n`n-- The width and height of the terminal`nlocal w,h = term.getSize()`n`n-- The selected colours on the left and right mouse button, and the colour of the canvas`nlocal leftColour, rightColour = colours.white, nil`nlocal canvasColour = colours.black`n`n-- The values stored in the canvas`nlocal canvas = {}`n`n-- The menu options`nlocal mChoices = { "Save","Exit" }`n`n-- The message displayed in the footer bar`nlocal fMessage = "Press Ctrl to access menu"`n`n-------------------------`n-- Initialisation --`n-------------------------`n`n-- Determine if we can even run this`nif not term.isColour() then`n	print("Requires an Advanced Computer")`n	return`nend`n`n-- Determines if the file exists, and can be edited on this computer`nlocal tArgs = {...}`nif #tArgs == 0 then`n	print("Usage: paint <path>")`n	return`nend`nlocal sPath = shell.resolve(tArgs[1])`nlocal bReadOnly = fs.isReadOnly(sPath)`nif fs.exists(sPath) and fs.isDir(sPath) then`n	print("Cannot edit a directory.")`n	return`nend`n`n---------------`n-- Functions --`n---------------`n`nlocal function getCanvasPixel( x, y )`n    if canvas[y] then`n        return canvas[y][x]`n    end`n    return nil`nend`n`n--[[`n	Converts a colour value to a text character`n	params: colour = the number to convert to a hex value`n	returns: a string representing the chosen colour`n]]`nlocal function getCharOf( colour )`n	-- Incorrect values always convert to nil`n	if type(colour) == "number" then`n		local value = math.floor( math.log(colour) / math.log(2) ) + 1`n		if value >= 1 and value <= 16 then`n			return string.sub( "0123456789abcdef", value, value )`n		end`n	end`n	return " "`nend	`n`n--[[`n	Converts a text character to colour value`n	params: char = the char (from string.byte) to convert to number`n	returns: the colour number of the hex value`n]]`nlocal tColourLookup = {}`nfor n=1,16 do`n	tColourLookup[ string.byte( "0123456789abcdef",n,n ) ] = 2^(n-1)`nend`nlocal function getColourOf( char )`n	-- Values not in the hex table are transparent (canvas coloured)`n	return tColourLookup[char]`nend`n`n--[[ `n	Loads the file into the canvas`n	params: path = the path of the file to open`n	returns: nil`n]]`nlocal function load(path)`n	-- Load the file`n	if fs.exists(path) then`n		local file = fs.open(sPath, "r")`n		local sLine = file.readLine()`n		while sLine do`n			local line = {}`n			for x=1,w-2 do`n				line[x] = getColourOf( string.byte(sLine,x,x) )`n			end`n			table.insert( canvas, line )`n			sLine = file.readLine()`n		end`n		file.close()`n	end`nend`n`n--[[  `n	Saves the current canvas to file  `n	params: path = the path of the file to save`n	returns: true if save was successful, false otherwise`n]]`nlocal function save(path)`n    -- Open file`n	local sDir = string.sub(sPath, 1, #sPath - #fs.getName(sPath))`n	if not fs.exists(sDir) then`n		fs.makeDir(sDir)`n	end`n`n	local file = fs.open( path, "w" )`n	if not file then`n	    return false`n	end`n`n    -- Encode (and trim)`n	local tLines = {}`n	local nLastLine = 0`n	for y=1,h-1 do`n	    local sLine = ""`n	    local nLastChar = 0`n		for x=1,w-2 do`n		    local c = getCharOf( getCanvasPixel( x, y ) )`n		    sLine = sLine .. c`n		    if c ~= " " then`n		        nLastChar = x`n		    end`n		end`n		sLine = string.sub( sLine, 1, nLastChar )`n		tLines[y] = sLine`n		if string.len( sLine ) > 0 then`n		    nLastLine = y`n		end`n	end`n`n    -- Save out`n	for n=1,nLastLine do`n   	    file.writeLine( tLines[ n ] )`n	end`n	file.close()`n	return true`nend`n`n--[[  `n	Draws colour picker sidebar, the pallette and the footer`n	returns: nil`n]]`nlocal function drawInterface()`n	-- Footer`n	term.setCursorPos(1, h)`n	term.setBackgroundColour(colours.black)`n	term.setTextColour(colours.yellow)`n	term.clearLine()`n	term.write(fMessage)`n	`n	-- Colour Picker`n	for i=1,16 do`n		term.setCursorPos(w-1, i)`n		term.setBackgroundColour( 2^(i-1) )`n		term.write("  ")`n	end`n`n	term.setCursorPos(w-1, 17)`n	term.setBackgroundColour( canvasColour )`n	term.setTextColour( colours.grey )`n	term.write("XX")`n			`n	-- Left and Right Selected Colours`n	for i=18,18 do`n		term.setCursorPos(w-1, i)`n		if leftColour ~= nil then`n			term.setBackgroundColour( leftColour )`n			term.write(" ")`n		else`n			term.setBackgroundColour( canvasColour )`n			term.setTextColour( colours.grey )`n			term.write("X")`n		end`n		if rightColour ~= nil then`n			term.setBackgroundColour( rightColour )`n			term.write(" ")`n		else`n			term.setBackgroundColour( canvasColour )`n			term.setTextColour( colours.grey )`n			term.write("X")`n		end`n	end`n`n	-- Padding`n	term.setBackgroundColour( canvasColour )`n	for i=20,h-1 do`n		term.setCursorPos(w-1, i)`n		term.write("  ")`n	end`nend`n`n--[[  `n	Converts a single pixel of a single line of the canvas and draws it`n	returns: nil`n]]`nlocal function drawCanvasPixel( x, y )`n	local pixel = getCanvasPixel( x, y )`n	if pixel then`n		term.setBackgroundColour( pixel or canvasColour )`n		term.setCursorPos(x, y)`n		term.write(" ")`n	else`n		term.setBackgroundColour( canvasColour )`n		term.setTextColour( colours.grey )`n		term.setCursorPos(x, y)`n        term.write("-")`n	end`nend`n`n--[[  `n	Converts each colour in a single line of the canvas and draws it`n	returns: nil`n]]`nlocal function drawCanvasLine( y )`n	for x = 1, w-2 do`n		drawCanvasPixel( x, y )`n	end`nend`n`n--[[  `n	Converts each colour in the canvas and draws it`n	returns: nil`n]]`nlocal function drawCanvas()`n	for y = 1, h-1 do`n		drawCanvasLine( y )`n	end`nend`n`n--[[`n	Draws menu options and handles input from within the menu.`n	returns: true if the program is to be exited; false otherwise`n]]`nlocal function accessMenu()`n	-- Selected menu option`n	local selection = 1`n	`n	term.setBackgroundColour(colours.black)`n	while true do`n		-- Draw the menu`n		term.setCursorPos(1,h)`n		term.clearLine()`n		term.setTextColour(colours.white)`n		for k,v in pairs(mChoices) do`n			if selection==k then `n				term.setTextColour(colours.yellow)`n				local ox,_ = term.getCursorPos()`n				term.write("["..string.rep(" ",#v).."]")`n				term.setCursorPos(ox+1,h)`n				term.setTextColour(colours.white)`n				term.write(v)`n				term.setCursorPos(term.getCursorPos()+1,h)`n			else`n				term.write(" "..v.." ")`n			end`n		end`n		`n		-- Handle input in the menu`n		local id,key = os.pullEvent("key")`n		if id == "key" then`n			-- S and E are shortcuts`n			if key == keys.s then`n				selection = 1`n				key = keys.enter`n			elseif key == keys.e then`n				selection = 2`n				key = keys.enter`n			end`n		`n			if key == keys.right then`n				-- Move right`n				selection = selection + 1`n				if selection > #mChoices then`n					selection = 1`n				end`n				`n			elseif key == keys.left and selection > 1 then`n				-- Move left`n				selection = selection - 1`n				if selection < 1 then`n					selection = #mChoices`n				end`n				`n			elseif key == keys.enter then`n				-- Select an option`n				if mChoices[selection]=="Save" then `n					if bReadOnly then `n						fMessage = "Access Denied"`n						return false`n					end`n					local success = save(sPath)`n					if success then`n						fMessage = "Saved to "..sPath`n					else`n						fMessage = "Error saving to "..sPath`n					end`n					return false`n				elseif mChoices[selection]=="Exit" then `n					return true`n				end`n			elseif key == keys.leftCtrl or keys == keys.rightCtrl then`n				-- Cancel the menu`n				return false `n			end`n		end`n	end`nend`n`n--[[  `n	Runs the main thread of execution. Draws the canvas and interface, and handles`n	mouse and key events.`n	returns: nil`n]]`nlocal function handleEvents()`n	local programActive = true`n	while programActive do`n		local id,p1,p2,p3 = os.pullEvent()`n		if id=="mouse_click" or id=="mouse_drag" then`n			if p2 >= w-1 and p3 >= 1 and p3 <= 17 then`n				if id ~= "mouse_drag" then`n					-- Selecting an items in the colour picker`n					if p3 <= 16 then`n						if p1==1 then`n							leftColour = 2^(p3-1)`n						else`n							rightColour = 2^(p3-1)`n						end`n					else`n						if p1==1 then`n							leftColour = nil`n						else`n							rightColour = nil`n						end`n					end`n					--drawCanvas()`n					drawInterface()`n				end`n			elseif p2 < w-1 and p3 <= h-1 then`n				-- Clicking on the canvas`n				local paintColour = nil`n				if p1==1 then`n					paintColour = leftColour`n				elseif p1==2 then`n					paintColour = rightColour`n				end`n				if not canvas[p3] then`n                    canvas[p3] = {}`n    			end`n                canvas[p3][p2] = paintColour`n`n				drawCanvasPixel( p2, p3 )`n			end`n		elseif id=="key" then`n			if p1==keys.leftCtrl or p1==keys.rightCtrl then`n				programActive = not accessMenu()`n				drawInterface()`n			end`n		elseif id=="term_resize" then`n		    w,h = term.getSize()`n            drawCanvas()`n            drawInterface()`n        end`n	end`nend`n`n-- Init`nload(sPath)`ndrawCanvas()`ndrawInterface()`n`n-- Main loop`nhandleEvents()`n`n-- Shutdown`nterm.setBackgroundColour(colours.black)`nterm.setTextColour(colours.white)`nterm.clear()`nterm.setCursorPos(1,1)`n`n/rom/programs/fun/advanced/redirection/@/--CCRedirection by : RamiLego4Game and Dan200--`n--Based on Redirection by Dan200: http://www.redirectiongame.com--`n--Clearing Screen--`n`n--Vars--`nlocal TermW,TermH = term.getSize()`n`nlocal sLevelTitle`nlocal tScreen`nlocal oScreen`nlocal SizeW,SizeH`nlocal aExits`nlocal fExit`nlocal nSpeed`nlocal Speed`nlocal fSpeed`nlocal fSpeedS`nlocal bPaused`nlocal Tick`nlocal Blocks`nlocal XOrgin,YOrgin`n`nlocal function reset()`n    sLevelTitle = ""`n    tScreen = {}`n    oScreen = {}`n    SizeW,SizeH = TermW,TermH`n    aExits = 0`n    fExit = "nop"`n    nSpeed = 0.6`n    Speed = nSpeed`n    fSpeed = 0.2`n    fSpeedS = false`n    bPaused = false`n    Tick = os.startTimer(Speed)`n    Blocks = 0`n    XOrgin,YOrgin = 1,1`n`n    term.setBackgroundColor(colors.black)`n    term.setTextColor(colors.white)`n    term.clear()`nend`n`nlocal InterFace = {}`nInterFace.cExit = colors.red`nInterFace.cSpeedD = colors.white`nInterFace.cSpeedA = colors.red`nInterFace.cTitle = colors.red`n`nlocal cG = colors.lightGray`nlocal cW = colors.gray`nlocal cS = colors.black`nlocal cR1 = colors.blue`nlocal cR2 = colors.red`nlocal cR3 = colors.green`nlocal cR4 = colors.yellow`n`nlocal tArgs = { ... }`n`n--Functions--`nlocal function printCentred( yc, stg )`n	local xc = math.floor((TermW - string.len(stg)) / 2) + 1`n	term.setCursorPos(xc,yc)`n	term.write( stg )`nend`n`nlocal function centerOrgin()`n	XOrgin = math.floor((TermW/2)-(SizeW/2))`n	YOrgin = math.floor((TermH/2)-(SizeH/2))`nend`n`nlocal function reMap()`n	tScreen = nil`n	tScreen = {}`n	for x=1,SizeW do`n		tScreen[x] = {}`n		for y=1,SizeH do`n			tScreen[x][y] = { space = true, wall = false, ground = false, robot = "zz", start = "zz", exit = "zz" }`n		end`n	end`nend`n`nlocal function tablecopy(t)`n  local t2 = {}`n  for k,v in pairs(t) do`n    t2[k] = v`n  end`n  return t2`nend`n`nlocal function buMap()`n	oScreen = nil`n	oScreen = {}`n	for x=1,SizeW do`n		oScreen[x] = {}`n		for y=1,SizeH do`n			oScreen[x][y] = tablecopy(tScreen[x][y])`n		end`n	end`nend`n`nlocal function addRobot(x,y,side,color)`n	local obj = tScreen[x][y]`n	local data = side..color`n	if obj.wall == nil and obj.robot == nil then`n		tScreen[x][y].robot = data`n	else`n		obj.wall = nil`n		obj.robot = "zz"`n		tScreen[x][y].robot = data`n	end`nend`n`nlocal function addStart(x,y,side,color)`n	local obj = tScreen[x][y]`n	local data = side..color`n	if obj.wall == nil and obj.space == nil then`n		tScreen[x][y].start = data`n	else`n		obj.wall = nil`n		obj.space = nil`n		tScreen[x][y].start = data`n	end`n	aExits = aExits+1`nend`n`nlocal function addGround(x,y)`n	local obj = tScreen[x][y]`n	if obj.space == nil and obj.exit == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then`n		tScreen[x][y].ground = true`n	else`n		obj.space = nil`n		obj.exit = "zz"`n		obj.wall = nil`n		obj.robot = "zz"`n		obj.start = "zz"`n		tScreen[x][y].ground = true`n	end`nend`n`nlocal function addExit(x,y,cl)`n	local obj = tScreen[x][y]`n	if obj.space == nil and obj.ground == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then`n		tScreen[x][y].exit = cl`n	else`n		obj.space = nil`n		obj.ground = nil`n		obj.wall = nil`n		obj.robot = "zz"`n		obj.start = "zz"`n		tScreen[x][y].exit = cl`n	end`nend`n`nlocal function addWall(x,y)`n	local obj = tScreen[x][y]`n	if obj == nil then`n		return error("Here X"..x.." Y"..y)`n	end`n	if obj.space == nil and obj.exit == nil and obj.ground == nil and obj.robot == nil and obj.start == nil then`n		tScreen[x][y].wall = true`n	else`n		obj.space = nil`n		obj.exit = nil`n		obj.ground = nil`n		obj.robot = nil`n		obj.start = nil`n		tScreen[x][y].wall = true`n	end`nend`n`nlocal function loadLevel(nNum)`n    sLevelTitle = "Level "..nNum`n	if nNum == nil then return error("nNum == nil") end`n	local sDir = fs.getDir( shell.getRunningProgram() )`n	local sLevelD = sDir .. "/levels/" .. tostring(nNum)`n	if not ( fs.exists(sLevelD) or fs.isDir(sLevelD) ) then return error("Level Not Exists : "..sLevelD) end`n	fLevel = fs.open(sLevelD,"r")`n	local Line = 0`n	local wl = true`n	Blocks = tonumber(string.sub(fLevel.readLine(),1,1))`n	local xSize = string.len(fLevel.readLine())+2`n	local Lines = 3`n	while wl do`n		local wLine = fLevel.readLine()`n		if wLine == nil then`n			fLevel.close()`n			wl = false`n		else`n    	    xSize = math.max(string.len(wLine)+2,xSize)`n			Lines = Lines + 1`n		end`n	end`n	SizeW,SizeH = xSize,Lines`n	reMap()`n	fLevel = fs.open(sLevelD,"r")`n	fLevel.readLine()`n	for Line=2,Lines-1 do`n		sLine = fLevel.readLine()`n		local chars = string.len(sLine)`n		for char = 1, chars do`n			local el = string.sub(sLine,char,char)`n			if el == "8" then`n				addGround(char+1,Line)`n			elseif el == "0" then`n				addStart(char+1,Line,"a","a")`n			elseif el == "1" then`n				addStart(char+1,Line,"b","a")`n			elseif el == "2" then`n				addStart(char+1,Line,"c","a")`n			elseif el == "3" then`n				addStart(char+1,Line,"d","a")`n			elseif el == "4" then`n				addStart(char+1,Line,"a","b")`n			elseif el == "5" then`n				addStart(char+1,Line,"b","b")`n			elseif el == "6" then`n				addStart(char+1,Line,"c","b")`n			elseif el == "9" then`n				addStart(char+1,Line,"d","b")`n			elseif el == "b" then`n				addExit(char+1,Line,"a")`n			elseif el == "e" then`n				addExit(char+1,Line,"b")`n			elseif el == "7" then`n				addWall(char+1,Line)`n			end`n		end`n	end`n	fLevel.close()`nend`n`nlocal function drawStars()`n	--CCR Background By : RamiLego--`n	local cStar,cStarG,crStar,crStarB = colors.lightGray,colors.gray,".","*"`n	local DStar,BStar,nStar,gStar = 14,10,16,3`n	local TermW,TermH = term.getSize()`n`n    term.clear()`n    term.setCursorPos(1,1)`n	for x=1,TermW do`n		for y=1,TermH do`n			local StarT = math.random(1,30)`n			if StarT == DStar then`n				term.setCursorPos(x,y)`n				term.setTextColor(cStar)`n				write(crStar)`n			elseif StarT == BStar then`n				term.setCursorPos(x,y)`n				term.setTextColor(cStar)`n				write(crStarB)`n			elseif StarT == nStar then`n				term.setCursorPos(x,y)`n				term.setTextColor(cStarG)`n				write(crStar)`n			elseif StarT == gStar then`n				term.setCursorPos(x,y)`n				term.setTextColor(cStarG)`n				write(crStarB)`n			end`n		end`n	end`nend`n`nlocal function drawMap()`n	for x=1,SizeW do`n		for y=1,SizeH do`n		  `n			local obj = tScreen[x][y]`n			if obj.ground == true then`n				paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cG)`n			end`n			if obj.wall == true then`n				paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cW)`n			end`n		 `n		 local ex = tostring(tScreen[x][y].exit)`n			if not(ex == "zz" or ex == "nil") then`n				if ex == "a" then`n					ex = cR1`n				elseif ex == "b" then`n					ex = cR2`n				elseif ex == "c" then`n					ex = cR3`n				elseif ex == "d" then`n					ex = cR4`n				else`n					return error("Exit Color Out")`n				end`n				term.setBackgroundColor(cG)`n				term.setTextColor(ex)`n				term.setCursorPos(XOrgin+x,YOrgin+y+1)`n				print("X")`n			end`n		 `n		 local st = tostring(tScreen[x][y].start)`n			if not(st == "zz" or st == "nil") then`n				local Cr = string.sub(st,2,2)`n				if Cr == "a" then`n					Cr = cR1`n				elseif Cr == "b" then`n					Cr = cR2`n				elseif Cr == "c" then`n					Cr = cR3`n				elseif Cr == "d" then`n					Cr = cR4`n				else`n					return error("Start Color Out")`n				end`n			`n				term.setTextColor(Cr)`n			term.setBackgroundColor(cG)`n				term.setCursorPos(XOrgin+x,YOrgin+y+1)`n			`n				sSide = string.sub(st,1,1)`n				if sSide == "a" then`n					print("^")`n				elseif sSide == "b" then`n					print(">")`n				elseif sSide == "c" then`n					print("v")`n				elseif sSide == "d" then`n					print("<")`n				else`n					print("@")`n				end`n			end`n			`n			if obj.space == true then`n				paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cS)`n			end`n			`n			local rb = tostring(tScreen[x][y].robot)`n			if not(rb == "zz" or rb == "nil") then`n				local Cr = string.sub(rb,2,2)`n				if Cr == "a" then`n					Cr = cR1`n				elseif Cr == "b" then`n					Cr = cR2`n				elseif Cr == "c" then`n					Cr = cR3`n				elseif Cr == "d" then`n					Cr = cR4`n				else`n					Cr = colors.white`n				end`n				term.setBackgroundColor(Cr)`n				term.setTextColor(colors.white)`n				term.setCursorPos(XOrgin+x,YOrgin+y+1)`n				sSide = string.sub(rb,1,1)`n				if sSide == "a" then`n					print("^")`n				elseif sSide == "b" then`n					print(">")`n				elseif sSide == "c" then`n					print("v")`n				elseif sSide == "d" then`n					print("<")`n				else`n					print("@")`n				end`n			end`n		end`n	end`nend`n`nlocal function isBrick(x,y)`n	local brb = tostring(tScreen[x][y].robot)`n	local bobj = oScreen[x][y]`n	if (brb == "zz" or brb == "nil") and not bobj.wall == true then`n		return false`n	else`n		return true`n	end`nend`n`nlocal function gRender(sContext)`n	if sContext == "start" then`n		for x=1,SizeW do`n			for y=1,SizeH do`n				local st = tostring(tScreen[x][y].start)`n				if not(st == "zz" or st == "nil") then`n					local Cr = string.sub(st,2,2)`n					local sSide = string.sub(st,1,1)`n					addRobot(x,y,sSide,Cr)`n				end`n			end`n		end`n	elseif sContext == "tick" then`n		buMap()`n        for x=1,SizeW do`n            for y=1,SizeH do`n                local rb = tostring(oScreen[x][y].robot)`n                if not(rb == "zz" or rb == "nil") then`n                    local Cr = string.sub(rb,2,2)`n                    local sSide = string.sub(rb,1,1)`n                    local sobj = oScreen[x][y]`n                    if sobj.space == true then`n                        tScreen[x][y].robot = "zz"`n                        if not sSide == "g" then`n                            addRobot(x,y,"g",Cr)`n                        end`n                    elseif sobj.exit == Cr then`n                        if sSide == "a" or sSide == "b" or sSide == "c" or sSide == "d" then`n                        tScreen[x][y].robot = "zz"`n                        addRobot(x,y,"g",Cr)`n                        aExits = aExits-1`n                        end`n                    elseif sSide == "a" then`n                        local obj = isBrick(x,y-1)`n                        tScreen[x][y].robot = "zz"`n                        if not obj == true then`n                            addRobot(x,y-1,sSide,Cr)`n                        else`n                            local obj2 = isBrick(x-1,y)`n                            local obj3 = isBrick(x+1,y)`n                            if not obj2 == true and not obj3 == true then`n                                if Cr == "a" then`n                                    addRobot(x,y,"d",Cr)`n                                elseif Cr == "b" then`n                                    addRobot(x,y,"b",Cr)`n                                end`n                            elseif obj == true and obj2 == true and obj3 == true then`n                                addRobot(x,y,"c",Cr)`n                            else`n                                if obj3 == true then`n                                    addRobot(x,y,"d",Cr)`n                                elseif obj2 == true then`n                                    addRobot(x,y,"b",Cr)`n                                end`n                            end`n                        end`n                    elseif sSide == "b" then`n                        local obj = isBrick(x+1,y)`n                        tScreen[x][y].robot = "zz"`n                        if not obj == true then`n                            addRobot(x+1,y,sSide,Cr)`n                        else`n                            local obj2 = isBrick(x,y-1)`n                            local obj3 = isBrick(x,y+1)`n                            if not obj2 == true and not obj3 == true then`n                                if Cr == "a" then`n                                    addRobot(x,y,"a",Cr)`n                                elseif Cr == "b" then`n                                    addRobot(x,y,"c",Cr)`n                                end`n                            elseif obj == true and obj2 == true and obj3 == true then`n                                addRobot(x,y,"d",Cr)`n                            else`n                                if obj3 == true then`n                                    addRobot(x,y,"a",Cr)`n                                elseif obj2 == true then`n                                    addRobot(x,y,"c",Cr)`n                                end`n                            end`n                        end`n                    elseif sSide == "c" then`n                        local obj = isBrick(x,y+1)`n                        tScreen[x][y].robot = "zz"`n                        if not obj == true then`n                            addRobot(x,y+1,sSide,Cr)`n                        else`n                            local obj2 = isBrick(x-1,y)`n                            local obj3 = isBrick(x+1,y)`n                            if not obj2 == true and not obj3 == true then`n                                if Cr == "a" then`n                                    addRobot(x,y,"b",Cr)`n                                elseif Cr == "b" then`n                                    addRobot(x,y,"d",Cr)`n                                end`n                            elseif obj == true and obj2 == true and obj3 == true then`n                                addRobot(x,y,"a",Cr)`n                            else`n                                if obj3 == true then`n                                    addRobot(x,y,"d",Cr)`n                                elseif obj2 == true then`n                                    addRobot(x,y,"b",Cr)`n                                end`n                            end`n                        end`n                    elseif sSide == "d" then`n                        local obj = isBrick(x-1,y)`n                        tScreen[x][y].robot = "zz"`n                        if not obj == true then`n                            addRobot(x-1,y,sSide,Cr)`n                        else`n                            local obj2 = isBrick(x,y-1)`n                            local obj3 = isBrick(x,y+1)`n                            if not obj2 == true and not obj3 == true then`n                                if Cr == "a" then`n                                    addRobot(x,y,"c",Cr)`n                                elseif Cr == "b" then`n                                    addRobot(x,y,"a",Cr)`n                                end`n                            elseif obj == true and obj2 == true and obj3 == true then`n                                addRobot(x,y,"b",Cr)`n                            else`n                                if obj3 == true then`n                                    addRobot(x,y,"a",Cr)`n                                elseif obj2 == true then`n                                    addRobot(x,y,"c",Cr)`n                                end`n                            end`n                        end`n                    else`n                        addRobot(x,y,sSide,"g")`n                    end`n                end`n            end`n        end`n    end`nend`n`nfunction InterFace.drawBar()`n	term.setBackgroundColor( colors.black )`n	term.setTextColor( InterFace.cTitle )`n	printCentred( 1, "  "..sLevelTitle.."  " )`n	`n	term.setCursorPos(1,1)`n	term.setBackgroundColor( cW )`n	write( " " )`n	term.setBackgroundColor( colors.black )`n	write( " x "..tostring(Blocks).." " )`n	`n	term.setCursorPos( TermW-8,TermH )`n	term.setBackgroundColor( colors.black )`n    term.setTextColour(InterFace.cSpeedD)`n	write(" <<" )`n	if bPaused then`n		term.setTextColour(InterFace.cSpeedA)`n	else`n		term.setTextColour(InterFace.cSpeedD)`n	end`n	write(" ||")`n	if fSpeedS then`n		term.setTextColour(InterFace.cSpeedA)`n	else`n		term.setTextColour(InterFace.cSpeedD)`n	end`n	write(" >>")`n`n	term.setCursorPos( TermW-1, 1 )`n	term.setBackgroundColor( colors.black )`n	term.setTextColour( InterFace.cExit )`n	write(" X")`n	term.setBackgroundColor(colors.black)`nend`n`nfunction InterFace.render()`n	local id,p1,p2,p3 = os.pullEvent()`n	if id == "mouse_click" then`n		if p3 == 1 and p2 == TermW then`n            return "end"`n        elseif p3 == TermH and p2 >= TermW-7 and p2 <= TermW-6 then`n            return "retry"`n        elseif p3 == TermH and p2 >= TermW-4 and p2 <= TermW-3 then`n            bPaused = not bPaused`n            fSpeedS = false`n            Speed = (bPaused and 0) or nSpeed`n            if Speed > 0 then`n                Tick = os.startTimer(Speed)`n            else`n                Tick = nil`n            end`n            InterFace.drawBar()`n        elseif p3 == TermH and p2 >= TermW-1 then`n            bPaused = false`n            fSpeedS = not fSpeedS`n            Speed = (fSpeedS and fSpeed) or nSpeed`n            Tick = os.startTimer(Speed)`n            InterFace.drawBar()`n		elseif p3-1 < YOrgin+SizeH+1 and p3-1 > YOrgin and`n               p2 < XOrgin+SizeW+1 and p2 > XOrgin then`n            local eobj = tScreen[p2-XOrgin][p3-YOrgin-1]`n            local erobj = tostring(tScreen[p2-XOrgin][p3-YOrgin-1].robot)`n            if (erobj == "zz" or erobj == "nil") and not eobj.wall == true and not eobj.space == true and Blocks > 0 then`n                addWall(p2-XOrgin,p3-YOrgin-1)`n                Blocks = Blocks-1`n                InterFace.drawBar()`n                drawMap()`n            end`n		end`n	elseif id == "timer" and p1 == Tick then`n		gRender("tick")`n        drawMap()`n        if Speed > 0 then`n            Tick = os.startTimer(Speed)`n        else`n            Tick = nil`n        end`n	end`nend`n`nlocal function startG(LevelN)`n	drawStars()`n	loadLevel(LevelN)`n	centerOrgin()`n	local create = true`n	drawMap()`n	InterFace.drawBar()`n	gRender("start")`n	drawMap()`n	`n	local NExit = true`n	if aExits == 0 then`n		NExit = false`n	end`n	`n	while true do`n		local isExit = InterFace.render()`n		if isExit == "end" then`n		    return nil`n		elseif isExit == "retry" then`n		    return LevelN`n		elseif fExit == "yes" then`n			if fs.exists( fs.getDir( shell.getRunningProgram() ) .. "/levels/" .. tostring(LevelN + 1) ) then`n			    return LevelN + 1`n			else`n			    return nil`n			end`n		end`n		if aExits == 0 and NExit == true then`n			fExit = "yes"`n		end`n	end`nend`n`nlocal ok, err = true, nil`n`n--Menu--`nlocal sStartLevel = tArgs[1]`nif ok and not sStartLevel then`n    ok, err = pcall( function()`n        term.setTextColor(colors.white)`n        term.setBackgroundColor( colors.black )`n        term.clear()`n        drawStars()`n        term.setTextColor( colors.red )`n        printCentred( TermH/2 - 1, "  REDIRECTION  " )`n        printCentred( TermH/2 - 0, "  ComputerCraft Edition  " )`n        term.setTextColor( colors.yellow )`n        printCentred( TermH/2 + 2, "  Click to Begin  " )`n        os.pullEvent( "mouse_click" )`n    end )`nend`n`n--Game--`nif ok then`n    ok,err = pcall( function()`n        local nLevel`n        if sStartLevel then`n            nLevel = tonumber( sStartLevel )`n        else`n            nLevel = 1`n        end`n        while nLevel do`n            reset()`n            nLevel = startG(nLevel)`n        end`n    end )`nend`n`n--Upsell screen--`nif ok then`n    ok, err = pcall( function()`n        term.setTextColor(colors.white)`n        term.setBackgroundColor( colors.black )`n        term.clear()`n        drawStars()`n        term.setTextColor( colors.red )`n        if TermW >= 40 then`n            printCentred( TermH/2 - 1, "  Thank you for playing Redirection  " )`n            printCentred( TermH/2 - 0, "  ComputerCraft Edition  " )`n            printCentred( TermH/2 + 2, "  Check out the full game:  " )`n            term.setTextColor( colors.yellow )`n            printCentred( TermH/2 + 3, "  http://www.redirectiongame.com  " )`n        else`n            printCentred( TermH/2 - 2, "  Thank you for  " )`n            printCentred( TermH/2 - 1, "  playing Redirection  " )`n            printCentred( TermH/2 - 0, "  ComputerCraft Edition  " )`n            printCentred( TermH/2 + 2, "  Check out the full game:  " )`n            term.setTextColor( colors.yellow )`n            printCentred( TermH/2 + 3, "  www.redirectiongame.com  " )`n        end`n        parallel.waitForAll(`n            function() sleep(2) end,`n            function() os.pullEvent( "mouse_click" ) end`n        )`n    end )`nend`n`n--Clear and exit--`nterm.setCursorPos(1,1)`nterm.setTextColor(colors.white)`nterm.setBackgroundColor(colors.black)`nterm.clear()`nif not ok then`n    if err == "Terminated" then`n        print( "Check out the full version of Redirection:" )`n        print( "http://www.redirectiongame.com" )`n    else`n        printError( err )`n    end`nend`n`n/rom/programs/fun/advanced/levels/0/@/0`n77     77`n718888887`n 8     8`n 8     8`n 8     8`n788888897`n77     77`n`n/rom/programs/fun/advanced/levels/1/@/1`n     777`n     7b7`n     787`n7777778777`n7188888887`n7777777777`n`n/rom/programs/fun/advanced/levels/10/@/5`n 777    77777`n 727777778837`n 788888878787`n 787777888887`n77877778777777`n7e8b7888b888e7`n7787787b777877`n 777887887887`n   7487807487`n   7777777777`n`n/rom/programs/fun/advanced/levels/11/@/4`n   777777777`n   727872787`n   787878787`n777787878787777`n7be888888888be7`n777787878787777`n   787878787`n   787478747`n   777777777`n`n/rom/programs/fun/advanced/levels/12/@/6`n77  777  77`n72888888897`n 8   8   8`n 8 8b888 8`n78 e8888 87`n78888788887`n78 8888e 87`n 8 888b8 8`n 8   8   8`n75888888807`n77  777  77`n`n/rom/programs/fun/advanced/levels/2/@/1`n777777777`n7888888b7`n787778887`n787 78777`n7877787`n7888887`n7777787`n    707`n    777`n`n/rom/programs/fun/advanced/levels/3/@/2`n  77777777`n777888188777`n7b78777787b7`n78787  78787`n78787  78787`n78887  78887`n777877778777`n  78838887`n  77777777`n`n/rom/programs/fun/advanced/levels/4/@/2`n    77777777`n777778888887`n788888777787`n7b77787  787`n787 787  787`n7b77787  787`n7888887  787`n7777707  707`n    777  777`n`n/rom/programs/fun/advanced/levels/5/@/3`n777777777`n788888887`n787787787`n787787787`n788888887`n787787787`n787787787`n78e748887`n777777777`n`n/rom/programs/fun/advanced/levels/6/@/4`n7777777777`n7288888837`n78      87`n788888b 87`n788888b 87`n788888b 87`n788888b 87`n78      87`n7188888807`n7777777777`n`n/rom/programs/fun/advanced/levels/7/@/3`n728777778b7`n78888888887`n78777877787`n787 787 787`n787 7877788`n787 7888889`n88777877777`ne888887`n7777887`n`n/rom/programs/fun/advanced/levels/8/@/4`n777777 7777`n7287b7 7867`n788787 7887`n77878777877`n 7888eb8887`n 77877787877`n 7887 787887`n 7487 7e7807`n 7777 777777`n`n/rom/programs/fun/advanced/levels/9/@/2`n    777  777`n  777877778777`n  788838888887`n7778bbbbbbbb8777`n7888b888888b8897`n7878be8888eb8787`n7588b888888b8887`n7778bbbbbbbb8777`n  788888818887`n  777877778777`n    777  777`n/rom/programs/fun/advanced/levels`n/rom/programs/fun/advanced`n/rom/programs/fun`n`n/rom/programs/http/pastebin/@/`nlocal function printUsage()`n    print( "Usages:" )`n    print( "pastebin put <filename>" )`n    print( "pastebin get <code> <filename>" )`n    print( "pastebin run <code> <arguments>" )`nend`n `nlocal tArgs = { ... }`nif #tArgs < 2 then`n    printUsage()`n    return`nend`n `nif not http then`n    printError( "Pastebin requires http API" )`n    printError( "Set http_enable to true in ComputerCraft.cfg" )`n    return`nend`n `nlocal function get(paste)`n    write( "Connecting to pastebin.com... " )`n    local response = http.get(`n        "http://pastebin.com/raw.php?i="..textutils.urlEncode( paste )`n    )`n        `n    if response then`n        print( "Success." )`n        `n        local sResponse = response.readAll()`n        response.close()`n        return sResponse`n    else`n        printError( "Failed." )`n    end`nend`n `nlocal sCommand = tArgs[1]`nif sCommand == "put" then`n    -- Upload a file to pastebin.com`n    -- Determine file to upload`n    local sFile = tArgs[2]`n    local sPath = shell.resolve( sFile )`n    if not fs.exists( sPath ) or fs.isDir( sPath ) then`n        print( "No such file" )`n        return`n    end`n    `n    -- Read in the file`n    local sName = fs.getName( sPath )`n    local file = fs.open( sPath, "r" )`n    local sText = file.readAll()`n    file.close()`n    `n    -- POST the contents to pastebin`n    write( "Connecting to pastebin.com... " )`n    local key = "0ec2eb25b6166c0c27a394ae118ad829"`n    local response = http.post(`n        "http://pastebin.com/api/api_post.php", `n        "api_option=paste&"..`n        "api_dev_key="..key.."&"..`n        "api_paste_format=lua&"..`n        "api_paste_name="..textutils.urlEncode(sName).."&"..`n        "api_paste_code="..textutils.urlEncode(sText)`n    )`n        `n    if response then`n        print( "Success." )`n        `n        local sResponse = response.readAll()`n        response.close()`n                `n        local sCode = string.match( sResponse, "[^/]+$" )`n        print( "Uploaded as "..sResponse )`n        print( "Run \"pastebin get "..sCode.."\" to download anywhere" )`n `n    else`n        print( "Failed." )`n    end`n    `nelseif sCommand == "get" then`n    -- Download a file from pastebin.com`n    if #tArgs < 3 then`n        printUsage()`n        return`n    end`n `n    -- Determine file to download`n    local sCode = tArgs[2]`n    local sFile = tArgs[3]`n    local sPath = shell.resolve( sFile )`n    if fs.exists( sPath ) then`n        print( "File already exists" )`n        return`n    end`n    `n    -- GET the contents from pastebin`n    local res = get(sCode)`n    if res then        `n        local file = fs.open( sPath, "w" )`n        file.write( res )`n        file.close()`n        `n        print( "Downloaded as "..sFile )`n    end `nelseif sCommand == "run" then`n    local sCode = tArgs[2]`n `n    local res = get(sCode)`n    if res then`n        local func, err = loadstring(res)`n        if not func then`n            printError( err )`n            return`n        end`n        setfenv(func, getfenv())`n        local success, msg = pcall(func, unpack(tArgs, 3))`n        if not success then`n            printError( msg )`n        end`n    end`nelse`n    printUsage()`n    return`nend`n/rom/programs/http`n`n/rom/programs/pocket/falling/@/--[[`nFalling - Based on Tetris by Alexey Pajitnov`nThis version written by Gopher, at the request of Dan200, for`nComputerCraft v1.6. No particular rights are reserved.`n--]]`n`nlocal function colorass(c,bw)`n  return term.isColor() and c or bw`nend`n`nlocal block_s1= {`n    {`n      { 1,0,0,0, },`n      { 1,1,0,0, },`n      { 0,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,0,0,0, },`n      { 0,1,1,0, },`n      { 1,1,0,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","{}"),`n    fg=colorass(colors.blue,colors.black),`n    bg=colorass(colors.cyan,colors.white),`n  }`nlocal block_s2= {`n    {`n      { 0,1,0,0, },`n      { 1,1,0,0, },`n      { 1,0,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,0,0,0, },`n      { 1,1,0,0, },`n      { 0,1,1,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","{}"),`n    fg=colorass(colors.green,colors.black),`n    bg=colorass(colors.lime,colors.white),`n  }`nlocal block_line = {`n    {`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n    },`n    {`n      { 0,0,0,0, },`n      { 1,1,1,1, },`n      { 0,0,0,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","[]"),`n    fg=colorass(colors.pink,colors.black),`n    bg=colorass(colors.red,colors.white),`n  }`nlocal block_square = {`n    {`n      { 1,1,0,0, },`n      { 1,1,0,0, },`n      { 0,0,0,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","[]"),`n    fg=colorass(colors.lightBlue,colors.black),`n    bg=colorass(colors.blue,colors.white),`n  }`nlocal block_L1 = {`n    {`n      { 1,1,0,0, },`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,0,0,0, },`n      { 1,1,1,0, },`n      { 1,0,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n      { 0,1,1,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,0,1,0, },`n      { 1,1,1,0, },`n      { 0,0,0,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","()"),`n    fg=colorass(colors.orange,colors.black),`n    bg=colorass(colors.yellow,colors.white),`n  }`nlocal block_L2 = {`n    {`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n      { 1,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,0,0,0, },`n      { 1,1,1,0, },`n      { 0,0,1,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,1,1,0, },`n      { 0,1,0,0, },`n      { 0,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 1,0,0,0, },`n      { 1,1,1,0, },`n      { 0,0,0,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","()"),`n    fg=colorass(colors.brown,colors.black),`n    bg=colorass(colors.orange,colors.white),`n  }`nlocal block_T = {`n    {`n      { 0,1,0,0, },`n      { 1,1,0,0, },`n      { 0,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,0,0,0, },`n      { 1,1,1,0, },`n      { 0,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,1,0,0, },`n      { 0,1,1,0, },`n      { 0,1,0,0, },`n      { 0,0,0,0, },`n    },`n    {`n      { 0,1,0,0, },`n      { 1,1,1,0, },`n      { 0,0,0,0, },`n      { 0,0,0,0, },`n    },`n    ch=colorass("  ","<>"),`n    fg=colorass(colors.cyan,colors.black),`n    bg=colorass(colors.purple,colors.white),`n  }`n`nlocal blocks={ block_line, block_square, block_s1, block_s2, block_L1, block_L2, block_T}`n`nlocal points={4,10,30,120}`n`nlocal function lpad(text,amt)`n  text=tostring(text)`n  return string.rep(" ",amt-#text)..text`nend`n`nlocal width,height=term.getSize()`n`nif height<19 or width<26 then`n  print("Your screen is too small to play :(")`n  return`nend`n`n`nlocal speedsByLevel={`n  1.2,`n  1.0,`n   .8,`n   .65,`n   .5,`n   .4,`n   .3,`n   .25,`n   .2,`n   .15,`n   .1,`n   .05,}`n`nlocal level=1`n`nlocal function playGame()`n  local score=0`n  local lines=0`n  local initialLevel=level`n  local next=blocks[math.random(1,#blocks)]`n`n  local pit={}`n`n`n  local heightAdjust=0`n`n  if height<=19 then`n    heightAdjust=1`n  end`n`n`n`n  local function drawScreen()`n    term.setTextColor(colors.white)`n    term.setBackgroundColor(colors.black)`n    term.clear()`n`n    term.setTextColor(colors.black)`n    term.setBackgroundColor(colorass(colors.lightGray, colors.white))`n    term.setCursorPos(22,2)`n    term.write("Score") --score`n    term.setCursorPos(22,5)`n    term.write("Level")  --level`n    term.setCursorPos(22,8)`n    term.write("Lines")  --lines`n    term.setCursorPos(22,12)`n    term.write("Next") --next`n`n    term.setCursorPos(21,1)`n    term.write("      ")`n    term.setCursorPos(21,2)`n    term.write(" ") --score`n    term.setCursorPos(21,3)`n    term.write(" ")`n    term.setCursorPos(21,4)`n    term.write("      ")`n    term.setCursorPos(21,5)`n    term.write(" ")  --level`n    term.setCursorPos(21,6)`n    term.write(" ")`n    term.setCursorPos(21,7)`n    term.write("      ")`n    term.setCursorPos(21,8)`n    term.write(" ")  --lines`n    term.setCursorPos(21,9)`n    term.write(" ")`n    term.setCursorPos(21,10)`n    term.write("      ")`n    term.setCursorPos(21,11)`n    term.write("      ")`n    term.setCursorPos(21,12)`n    term.write(" ") --next`n    term.setCursorPos(26,12)`n    term.write(" ") --next`n    term.setCursorPos(21,13)`n    term.write("      ")`n    term.setCursorPos(21,14)`n    term.write(" ")`n    term.setCursorPos(21,15)`n    term.write(" ")`n    term.setCursorPos(21,16)`n    term.write(" ")`n    term.setCursorPos(21,17)`n    term.write(" ")`n    term.setCursorPos(21,18)`n    term.write(" ")`n    term.setCursorPos(21,19)`n    term.write("      ")`n    term.setCursorPos(21,20)`n    term.write("      ")`n  end`n`n  local function updateNumbers()`n    term.setTextColor(colors.white)`n    term.setBackgroundColor(colors.black)`n`n    term.setCursorPos(22,3)`n    term.write(lpad(score,5)) --score`n    term.setCursorPos(22,6)`n    term.write(lpad(level,5))  --level`n    term.setCursorPos(22,9)`n    term.write(lpad(lines,5))  --lines`n  end`n`n  local function drawBlockAt(block,xp,yp,rot)`n    term.setTextColor(block.fg)`n    term.setBackgroundColor(block.bg)`n    for y=1,4 do`n      for x=1,4 do`n        if block[rot][y][x]==1 then`n          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)`n          term.write(block.ch)`n        end`n      end`n    end`n  end`n`n  local function eraseBlockAt(block,xp,yp,rot)`n    term.setTextColor(colors.white)`n    term.setBackgroundColor(colors.black)`n    for y=1,4 do`n      for x=1,4 do`n        if block[rot][y][x]==1 then`n          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)`n          term.write("  ")`n        end`n      end`n    end`n  end`n`n  local function testBlockAt(block,xp,yp,rot)`n    for y=1,4 do`n      local ty=yp+y-1`n      for x=1,4 do`n        local tx=xp+x-1`n        if block[rot][y][x]==1 then`n          if tx>10 or tx<1 or ty>20 or pit[ty][tx]~=0 then`n            return true`n          end`n        end`n      end`n    end`n  end`n`n  local function pitBlock(block,xp,yp,rot)`n    for y=1,4 do`n      for x=1,4 do`n        if block[rot][y][x]==1 then`n          pit[yp+y-1][xp+x-1]=block`n        end`n      end`n    end`n  end`n`n`n  local function clearPit()`n    for row=1,20 do`n      pit[row]={}`n      for col=1,10 do`n        pit[row][col]=0`n      end`n    end`n  end`n`n`n`n  drawScreen()`n  updateNumbers()`n`n  --declare & init the pit`n  clearPit()`n`n`n`n  local halt=false`n  local dropSpeed=speedsByLevel[math.min(level,12)]`n`n`n  local curBlock=next`n  next=blocks[math.random(1,7)]`n`n  local curX, curY, curRot=4, 1, 1`n  local dropTimer=os.startTimer(dropSpeed)`n`n  drawBlockAt(next,11.5,15+heightAdjust,1)`n  drawBlockAt(curBlock,curX,curY,curRot)`n`n  local function redrawPit()`n    for r=1+heightAdjust,20 do`n      term.setCursorPos(1,r-heightAdjust)`n      for c=1,10 do`n        if pit[r][c]==0 then`n          term.setTextColor(colors.black)`n          term.setBackgroundColor(colors.black)`n          term.write("  ")`n        else`n          term.setTextColor(pit[r][c].fg)`n          term.setBackgroundColor(pit[r][c].bg)`n          term.write(pit[r][c].ch)`n        end`n      end`n    end`n  end`n`n  local function hidePit()`n    for r=1+heightAdjust,20 do`n      term.setCursorPos(1,r-heightAdjust)`n      term.setTextColor(colors.black)`n      term.setBackgroundColor(colors.black)`n      term.write("                    ")`n    end`n  end`n`n  local function msgBox(message)`n    local x=math.floor((17-#message)/2)`n    term.setBackgroundColor(colorass(colors.lightGray,colors.white))`n    term.setTextColor(colors.black)`n    term.setCursorPos(x,9)`n    term.write("+"..string.rep("-",#message+2).."+")`n    term.setCursorPos(x,10)`n    term.write("|")`n    term.setCursorPos(x+#message+3,10)`n    term.write("|")`n    term.setCursorPos(x,11)`n    term.write("+"..string.rep("-",#message+2).."+")`n    term.setTextColor(colors.white)`n    term.setBackgroundColor(colors.black)`n    term.setCursorPos(x+1,10)`n    term.write(" "..message.." ")`n  end`n`n  local function clearRows()`n    local rows={}`n    for r=1,20 do`n      local count=0`n      for c=1,10 do`n        if pit[r][c]~=0 then`n          count=count+1`n        else`n          break`n        end`n      end`n      if count==10 then`n        rows[#rows+1]=r`n      end`n    end`n`n    if #rows>0 then`n      for i=1,4 do`n        sleep(.1)`n        for r=1,#rows do`n          r=rows[r]`n          term.setCursorPos(1,r-heightAdjust)`n          for c=1,10 do`n            term.setTextColor(pit[r][c].bg)`n            term.setBackgroundColor(pit[r][c].fg)`n            term.write(pit[r][c].ch)`n          end`n        end`n        sleep(.1)`n        for r=1,#rows do`n          r=rows[r]`n          term.setCursorPos(1,r-heightAdjust)`n          for c=1,10 do`n            term.setTextColor(pit[r][c].fg)`n            term.setBackgroundColor(pit[r][c].bg)`n            term.write(pit[r][c].ch)`n          end`n        end`n      end`n      --now remove the rows and drop everythign else`n      term.setBackgroundColor(colors.black)`n      for r=1,#rows do`n        r=rows[r]`n        term.setCursorPos(1,r-heightAdjust)`n        term.write("                    ")`n      end`n      sleep(.25)`n      for r=1,#rows do`n        table.remove(pit,rows[r])`n        table.insert(pit,1,{0,0,0,0,0,0,0,0,0,0})`n      end`n      redrawPit()`n      lines=lines+#rows`n      score=score+points[#rows]*math.min(level,20)`n      level=math.floor(lines/10)+initialLevel`n      dropSpeed=speedsByLevel[math.min(level,12)]`n      updateNumbers()`n    end`n    sleep(.25)`n  end`n`n  local function blockFall()`n    local result = false`n    if testBlockAt(curBlock,curX,curY+1,curRot) then`n      pitBlock(curBlock,curX,curY,curRot)`n      --detect rows that clear`n      clearRows(rows)`n`n      curBlock=next`n      curX=4`n      curY=1`n      curRot=1`n      if testBlockAt(curBlock,curX,curY,curRot) then`n        halt=true`n      end`n      drawBlockAt(curBlock,curX,curY,curRot)`n      eraseBlockAt(next,11.5,15+heightAdjust,1)`n      next=blocks[math.random(1,7)]`n      drawBlockAt(next,11.5,15+heightAdjust,1)`n      return true`n    else`n      eraseBlockAt(curBlock,curX,curY,curRot)`n      curY=curY+1`n      drawBlockAt(curBlock,curX,curY,curRot)`n      return false`n    end`n  end`n`n`n  while not halt do`n    local e={os.pullEvent()}`n    if e[1]=="timer" then`n      if e[2]==dropTimer then`n        blockFall()`n        dropTimer=os.startTimer(dropSpeed)`n      end`n    elseif e[1]=="key" then`n      local key=e[2]`n      local dx,dy,dr=0,0,0`n      if key==keys.left or key==keys.a then`n        dx=-1`n      elseif key==keys.right or key==keys.d then`n        dx=1`n      elseif key==keys.up or key==keys.w then`n        dr=1`n      elseif key==keys.down or key==keys.s then`n        while not blockFall() do end`n        dropTimer=os.startTimer(dropSpeed)`n      elseif key==keys.space then`n        hidePit()`n        msgBox("Paused")`n        while ({os.pullEvent("key")})[2]~=keys.space do end`n        redrawPit()`n        drawBlockAt(curBlock,curX,curY,curRot)`n        dropTimer=os.startTimer(dropSpeed)`n      end`n      if dx+dr~=0 then`n        if not testBlockAt(curBlock,curX+dx,curY+dy,(dr>0 and curRot%#curBlock+dr or curRot)) then`n          eraseBlockAt(curBlock,curX,curY,curRot)`n          curX=curX+dx`n          curY=curY+dy`n          curRot=dr==0 and curRot or (curRot%#curBlock+dr)`n          drawBlockAt(curBlock,curX,curY,curRot)`n        end`n      end`n    elseif e[1]=="term_resize" then`n      local w,h=term.getSize()`n      if h==20 then`n        heightAdjust=0`n      else`n        heightAdjust=1`n      end`n      redrawPit()`n      drawBlockAt(curBlock,curX,curY,curRot)`n    end`n  end`n`n  msgBox("Game Over!")`n  while true do`n    local _,k=os.pullEvent("key")`n    if k==keys.space or k==keys.enter then`n      break`n    end`n  end`n`n  level = math.min(level,9)`nend`n`n`nlocal selected=1`nlocal playersDetected=false`n`nlocal function drawMenu()`n  term.setBackgroundColor(colors.black)`n  term.setTextColor(colorass(colors.red,colors.white))`n  term.clear()`n`n  local cx,cy=math.floor(width/2),math.floor(height/2)`n`n  term.setCursorPos(cx-6,cy-2)`n  term.write("F A L L I N G")`n`n  if playersDetected then`n    if selected==0 then`n      term.setTextColor(colorass(colors.blue,colors.black))`n      term.setBackgroundColor(colorass(colors.gray,colors.white))`n    else`n      term.setTextColor(colorass(colors.lightBlue,colors.white))`n      term.setBackgroundColor(colors.black)`n    end`n    term.setCursorPos(cx-12,cy)`n    term.write(" Play head-to-head game! ")`n  end`n`n  term.setCursorPos(cx-10,cy+1)`n  if selected==1 then`n    term.setTextColor(colorass(colors.blue,colors.black))`n    term.setBackgroundColor(colorass(colors.lightGray,colors.white))`n  else`n    term.setTextColor(colorass(colors.lightBlue,colors.white))`n    term.setBackgroundColor(colors.black)`n  end`n  term.write(" Play from level: <" .. level .. "> ")`n`n  term.setCursorPos(cx-3,cy+3)`n  if selected==2 then`n    term.setTextColor(colorass(colors.blue,colors.black))`n    term.setBackgroundColor(colorass(colors.lightGray,colors.white))`n  else`n    term.setTextColor(colorass(colors.lightBlue,colors.white))`n    term.setBackgroundColor(colors.black)`n  end`n  term.write(" Quit ")`nend`n`n`nlocal function runMenu()`n  drawMenu()`n`n  while true do`n    local event={os.pullEvent()}`n    if event[1]=="key" then`n      local key=event[2]`n      if key==keys.right or key==keys.d and selected==1 then`n        level=math.min(level+1,9)`n        drawMenu()`n      elseif key==keys.left or key==keys.a and selected==1 then`n        level=math.max(level-1,1)`n        drawMenu()`n      elseif key>=keys.one and key<=keys.nine and selected==1 then`n        level=(key-keys.one) + 1`n        drawMenu()`n      elseif key==keys.up or key==keys.w then`n        selected=selected-1`n        if selected==0 then`n          selected=2`n        end`n        drawMenu()`n      elseif key==keys.down or key==keys.s then`n        selected=selected%2+1`n        drawMenu()`n      elseif key==keys.enter or key==keys.space then`n        break --begin play!`n      end`n    end`n  end`nend`n`nwhile true do`n  runMenu()`n  if selected==2 then`n    break`n  end`n`n  playGame()`nend`n`n`nterm.setTextColor(colors.white)`nterm.setBackgroundColor(colors.black)`nterm.clear()`nterm.setCursorPos(1,1)`n/rom/programs/pocket`n`n/rom/programs/rednet/chat/@/`nlocal tArgs = { ... }`n`nlocal function printUsage()`n	print( "Usages:" )`n	print( "chat host <hostname>" )`n	print( "chat join <hostname> <nickname>" )`nend`n`nlocal sOpenedModem = nil`nlocal function openModem()`n    for n,sModem in ipairs( peripheral.getNames() ) do`n        if peripheral.getType( sModem ) == "modem" then`n            if not rednet.isOpen( sModem ) then`n                rednet.open( sModem )`n                sOpenedModem = sModem`n            end`n            return true`n        end`n    end`n    print( "No modems found." )`n    return false`nend`n`nlocal function closeModem()`n    if sOpenedModem ~= nil then`n        rednet.close( sOpenedModem )`n        sOpenedModem = nil`n    end`nend`n`n-- Colours`nlocal highlightColour, textColour`nif term.isColour() then`n	textColour = colours.white`n	highlightColour = colours.yellow`nelse`n	textColour = colours.white`n	highlightColour = colours.white`nend`n`nlocal sCommand = tArgs[1]`nif sCommand == "host" then`n    -- "chat host"`n    -- Get hostname`n    local sHostname = tArgs[2]`n    if sHostname == nil then`n        printUsage()`n        return`n    end`n`n    -- Host server`n    if not openModem() then`n        return`n    end`n    rednet.host( "chat", sHostname )`n    print( "0 users connected." )`n`n    local tUsers = {}`n    local nUsers = 0`n    function send( sText, nUserID )`n        if nUserID then`n            local tUser = tUsers[ nUserID ]`n            if tUser then`n                rednet.send( tUser.nID, {`n                    sType = "text",`n                    nUserID = nUserID,`n                    sText = sText,`n                }, "chat" )`n            end`n        else`n            for nUserID, tUser in pairs( tUsers ) do`n                rednet.send( tUser.nID, {`n                    sType = "text",`n                    nUserID = nUserID,`n                    sText = sText,`n                }, "chat" )`n            end`n        end`n    end`n`n    -- Setup ping pong`n    local tPingPongTimer = {}`n    function ping( nUserID )`n        local tUser = tUsers[ nUserID ]`n        rednet.send( tUser.nID, {`n            sType = "ping to client",`n            nUserID = nUserID,`n        }, "chat" )`n`n        local timer = os.startTimer( 15 )`n        tUser.bPingPonged = false`n        tPingPongTimer[ timer ] = nUserID`n    end`n`n    function printUsers()`n        local x,y = term.getCursorPos()`n        term.setCursorPos( 1, y - 1 )`n        term.clearLine()`n        if nUsers == 1 then`n            print( nUsers .. " user connected." )`n        else`n            print( nUsers .. " users connected." )`n        end`n    end`n`n    -- Handle messages`n    local ok, error = pcall( function()`n        parallel.waitForAny( function()`n            while true do`n                local sEvent, timer = os.pullEvent( "timer" )`n                local nUserID = tPingPongTimer[ timer ]`n                if nUserID and tUsers[ nUserID ] then`n                    local tUser = tUsers[ nUserID ]`n                    if tUser then`n                        if not tUser.bPingPonged then`n                            send( "* "..tUser.sUsername.." has timed out" )`n                            tUsers[ nUserID ] = nil`n                            nUsers = nUsers - 1`n                            printUsers()`n                        else`n                            ping( nUserID )`n                        end`n                    end`n                end`n            end`n        end,`n        function()`n            while true do`n                local tCommands`n                tCommands = {`n                    ["me"] = function( tUser, sContent )`n                        if string.len(sContent) > 0 then`n                            send( "* "..tUser.sUsername.." "..sContent )`n                        else`n                            send( "* Usage: /me [words]", tUser.nUserID )`n                        end`n                    end,`n                    ["nick"] = function( tUser, sContent )`n                        if string.len(sContent) > 0 then`n                            local sOldName = tUser.sUsername`n                            tUser.sUsername = sContent`n                            send( "* "..sOldName.." is now known as "..tUser.sUsername )`n                        else`n                            send( "* Usage: /nick [nickname]", tUser.nUserID )`n                        end`n                    end,`n                    ["users"] = function( tUser, sContent )`n                        send( "* Connected Users:", tUser.nUserID )`n                        local sUsers = "*"`n                        for nUserID, tUser in pairs( tUsers ) do`n                            sUsers = sUsers .. " " .. tUser.sUsername`n                        end`n                        send( sUsers, tUser.nUserID )`n                    end,`n                    ["help"] = function( tUser, sContent )`n                        send( "* Available commands:", tUser.nUserID )`n                        local sCommands = "*"`n                        for sCommand, fnCommand in pairs( tCommands ) do`n                            sCommands = sCommands .. " /" .. sCommand`n                        end`n                        send( sCommands.." /logout", tUser.nUserID )`n                    end,`n                }`n`n                local nSenderID, tMessage = rednet.receive( "chat" )`n                if type( tMessage ) == "table" then`n                    if tMessage.sType == "login" then`n                        -- Login from new client`n                        local nUserID = tMessage.nUserID`n                        local sUsername = tMessage.sUsername`n                        if nUserID and sUsername then`n                            tUsers[ nUserID ] = {`n                                nID = nSenderID,`n                                nUserID = nUserID,`n                                sUsername = sUsername,`n                            }`n                            nUsers = nUsers + 1`n                            printUsers()`n                            send( "* "..sUsername.." has joined the chat" )`n                            ping( nUserID )`n                        end`n`n                    else`n                        -- Something else from existing client`n                        local nUserID = tMessage.nUserID`n                        local tUser = tUsers[ nUserID ]`n                        if tUser and tUser.nID == nSenderID then`n                            if tMessage.sType == "logout" then`n                                send( "* "..tUser.sUsername.." has left the chat" )`n                                tUsers[ nUserID ] = nil`n                                nUsers = nUsers - 1`n                                printUsers()`n`n                            elseif tMessage.sType == "chat" then`n                                local sMessage = tMessage.sText`n                                if sMessage then`n                                    local sCommand = string.match( sMessage, "^/([a-z]+)" )`n                                    if sCommand then`n                                        local fnCommand = tCommands[ sCommand ]`n                                        if fnCommand then`n                                            local sContent = string.sub( sMessage, string.len(sCommand)+3 )`n                                            fnCommand( tUser, sContent )`n                                        else`n                                            send( "* Unrecognised command: /"..sCommand, tUser.nUserID )`n                                        end`n                                    else`n                                        send( "<"..tUser.sUsername.."> "..tMessage.sText )`n                                    end`n                                end`n`n                            elseif tMessage.sType == "ping to server" then`n                                rednet.send( tUser.nID, {`n                                    sType = "pong to client",`n                                    nUserID = nUserID,`n                                }, "chat" )`n`n                            elseif tMessage.sType == "pong to server" then`n                                tUser.bPingPonged = true`n`n                            end`n                        end`n                    end`n                 end`n            end`n        end )`n    end )`n    if not ok then`n        printError( error )`n    end`n`n    -- Unhost server`n    for nUserID, tUser in pairs( tUsers ) do`n        rednet.send( tUser.nID, {`n            sType = "kick",`n            nUserID = nUserID,`n        }, "chat" )`n    end`n    rednet.unhost( "chat" )`n    closeModem()`n`nelseif sCommand == "join" then`n    -- "chat join"`n    -- Get hostname and username`n    local sHostname = tArgs[2]`n    local sUsername = tArgs[3]`n    if sHostname == nil or sUsername == nil then`n        printUsage()`n        return`n    end`n`n    -- Connect`n    if not openModem() then`n        return`n    end`n    write( "Looking up " .. sHostname .. "... " )`n    local nHostID = rednet.lookup( "chat", sHostname )`n    if nHostID == nil then`n        print( "Failed." )`n        return`n    else`n        print( "Success." )`n    end`n`n    -- Login`n    local nUserID = math.random( 1, 2147483647 )`n    rednet.send( nHostID, {`n        sType = "login",`n        nUserID = nUserID,`n        sUsername = sUsername,`n    }, "chat" )`n`n    -- Setup ping pong`n    local bPingPonged = true`n    local pingPongTimer = os.startTimer( 0 )`n`n    function ping()`n        rednet.send( nHostID, {`n            sType = "ping to server",`n            nUserID = nUserID,`n        }, "chat" )`n        bPingPonged = false`n        pingPongTimer = os.startTimer( 15 )`n    end`n`n    -- Handle messages`n    local w,h = term.getSize()`n    local parentTerm = term.current()`n    local titleWindow = window.create( parentTerm, 1, 1, w, 1, true )`n    local historyWindow = window.create( parentTerm, 1, 2, w, h-2, true )`n    local promptWindow = window.create( parentTerm, 1, h, w, 1, true )`n    historyWindow.setCursorPos( 1, h-2 )`n`n    term.clear()`n    term.setTextColour( textColour )`n    term.redirect( promptWindow )`n    promptWindow.restoreCursor()`n`n    function drawTitle()`n        local x,y = titleWindow.getCursorPos()`n        local w,h = titleWindow.getSize()`n        local sTitle = sUsername.." on "..sHostname`n        titleWindow.setTextColour( highlightColour )`n        titleWindow.setCursorPos( math.floor( w/2 - string.len(sTitle)/2 ), 1 )`n        titleWindow.clearLine()`n        titleWindow.write( sTitle )`n        promptWindow.restoreCursor()`n    end`n`n    function printMessage( sMessage )`n        term.redirect( historyWindow )`n        print()`n        if string.match( sMessage, "^\*" ) then`n            -- Information`n            term.setTextColour( highlightColour )`n            write( sMessage )`n            term.setTextColour( textColour )`n        else`n            -- Chat`n            local sUsernameBit = string.match( sMessage, "^\<[^\>]*\>" )`n            if sUsernameBit then`n                term.setTextColour( highlightColour )`n                write( sUsernameBit )`n                term.setTextColour( textColour )`n                write( string.sub( sMessage, string.len( sUsernameBit ) + 1 ) )`n            else`n                write( sMessage )`n            end`n        end`n        term.redirect( promptWindow )`n        promptWindow.restoreCursor()`n    end`n`n    drawTitle()`n`n    local ok, error = pcall( function()`n        parallel.waitForAny( function()`n            while true do`n                local sEvent, timer = os.pullEvent()`n                if sEvent == "timer" then`n                    if timer == pingPongTimer then`n                        if not bPingPonged then`n                            printMessage( "Server timeout." )`n                            return`n                        else`n                            ping()`n                        end`n                    end`n`n                elseif sEvent == "term_resize" then`n                    local w,h = parentTerm.getSize()`n                    titleWindow.reposition( 1, 1, w, 1 )`n                    historyWindow.reposition( 1, 2, w, h-2 )`n                    promptWindow.reposition( 1, h, w, 1 )`n`n                end`n            end`n        end,`n        function()`n            while true do`n                local nSenderID, tMessage = rednet.receive( "chat" )`n                if nSenderID == nHostID and type( tMessage ) == "table" and tMessage.nUserID == nUserID then`n                    if tMessage.sType == "text" then`n                        local sText = tMessage.sText`n                        if sText then`n                            printMessage( sText )`n                        end`n`n                    elseif tMessage.sType == "ping to client" then`n                        rednet.send( nSenderID, {`n                            sType = "pong to server",`n                            nUserID = nUserID,`n                        }, "chat" )`n`n                    elseif tMessage.sType == "pong to client" then`n                        bPingPonged = true`n`n                    elseif tMessage.sType == "kick" then`n                        return`n`n                    end`n                end`n            end`n        end,`n        function()`n            local tSendHistory = {}`n            while true do`n                promptWindow.setCursorPos( 1,1 )`n                promptWindow.clearLine()`n                promptWindow.setTextColor( highlightColour )`n                promptWindow.write( ": ")`n                promptWindow.setTextColor( textColour )`n`n                local sChat = read( nil, tSendHistory )`n                if string.match( sChat, "^/logout" ) then`n                    break`n                else`n                    rednet.send( nHostID, {`n                        sType = "chat",`n                        nUserID = nUserID,`n                        sText = sChat,`n                    }, "chat" )`n                    table.insert( tSendHistory, sChat )`n                end`n            end`n        end )`n    end )`n`n    -- Close the windows`n    term.redirect( parentTerm )`n`n    -- Print error notice`n    local w,h = term.getSize()`n    term.setCursorPos( 1, h )`n    term.clearLine()`n    term.setCursorBlink( false )`n    if not ok then`n        printError( error )`n    end`n`n    -- Logout`n    rednet.send( nHostID, {`n        sType = "logout",`n        nUserID = nUserID,`n    }, "chat" )`n    closeModem()`n`n    -- Print disconnection notice`n    print( "Disconnected." )`n`nelse`n    -- "chat somethingelse"`n    printUsage()`n`nend`n`n/rom/programs/rednet/repeat/@/`n-- Find modems`nlocal tModems = {}`nfor n,sModem in ipairs( peripheral.getNames() ) do`n    if peripheral.getType( sModem ) == "modem" then`n        table.insert( tModems, sModem )`n    end`nend`nif #tModems == 0 then`n    print( "No modems found." )`n    return`nelseif #tModems == 1 then`n    print( "1 modem found." )`nelse`n    print( #tModems .. " modems found." )`nend`n`nfunction open( nChannel )`n    for n=1,#tModems do`n        local sModem = tModems[n]`n        peripheral.call( sModem, "open", nChannel )`n    end`nend`n`nfunction close( nChannel )`n    for n=1,#tModems do`n        local sModem = tModems[n]`n        peripheral.call( sModem, "close", nChannel )`n    end`nend`n`n-- Open channels`nprint( "0 messages repeated." )`nopen( rednet.CHANNEL_REPEAT )`n`n-- Main loop (terminate to break)`nlocal ok, error = pcall( function()`n    local tReceivedMessages = {}`n    local tReceivedMessageTimeouts = {}`n    local nTransmittedMessages = 0`n`n    while true do`n        local sEvent, sModem, nChannel, nReplyChannel, tMessage = os.pullEvent()`n        if sEvent == "modem_message" then`n            -- Got a modem message, rebroadcast it if it's a rednet thing`n            if nChannel == rednet.CHANNEL_REPEAT then`n                if type( tMessage ) == "table" and tMessage.nMessageID and tMessage.nRecipient then`n                    if not tReceivedMessages[ tMessage.nMessageID ] then`n                        -- Ensure we only repeat a message once`n                        tReceivedMessages[ tMessage.nMessageID ] = true`n                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = tMessage.nMessageID`n`n                        -- Send on all other open modems, to the target and to other repeaters`n                        for n=1,#tModems do`n                            local sOtherModem = tModems[n]`n                            peripheral.call( sOtherModem, "transmit", rednet.CHANNEL_REPEAT, nReplyChannel, tMessage )`n                            peripheral.call( sOtherModem, "transmit", tMessage.nRecipient, nReplyChannel, tMessage )`n                        end`n`n                        -- Log the event`n                        nTransmittedMessages = nTransmittedMessages + 1`n                        local x,y = term.getCursorPos()`n                        term.setCursorPos( 1, y - 1 )`n                        term.clearLine()`n                        if nTransmittedMessages == 1 then`n                            print( nTransmittedMessages .. " message repeated." )`n                        else`n                            print( nTransmittedMessages .. " messages repeated." )`n                        end`n                    end`n                end`n            end`n`n        elseif sEvent == "timer" then`n            -- Got a timer event, use it to clear the message history`n            local nTimer = sModem`n            local nMessageID = tReceivedMessageTimeouts[ nTimer ]`n            if nMessageID then`n                tReceivedMessageTimeouts[ nTimer ] = nil`n                tReceivedMessages[ nMessageID ] = nil`n            end`n`n        end`n    end`nend )`nif not ok then`n    printError( error )`nend`n`n-- Close channels`nclose( rednet.CHANNEL_REPEAT )`n/rom/programs/rednet`n`n/rom/programs/turtle/craft/@/`nif not turtle.craft then`n    print( "Requires a Crafty Turtle" )`n    return`nend`n`nlocal tArgs = { ... }`nlocal nLimit = nil`nif #tArgs < 1 then`n	print( "Usage: craft [number]" )`n	return`nelse`n	nLimit = tonumber( tArgs[1] )`nend`n`nlocal nCrafted = 0`nlocal nOldCount = turtle.getItemCount( turtle.getSelectedSlot() )`nif turtle.craft( nLimit ) then`n    local nNewCount = turtle.getItemCount( turtle.getSelectedSlot() )`n    if nOldCount <= nLimit then`n        nCrafted = nNewCount`n    else`n        nCrafted = nOldCount - nNewCount`n    end`nend`n`nif nCrafted > 1 then`n    print( nCrafted.." items crafted" )`nelseif nCrafted == 1 then`n    print( "1 item crafted" )`nelse`n    print( "No items crafted" )`nend`n`n/rom/programs/turtle/dance/@/`nlocal tMoves = {`n	function()`n		turtle.up()`n		turtle.down()`n	end,`n	function()`n		turtle.up()`n		turtle.turnLeft()`n		turtle.turnLeft()`n		turtle.turnLeft()`n		turtle.turnLeft()`n		turtle.down()`n	end,`n	function()`n		turtle.up()`n		turtle.turnRight()`n		turtle.turnRight()`n		turtle.turnRight()`n		turtle.turnRight()`n		turtle.down()`n	end,`n	function()`n		turtle.turnLeft()`n		turtle.turnLeft()`n		turtle.turnLeft()`n		turtle.turnLeft()`n	end,`n	function()`n		turtle.turnRight()`n		turtle.turnRight()`n		turtle.turnRight()`n		turtle.turnRight()`n	end,`n	function()`n		turtle.turnLeft()`n		turtle.back()`n		turtle.back()`n		turtle.turnRight()`n		turtle.turnRight()`n		turtle.back()`n		turtle.back()`n		turtle.turnLeft()`n	end,`n	function()`n		turtle.turnRight()`n		turtle.back()`n		turtle.back()`n		turtle.turnLeft()`n		turtle.turnLeft()`n		turtle.back()`n		turtle.back()`n		turtle.turnRight()`n	end,`n	function()`n		turtle.back()`n		turtle.turnLeft()`n		turtle.back()`n		turtle.turnLeft()`n		turtle.back()`n		turtle.turnLeft()`n		turtle.back()`n		turtle.turnLeft()`n	end,`n	function()`n		turtle.back()`n		turtle.turnRight()`n		turtle.back()`n		turtle.turnRight()`n		turtle.back()`n		turtle.turnRight()`n		turtle.back()`n		turtle.turnRight()`n	end,`n}`n`ntextutils.slowWrite( "Preparing to get down." )`ntextutils.slowPrint( "..", 0.75 )`n`nlocal sAudio = nil`nfor n,sName in pairs( peripheral.getNames() ) do`n	if disk.hasAudio( sName ) then`n		disk.playAudio( sName )`n		print( "Jamming to "..disk.getAudioTitle( sName ) )`n		sAudio = sName`n		break`n	end`nend`n`nprint( "Press any key to stop the groove" )`n`nlocal bEnd = false`nparallel.waitForAll(`n	function()`n		while not bEnd do`n			local event, key = os.pullEvent("key")`n			if key ~= keys.escape then`n				bEnd = true`n			end`n		end		`n	end,`n	function()`n		while not bEnd do`n			local fnMove = tMoves[math.random(1,#tMoves)]`n			fnMove()`n		end`n	end`n)`n`nif sAudio then`n	disk.stopAudio( sAudio )`nend`n`n/rom/programs/turtle/equip/@/`nlocal tArgs = { ... }`nlocal function printUsage()`n	print( "Usage: equip <slot> <side>" )`nend`n`nif #tArgs ~= 2 then`n    printUsage()`n	return`nend`n`nlocal function equip( nSlot, fnEquipFunction )`n    turtle.select( nSlot )`n    local nOldCount = turtle.getItemCount( nSlot )`n    if nOldCount == 0 then`n        print( "Nothing to equip" )`n    elseif fnEquipFunction() then`n        local nNewCount = turtle.getItemCount( nSlot )`n        if nNewCount > 0 then`n            print( "Items swapped" )`n        else`n            print( "Item equipped" )`n        end`n    else`n        print( "Item not equippable" )`n    end`nend`n`nlocal nSlot = tonumber( tArgs[1] )`nlocal sSide = tArgs[2]`nif sSide == "left" then`n    equip( nSlot, turtle.equipLeft )`nelseif sSide == "right" then`n    equip( nSlot, turtle.equipRight )`nelse`n    printUsage()`n    return`nend`n`n/rom/programs/turtle/excavate/@/`nlocal tArgs = { ... }`nif #tArgs ~= 1 then`n	print( "Usage: excavate <diameter>" )`n	return`nend`n`n-- Mine in a quarry pattern until we hit something we can't dig`nlocal size = tonumber( tArgs[1] )`nif size < 1 then`n	print( "Excavate diameter must be positive" )`n	return`nend`n	`nlocal depth = 0`nlocal unloaded = 0`nlocal collected = 0`n`nlocal xPos,zPos = 0,0`nlocal xDir,zDir = 0,1`n`nlocal goTo -- Filled in further down`nlocal refuel -- Filled in further down`n `nlocal function unload( _bKeepOneFuelStack )`n	print( "Unloading items..." )`n	for n=1,16 do`n		local nCount = turtle.getItemCount(n)`n		if nCount > 0 then`n			turtle.select(n)			`n			local bDrop = true`n			if _bKeepOneFuelStack and turtle.refuel(0) then`n				bDrop = false`n				_bKeepOneFuelStack = false`n			end			`n			if bDrop then`n				turtle.drop()`n				unloaded = unloaded + nCount`n			end`n		end`n	end`n	collected = 0`n	turtle.select(1)`nend`n`nlocal function returnSupplies()`n	local x,y,z,xd,zd = xPos,depth,zPos,xDir,zDir`n	print( "Returning to surface..." )`n	goTo( 0,0,0,0,-1 )`n	`n	local fuelNeeded = 2*(x+y+z) + 1`n	if not refuel( fuelNeeded ) then`n		unload( true )`n		print( "Waiting for fuel" )`n		while not refuel( fuelNeeded ) do`n			os.pullEvent( "turtle_inventory" )`n		end`n	else`n		unload( true )	`n	end`n	`n	print( "Resuming mining..." )`n	goTo( x,y,z,xd,zd )`nend`n`nlocal function collect()	`n	local bFull = true`n	local nTotalItems = 0`n	for n=1,16 do`n		local nCount = turtle.getItemCount(n)`n		if nCount == 0 then`n			bFull = false`n		end`n		nTotalItems = nTotalItems + nCount`n	end`n	`n	if nTotalItems > collected then`n		collected = nTotalItems`n		if math.fmod(collected + unloaded, 50) == 0 then`n			print( "Mined "..(collected + unloaded).." items." )`n		end`n	end`n	`n	if bFull then`n		print( "No empty slots left." )`n		return false`n	end`n	return true`nend`n`nfunction refuel( ammount )`n	local fuelLevel = turtle.getFuelLevel()`n	if fuelLevel == "unlimited" then`n		return true`n	end`n	`n	local needed = ammount or (xPos + zPos + depth + 2)`n	if turtle.getFuelLevel() < needed then`n		local fueled = false`n		for n=1,16 do`n			if turtle.getItemCount(n) > 0 then`n				turtle.select(n)`n				if turtle.refuel(1) then`n					while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do`n						turtle.refuel(1)`n					end`n					if turtle.getFuelLevel() >= needed then`n						turtle.select(1)`n						return true`n					end`n				end`n			end`n		end`n		turtle.select(1)`n		return false`n	end`n	`n	return true`nend`n`nlocal function tryForwards()`n	if not refuel() then`n		print( "Not enough Fuel" )`n		returnSupplies()`n	end`n	`n	while not turtle.forward() do`n		if turtle.detect() then`n			if turtle.dig() then`n				if not collect() then`n					returnSupplies()`n				end`n			else`n				return false`n			end`n		elseif turtle.attack() then`n			if not collect() then`n				returnSupplies()`n			end`n		else`n			sleep( 0.5 )`n		end`n	end`n	`n	xPos = xPos + xDir`n	zPos = zPos + zDir`n	return true`nend`n`nlocal function tryDown()`n	if not refuel() then`n		print( "Not enough Fuel" )`n		returnSupplies()`n	end`n	`n	while not turtle.down() do`n		if turtle.detectDown() then`n			if turtle.digDown() then`n				if not collect() then`n					returnSupplies()`n				end`n			else`n				return false`n			end`n		elseif turtle.attackDown() then`n			if not collect() then`n				returnSupplies()`n			end`n		else`n			sleep( 0.5 )`n		end`n	end`n`n	depth = depth + 1`n	if math.fmod( depth, 10 ) == 0 then`n		print( "Descended "..depth.." metres." )`n	end`n`n	return true`nend`n`nlocal function turnLeft()`n	turtle.turnLeft()`n	xDir, zDir = -zDir, xDir`nend`n`nlocal function turnRight()`n	turtle.turnRight()`n	xDir, zDir = zDir, -xDir`nend`n`nfunction goTo( x, y, z, xd, zd )`n	while depth > y do`n		if turtle.up() then`n			depth = depth - 1`n		elseif turtle.digUp() or turtle.attackUp() then`n			collect()`n		else`n			sleep( 0.5 )`n		end`n	end`n`n	if xPos > x then`n		while xDir ~= -1 do`n			turnLeft()`n		end`n		while xPos > x do`n			if turtle.forward() then`n				xPos = xPos - 1`n			elseif turtle.dig() or turtle.attack() then`n				collect()`n			else`n				sleep( 0.5 )`n			end`n		end`n	elseif xPos < x then`n		while xDir ~= 1 do`n			turnLeft()`n		end`n		while xPos < x do`n			if turtle.forward() then`n				xPos = xPos + 1`n			elseif turtle.dig() or turtle.attack() then`n				collect()`n			else`n				sleep( 0.5 )`n			end`n		end`n	end`n	`n	if zPos > z then`n		while zDir ~= -1 do`n			turnLeft()`n		end`n		while zPos > z do`n			if turtle.forward() then`n				zPos = zPos - 1`n			elseif turtle.dig() or turtle.attack() then`n				collect()`n			else`n				sleep( 0.5 )`n			end`n		end`n	elseif zPos < z then`n		while zDir ~= 1 do`n			turnLeft()`n		end`n		while zPos < z do`n			if turtle.forward() then`n				zPos = zPos + 1`n			elseif turtle.dig() or turtle.attack() then`n				collect()`n			else`n				sleep( 0.5 )`n			end`n		end	`n	end`n	`n	while depth < y do`n		if turtle.down() then`n			depth = depth + 1`n		elseif turtle.digDown() or turtle.attackDown() then`n			collect()`n		else`n			sleep( 0.5 )`n		end`n	end`n	`n	while zDir ~= zd or xDir ~= xd do`n		turnLeft()`n	end`nend`n`nif not refuel() then`n	print( "Out of Fuel" )`n	return`nend`n`nprint( "Excavating..." )`n`nlocal reseal = false`nturtle.select(1)`nif turtle.digDown() then`n	reseal = true`nend`n`nlocal alternate = 0`nlocal done = false`nwhile not done do`n	for n=1,size do`n		for m=1,size-1 do`n			if not tryForwards() then`n				done = true`n				break`n			end`n		end`n		if done then`n			break`n		end`n		if n<size then`n			if math.fmod(n + alternate,2) == 0 then`n				turnLeft()`n				if not tryForwards() then`n					done = true`n					break`n				end`n				turnLeft()`n			else`n				turnRight()`n				if not tryForwards() then`n					done = true`n					break`n				end`n				turnRight()`n			end`n		end`n	end`n	if done then`n		break`n	end`n	`n	if size > 1 then`n		if math.fmod(size,2) == 0 then`n			turnRight()`n		else`n			if alternate == 0 then`n				turnLeft()`n			else`n				turnRight()`n			end`n			alternate = 1 - alternate`n		end`n	end`n	`n	if not tryDown() then`n		done = true`n		break`n	end`nend`n`nprint( "Returning to surface..." )`n`n-- Return to where we started`ngoTo( 0,0,0,0,-1 )`nunload( false )`ngoTo( 0,0,0,0,1 )`n`n-- Seal the hole`nif reseal then`n	turtle.placeDown()`nend`n`nprint( "Mined "..(collected + unloaded).." items total." )`n`n/rom/programs/turtle/go/@/local tArgs = { ... }`nif #tArgs < 1 then`n	print( "Usage: go <direction> <distance>" )`n	return`nend`n`nlocal tHandlers = {`n	["fd"] = turtle.forward,`n	["forward"] = turtle.forward,`n	["forwards"] = turtle.forward,`n	["bk"] = turtle.back,`n	["back"] = turtle.back,`n	["up"] = turtle.up,`n	["dn"] = turtle.down,`n	["down"] = turtle.down,`n	["lt"] = turtle.turnLeft,`n	["left"] = turtle.turnLeft,`n	["rt"] = turtle.turnRight,`n	["right"] = turtle.turnRight,`n}`n`nlocal nArg = 1`nwhile nArg <= #tArgs do`n	local sDirection = tArgs[nArg]`n	local nDistance = 1`n	if nArg < #tArgs then`n		local num = tonumber( tArgs[nArg + 1] )`n		if num then`n			nDistance = num`n			nArg = nArg + 1`n		end`n	end`n	nArg = nArg + 1`n`n	local fnHandler = tHandlers[string.lower(sDirection)]`n	if fnHandler then`n		while nDistance > 0 do`n			if fnHandler() then`n				nDistance = nDistance - 1`n			elseif turtle.getFuelLevel() == 0 then`n				print( "Out of fuel" )`n				return`n			else`n				sleep(0.5)`n			end`n		end`n	else`n		print( "No such direction: "..sDirection )`n		print( "Try: forward, back, up, down" )`n		return`n	end`n`nend`n`n/rom/programs/turtle/refuel/@/`nlocal tArgs = { ... }`nlocal nLimit = 1`nif #tArgs > 1 then`n	print( "Usage: refuel [number]" )`n	return`nelseif #tArgs > 0 then`n	if tArgs[1] == "all" then`n		nLimit = 64 * 16`n	else`n		nLimit = tonumber( tArgs[1] )`n	end`nend`n`nif turtle.getFuelLevel() ~= "unlimited" then`n	for n=1,16 do`n		local nCount = turtle.getItemCount(n)`n		if nLimit > 0 and nCount > 0 and turtle.getFuelLevel() < turtle.getFuelLimit() then`n		    local nBurn = math.min( nLimit, nCount )`n			turtle.select( n )`n			if turtle.refuel( nBurn ) then`n			    local nNewCount = turtle.getItemCount(n)`n    			nLimit = nLimit - (nCount - nNewCount)`n    		end`n		end`n	end`n    print( "Fuel level is "..turtle.getFuelLevel() )`n    if turtle.getFuelLevel() == turtle.getFuelLimit() then`n        print( "Fuel limit reached" )`n    end`nelse`n    print( "Fuel level is unlimited" )`nend`n`n/rom/programs/turtle/tunnel/@/`nlocal tArgs = { ... }`nif #tArgs ~= 1 then`n	print( "Usage: tunnel <length>" )`n	return`nend`n`n-- Mine in a quarry pattern until we hit something we can't dig`nlocal length = tonumber( tArgs[1] )`nif length < 1 then`n	print( "Tunnel length must be positive" )`n	return`nend`n	`nlocal depth = 0`nlocal collected = 0`n`nlocal function collect()`n	collected = collected + 1`n	if math.fmod(collected, 25) == 0 then`n		print( "Mined "..collected.." items." )`n	end`nend`n`nlocal function tryDig()`n	while turtle.detect() do`n		if turtle.dig() then`n			collect()`n			sleep(0.5)`n		else`n			return false`n		end`n	end`n	return true`nend`n`nlocal function tryDigUp()`n	while turtle.detectUp() do`n		if turtle.digUp() then`n			collect()`n			sleep(0.5)`n		else`n			return false`n		end`n	end`n	return true`nend`n`nlocal function tryDigDown()`n	while turtle.detectDown() do`n		if turtle.digDown() then`n			collect()`n			sleep(0.5)`n		else`n			return false`n		end`n	end`n	return true`nend`n`nlocal function refuel()`n	local fuelLevel = turtle.getFuelLevel()`n	if fuelLevel == "unlimited" or fuelLevel > 0 then`n		return`n	end`n	`n	local function tryRefuel()`n		for n=1,16 do`n			if turtle.getItemCount(n) > 0 then`n				turtle.select(n)`n				if turtle.refuel(1) then`n					turtle.select(1)`n					return true`n				end`n			end`n		end`n		turtle.select(1)`n		return false`n	end`n	`n	if not tryRefuel() then`n		print( "Add more fuel to continue." )`n		while not tryRefuel() do`n			os.pullEvent( "turtle_inventory" )`n		end`n		print( "Resuming Tunnel." )`n	end`nend`n`nlocal function tryUp()`n	refuel()`n	while not turtle.up() do`n		if turtle.detectUp() then`n			if not tryDigUp() then`n				return false`n			end`n		elseif turtle.attackUp() then`n			collect()`n		else`n			sleep( 0.5 )`n		end`n	end`n	return true`nend`n`nlocal function tryDown()`n	refuel()`n	while not turtle.down() do`n		if turtle.detectDown() then`n			if not tryDigDown() then`n				return false`n			end`n		elseif turtle.attackDown() then`n			collect()`n		else`n			sleep( 0.5 )`n		end`n	end`n	return true`nend`n`nlocal function tryForward()`n	refuel()`n	while not turtle.forward() do`n		if turtle.detect() then`n			if not tryDig() then`n				return false`n			end`n		elseif turtle.attack() then`n			collect()`n		else`n			sleep( 0.5 )`n		end`n	end`n	return true`nend`n`nprint( "Tunnelling..." )`n`nfor n=1,length do`n	turtle.placeDown()`n	tryDigUp()`n	turtle.turnLeft()`n	tryDig()`n	tryUp()`n	tryDig()`n	turtle.turnRight()`n	turtle.turnRight()`n	tryDig()`n	tryDown()`n	tryDig()`n	turtle.turnLeft()`n	`n	if n<length then`n		tryDig()`n		if not tryForward() then`n			print( "Aborting Tunnel." )`n			break`n		end`n	else`n		print( "Tunnel complete." )`n	end`n`nend`n`n--[[`nprint( "Returning to start..." )`n`n-- Return to where we started`nturtle.turnLeft()`nturtle.turnLeft()`nwhile depth > 0 do`n	if turtle.forward() then`n		depth = depth - 1`n	else`n		turtle.dig()`n	end`nend`nturtle.turnRight()`nturtle.turnRight()`n]]`n`nprint( "Tunnel complete." )`nprint( "Mined "..collected.." items total." )`n`n/rom/programs/turtle/turn/@/local tArgs = { ... }`nif #tArgs < 1 then`n	print( "Usage: turn <direction> <turns>" )`n	return`nend`n`nlocal tHandlers = {`n	["lt"] = turtle.turnLeft,`n	["left"] = turtle.turnLeft,`n	["rt"] = turtle.turnRight,`n	["right"] = turtle.turnRight,`n}`n`nlocal nArg = 1`nwhile nArg <= #tArgs do`n	local sDirection = tArgs[nArg]`n	local nDistance = 1`n	if nArg < #tArgs then`n		local num = tonumber( tArgs[nArg + 1] )`n		if num then`n			nDistance = num`n			nArg = nArg + 1`n		end`n	end`n	nArg = nArg + 1`n`n	local fnHandler = tHandlers[string.lower(sDirection)]`n	if fnHandler then`n		for n=1,nDistance do`n			fnHandler( nArg )`n		end`n	else`n		print( "No such direction: "..sDirection )`n		print( "Try: left, right" )`n		return`n	end`n	`nend`n`n/rom/programs/turtle/unequip/@/`nlocal tArgs = { ... }`nlocal function printUsage()`n	print( "Usage: unequip <side>" )`nend`n`nif #tArgs ~= 1 then`n    printUsage()`n	return`nend`n`nlocal function unequip( fnEquipFunction )`n    for nSlot=1,16 do`n        local nOldCount = turtle.getItemCount( nSlot )`n        if nOldCount == 0 then`n            turtle.select( nSlot )`n            if fnEquipFunction() then`n                local nNewCount = turtle.getItemCount( nSlot )`n                if nNewCount > 0 then`n                    print( "Item unequipped" )`n                    return`n                else`n                    print( "Nothing to unequip" )`n                    return`n                end`n            end`n        end`n    end`n    print( "No space to unequip item" )`nend`n`nlocal sSide = tArgs[1]`nif sSide == "left" then`n    unequip( turtle.equipLeft )`nelseif sSide == "right" then`n    unequip( turtle.equipRight )`nelse`n    printUsage()`n    return`nend`n/rom/programs/turtle`n/rom/programs`n/rom