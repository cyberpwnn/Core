-- Setup pathslocal sPath = ".:/rom/programs"if term.isColor() then	sPath = sPath..":/rom/programs/advanced"endif turtle then	sPath = sPath..":/rom/programs/turtle"else    sPath = sPath..":/rom/programs/rednet:/rom/programs/fun"    if term.isColor() then    	sPath = sPath..":/rom/programs/fun/advanced"    endendif pocket then    sPath = sPath..":/rom/programs/pocket"endif http then	sPath = sPath..":/rom/programs/http"endshell.setPath( sPath )help.setPath( "/rom/help" )-- Setup aliasesshell.setAlias( "ls", "list" )shell.setAlias( "dir", "list" )shell.setAlias( "cp", "copy" )shell.setAlias( "mv", "move" )shell.setAlias( "rm", "delete" )shell.setAlias( "clr", "clear" )shell.setAlias( "rs", "redstone" )shell.setAlias( "sh", "shell" )if term.isColor() then    shell.setAlias( "background", "bg" )    shell.setAlias( "foreground", "fg" )end-- Run autorun filesif fs.exists( "/rom/autorun" ) and fs.isDir( "/rom/autorun" ) then	local tFiles = fs.list( "/rom/autorun" )	table.sort( tFiles )	for n, sFile in ipairs( tFiles ) do		if string.sub( sFile, 1, 1 ) ~= "." then			local sPath = "/rom/autorun/"..sFile			if not fs.isDir( sPath ) then				shell.run( sPath )			end		end	endend-- Run the user created startup, either from disk drives or the rootlocal sUserStartup = shell.resolveProgram( "/startup" )for n,sName in pairs( peripheral.getNames() ) do    if disk.isPresent( sName ) and disk.hasData( sName ) then        local sDiskStartup = shell.resolveProgram( "/" .. disk.getMountPath( sName ) .. "/startup" )        if sDiskStartup then            sUserStartup = sDiskStartup            break        end    endendif sUserStartup then    shell.run( sUserStartup )end`n-- Colorswhite = 1orange = 2magenta = 4lightBlue = 8yellow = 16lime = 32pink = 64gray = 128lightGray = 256cyan = 512purple = 1024blue = 2048brown = 4096green = 8192red = 16384black = 32768function combine( ... )    local r = 0    for n,c in ipairs( { ... } ) do        r = bit.bor(r,c)    end    return rendfunction subtract( colors, ... )	local r = colors	for n,c in ipairs( { ... } ) do		r = bit.band(r, bit.bnot(c))	end	return rendfunction test( colors, color )    return ((bit.band(colors, color)) == color)end`n-- Colours (for lovers of british spelling)local fnFile, err = loadfile("/rom/apis/colors")if not fnFile then	error( err )endlocal tColors = {}setmetatable( tColors, { __index = _G } )setfenv( fnFile, tColors )fnFile( tColors )local tColours = getfenv()for k,v in pairs( tColors ) do	tColours[k] = vendtColours.gray = niltColours.grey = tColors.graytColours.lightGray = niltColours.lightGrey = tColors.lightGray`nlocal function isDrive( name )	return peripheral.getType( name ) == "drive"endfunction isPresent( name )	if isDrive( name ) then		return peripheral.call( name, "isDiskPresent" )	end	return falseendfunction getLabel( name )	if isDrive( name ) then		return peripheral.call( name, "getDiskLabel" )	end	return nilendfunction setLabel( name, label )	if isDrive( name ) then		peripheral.call( name, "setDiskLabel", label )	endendfunction hasData( name )	if isDrive( name ) then		return peripheral.call( name, "hasData" )	end	return falseendfunction getMountPath( name )	if isDrive( name ) then		return peripheral.call( name, "getMountPath" )	end	return nilendfunction hasAudio( name )	if isDrive( name ) then		return peripheral.call( name, "hasAudio" )	end	return falseendfunction getAudioTitle( name )	if isDrive( name ) then		return peripheral.call( name, "getAudioTitle" )	end	return nilendfunction playAudio( name )	if isDrive( name ) then		peripheral.call( name, "playAudio" )	endendfunction stopAudio( name )	if not name then		for n,sName in ipairs( peripheral.getNames() ) do			stopAudio( sName )		end	else		if isDrive( name ) then			peripheral.call( name, "stopAudio" )		end	endendfunction eject( name )	if isDrive( name ) then		peripheral.call( name, "ejectDisk" )	endendfunction getID( name )	if isDrive( name ) then		return peripheral.call( name, "getDiskID" )	end	return nilend`nCHANNEL_GPS = 65534local function trilaterate( A, B, C )	local a2b = B.vPosition - A.vPosition	local a2c = C.vPosition - A.vPosition			if math.abs( a2b:normalize():dot( a2c:normalize() ) ) > 0.999 then		return nil	end		local d = a2b:length()	local ex = a2b:normalize( )	local i = ex:dot( a2c )	local ey = (a2c - (ex * i)):normalize()	local j = ey:dot( a2c )	local ez = ex:cross( ey )	local r1 = A.nDistance	local r2 = B.nDistance	local r3 = C.nDistance			local x = (r1*r1 - r2*r2 + d*d) / (2*d)	local y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)			local result = A.vPosition + (ex * x) + (ey * y)	local zSquared = r1*r1 - x*x - y*y	if zSquared > 0 then		local z = math.sqrt( zSquared )		local result1 = result + (ez * z)		local result2 = result - (ez * z)				local rounded1, rounded2 = result1:round( 0.01 ), result2:round( 0.01 )		if rounded1.x ~= rounded2.x or rounded1.y ~= rounded2.y or rounded1.z ~= rounded2.z then			return rounded1, rounded2		else			return rounded1		end	end	return result:round( 0.01 )	endlocal function narrow( p1, p2, fix )	local dist1 = math.abs( (p1 - fix.vPosition):length() - fix.nDistance )	local dist2 = math.abs( (p2 - fix.vPosition):length() - fix.nDistance )		if math.abs(dist1 - dist2) < 0.01 then		return p1, p2	elseif dist1 < dist2 then		return p1:round( 0.01 )	else		return p2:round( 0.01 )	endendfunction locate( _nTimeout, _bDebug )	-- Find a modem	local sModemSide = nil	for n,sSide in ipairs( rs.getSides() ) do		if peripheral.getType( sSide ) == "modem" and peripheral.call( sSide, "isWireless" ) then				sModemSide = sSide			break		end	end	if sModemSide == nil then		if _bDebug then			print( "No wireless modem attached" )		end		return nil	end		if _bDebug then		print( "Finding position..." )	end		-- Open a channel	local modem = peripheral.wrap( sModemSide )	local bCloseChannel = false	if not modem.isOpen( os.getComputerID() ) then		modem.open( os.getComputerID() )		bCloseChannel = true	end		-- Send a ping to listening GPS hosts	modem.transmit( CHANNEL_GPS, os.getComputerID(), "PING" )			-- Wait for the responses	local tFixes = {}	local pos1, pos2 = nil, nil	local timeout = os.startTimer( _nTimeout or 2 )	while true do		local e, p1, p2, p3, p4, p5 = os.pullEvent()		if e == "modem_message" then			-- We received a message from a modem			local sSide, sChannel, sReplyChannel, tMessage, nDistance = p1, p2, p3, p4, p5			if sSide == sModemSide and sChannel == os.getComputerID() and sReplyChannel == CHANNEL_GPS then				-- Received the correct message from the correct modem: use it to determine position				if type(tMessage) == "table" and #tMessage == 3 then					local tFix = { vPosition = vector.new( tMessage[1], tMessage[2], tMessage[3] ), nDistance = nDistance }					if _bDebug then						print( tFix.nDistance.." metres from "..tostring( tFix.vPosition ) )					end					if tFix.nDistance == 0 then					    pos1, pos2 = tFix.vPosition, nil					else                        table.insert( tFixes, tFix )                        if #tFixes >= 3 then                            if not pos1 then                                pos1, pos2 = trilaterate( tFixes[1], tFixes[2], tFixes[#tFixes] )                            else                                pos1, pos2 = narrow( pos1, pos2, tFixes[#tFixes] )                            end                        end                    end					if pos1 and not pos2 then						break					end				end			end					elseif e == "timer" then			-- We received a timeout			local timer = p1			if timer == timeout then				break			end				end 	end		-- Close the channel, if we opened one	if bCloseChannel then		modem.close( os.getComputerID() )	end		-- Return the response	if pos1 and pos2 then		if _bDebug then			print( "Ambiguous position" )			print( "Could be "..pos1.x..","..pos1.y..","..pos1.z.." or "..pos2.x..","..pos2.y..","..pos2.z )		end		return nil	elseif pos1 then		if _bDebug then			print( "Position is "..pos1.x..","..pos1.y..","..pos1.z )		end		return pos1.x, pos1.y, pos1.z	else		if _bDebug then			print( "Could not determine position" )		end		return nil	endend`nlocal sPath = "/rom/help"function path()	return sPathendfunction setPath( _sPath )	sPath = _sPathendfunction lookup( _sTopic ) 	-- Look on the path variable    for sPath in string.gmatch(sPath, "[^:]+") do    	sPath = fs.combine( sPath, _sTopic )    	if fs.exists( sPath ) and not fs.isDir( sPath ) then			return sPath    	end    end		-- Not found	return nilendfunction topics()	local tItems = {}		-- Add topics from the path    for sPath in string.gmatch(sPath, "[^:]+") do		if fs.isDir( sPath ) then			local tList = fs.list( sPath )			for n,sFile in pairs( tList ) do				if string.sub( sFile, 1, 1 ) ~= "." then					if not fs.isDir( fs.combine( sPath, sFile ) ) then						tItems[ sFile ] = true					end				end			end		end    end		-- Sort and return	local tItemList = {}	for sItem, b in pairs( tItems ) do		table.insert( tItemList, sItem )	end	table.sort( tItemList )	return tItemListend`n-- Definition for the IO APIlocal g_defaultInput = {	bFileHandle = true,	bClosed = false,	close = function( self )	end,	read = function( self, _sFormat )		if _sFormat and _sFormat ~= "*l" then			error( "Unsupported format" )		end		return _G.read()	end,	lines = function( self )		return function()			return _G.read()		end	end,}local g_defaultOutput = {	bFileHandle = true,	bClosed = false,	close = function( self )	end,	write = function( self, _sText )		_G.write( _sText )	end,	flush = function( self )	end,}local g_currentInput = g_defaultInputlocal g_currentOutput = g_defaultOutputfunction close( _file )	(_file or g_currentOutput):close()endfunction flush()	g_currentOutput:flush()endfunction input( _arg )	if _G.type( _arg ) == "string" then		g_currentInput = open( _arg, "r" )	elseif _G.type( _arg ) == "table" then		g_currentInput = _arg	elseif _G.type( _arg ) == "nil" then		return g_currentInput	else		error( "Expected file name or file handle" )	endendfunction lines( _sFileName )	if _sFileName then		return open( _sFileName, "r" ):lines()	else		return g_currentInput:lines()	endendfunction open( _sPath, _sMode )	local sMode = _sMode or "r"	local file = fs.open( _sPath, sMode )	if not file then		return nil	end		if sMode == "r"then		return {			bFileHandle = true,			bClosed = false,							close = function( self )				file.close()				self.bClosed = true			end,			read = function( self, _sFormat )				local sFormat = _sFormat or "*l"				if sFormat == "*l" then					return file.readLine()				elseif sFormat == "*a" then					return file.readAll()				else					error( "Unsupported format" )				end				return nil			end,			lines = function( self )				return function()					local sLine = file.readLine()					if sLine == nil then						file.close()						self.bClosed = true					end					return sLine				end			end,		}	elseif sMode == "w" or sMode == "a" then		return {			bFileHandle = true,			bClosed = false,							close = function( self )				file.close()				self.bClosed = true			end,			write = function( self, _sText )				file.write( _sText )			end,			flush = function( self )				file.flush()			end,		}		elseif sMode == "rb" then		return {			bFileHandle = true,			bClosed = false,							close = function( self )				file.close()				self.bClosed = true			end,			read = function( self )				return file.read()			end,		}			elseif sMode == "wb" or sMode == "ab" then		return {			bFileHandle = true,			bClosed = false,							close = function( self )				file.close()				self.bClosed = true			end,			write = function( self, _number )				file.write( _number )			end,			flush = function( self )				file.flush()			end,		}		else		file.close()		error( "Unsupported mode" )			endendfunction output( _arg )	if _G.type( _arg ) == "string" then		g_currentOutput = open( _arg, "w" )	elseif _G.type( _arg ) == "table" then		g_currentOutput = _arg	elseif _G.type( _arg ) == "nil" then		return g_currentOutput	else		error( "Expected file name or file handle" )	endendfunction read( ... )	return input():read( ... )endfunction type( _handle )	if _G.type( _handle ) == "table" and _handle.bFileHandle == true then		if _handle.bClosed then			return "closed file"		else			return "file"		end	end	return nilendfunction write( ... )	return output():write( ... )end`n-- Minecraft key code bindings-- See http://www.minecraftwiki.net/wiki/Key_codes for more infolocal nothing = 42local tKeys = {	nil,	 	"one", 		"two", 		"three", 	"four",			-- 1	"five", 	"six", 		"seven", 	"eight", 	"nine",			-- 6	"zero", 	"minus", 	"equals", 	"backspace","tab",			-- 11	"q", 		"w", 		"e", 		"r",		"t",			-- 16	"y",		"u",		"i",		"o",		"p",			-- 21	"leftBracket","rightBracket","enter","leftCtrl","a",			-- 26	"s",		"d",		"f",		"g",		"h",			-- 31	"j",		"k",		"l",		"semiColon","apostrophe",	-- 36	"grave",	"leftShift","backslash","z",		"x",			-- 41	"c",		"v",		"b",		"n",		"m",			-- 46	"comma",	"period",	"slash",	"rightShift","multiply",	-- 51	"leftAlt",	"space",	"capsLock",	"f1",		"f2",			-- 56	"f3",		"f4",		"f5",		"f6",		"f7",			-- 61	"f8",		"f9",		"f10",		"numLock",	"scollLock",	-- 66		"numPad7",	"numPad8",	"numPad9",	"numPadSubtract","numPad4",	-- 71	"numPad5",	"numPad6",	"numPadAdd","numPad1",	"numPad2",		-- 76	"numPad3",	"numPad0",	"numPadDecimal",nil,	nil,			-- 81	nil,	 	"f11",		"f12",		nil,		nil,			-- 86	nil,		nil,		nil,		nil,		nil,			-- 91	nil,		nil,		nil,		nil,		"f13",			-- 96	"f14",		"f15",		nil,		nil,		nil,			-- 101	nil,		nil,		nil,		nil,		nil,			-- 106	nil,		"kana",		nil,		nil,		nil,			-- 111	nil,		nil,		nil,		nil,		nil,			-- 116		"convert",	nil,		"noconvert",nil,		"yen",			-- 121	nil,		nil,		nil,		nil,		nil,			-- 126	nil,		nil,		nil,		nil,		nil,			-- 131	nil,		nil,		nil,		nil,		nil,			-- 136	"numPadEquals",nil,		nil,		"cimcumflex","at",			-- 141	"colon",	"underscore","kanji",	"stop",		"ax",			-- 146	nil,		"numPadEnter","rightCtrl",nil,		nil,			-- 151	nil,		nil,		nil,		nil,		nil,			-- 156	nil,		nil,		nil,		nil,		nil,			-- 161	nil,		nil,		nil,		nil,		nil,			-- 166	nil,		nil,		nil,		nil,		nil,			-- 171	nil,		nil,		nil,		"numPadComma",nil,			-- 176	"numPadDivide",nil,		nil,		"rightAlt",	nil,			-- 181	nil,		nil,		nil,		nil,		nil,			-- 186	nil,		nil,		nil,		nil,		nil,			-- 191	nil,		"pause",	nil,		"home",		"up",			-- 196	"pageUp",	nil,		"left",		nil,		"right",		-- 201	nil,		"end",		"down",		"pageDown",	"insert",		-- 206	"delete"														-- 211}local keys = getfenv()for nKey, sKey in pairs( tKeys ) do	keys[sKey] = nKeyendkeys["return"] = keys.enterfunction getName( _nKey )	return tKeys[ _nKey ]end`nlocal function drawPixelInternal( xPos, yPos )    term.setCursorPos( xPos, yPos )    term.write(" ")endlocal tColourLookup = {}for n=1,16 do    tColourLookup[ string.byte( "0123456789abcdef",n,n ) ] = 2^(n-1)endfunction loadImage( sPath )    if type( sPath ) ~= "string" then        error( "Expected path", 2 )    end    local tImage = {}    if fs.exists( sPath ) then        local file = io.open(sPath, "r" )        local sLine = file:read()        while sLine do            local tLine = {}            for x=1,sLine:len() do                tLine[x] = tColourLookup[ string.byte(sLine,x,x) ] or 0            end            table.insert( tImage, tLine )            sLine = file:read()        end        file:close()        return tImage    end    return nilendfunction drawPixel( xPos, yPos, nColour )    if type( xPos ) ~= "number" or type( yPos ) ~= "number" or (nColour ~= nil and type( nColour ) ~= "number") then        error( "Expected x, y, colour", 2 )    end    if nColour then        term.setBackgroundColor( nColour )    end    drawPixelInternal( xPos, yPos )endfunction drawLine( startX, startY, endX, endY, nColour )    if type( startX ) ~= "number" or type( startX ) ~= "number" or       type( endX ) ~= "number" or type( endY ) ~= "number" or       (nColour ~= nil and type( nColour ) ~= "number") then        error( "Expected startX, startY, endX, endY, colour", 2 )    end        startX = math.floor(startX)    startY = math.floor(startY)    endX = math.floor(endX)    endY = math.floor(endY)    if nColour then        term.setBackgroundColor( nColour )    end    if startX == endX and startY == endY then        drawPixelInternal( startX, startY )        return    end        local minX = math.min( startX, endX )    if minX == startX then        minY = startY        maxX = endX        maxY = endY    else        minY = endY        maxX = startX        maxY = startY    end    -- TODO: clip to screen rectangle?            local xDiff = maxX - minX    local yDiff = maxY - minY                if xDiff > math.abs(yDiff) then        local y = minY        local dy = yDiff / xDiff        for x=minX,maxX do            drawPixelInternal( x, math.floor( y + 0.5 ) )            y = y + dy        end    else        local x = minX        local dx = xDiff / yDiff        if maxY >= minY then            for y=minY,maxY do                drawPixelInternal( math.floor( x + 0.5 ), y )                x = x + dx            end        else            for y=minY,maxY,-1 do                drawPixelInternal( math.floor( x + 0.5 ), y )                x = x - dx            end        end    endendfunction drawBox( startX, startY, endX, endY, nColour )    if type( startX ) ~= "number" or type( startX ) ~= "number" or       type( endX ) ~= "number" or type( endY ) ~= "number" or       (nColour ~= nil and type( nColour ) ~= "number") then        error( "Expected startX, startY, endX, endY, colour", 2 )    end    startX = math.floor(startX)    startY = math.floor(startY)    endX = math.floor(endX)    endY = math.floor(endY)    if nColour then        term.setBackgroundColor( nColour )    end    if startX == endX and startY == endY then        drawPixelInternal( startX, startY )        return    end    local minX = math.min( startX, endX )    if minX == startX then        minY = startY        maxX = endX        maxY = endY    else        minY = endY        maxX = startX        maxY = startY    end    for x=minX,maxX do        drawPixelInternal( x, minY )        drawPixelInternal( x, maxY )    end    if (maxY - minY) >= 2 then        for y=(minY+1),(maxY-1) do            drawPixelInternal( minX, y )            drawPixelInternal( maxX, y )        end    endendfunction drawFilledBox( startX, startY, endX, endY, nColour )    if type( startX ) ~= "number" or type( startX ) ~= "number" or       type( endX ) ~= "number" or type( endY ) ~= "number" or       (nColour ~= nil and type( nColour ) ~= "number") then        error( "Expected startX, startY, endX, endY, colour", 2 )    end    startX = math.floor(startX)    startY = math.floor(startY)    endX = math.floor(endX)    endY = math.floor(endY)    if nColour then        term.setBackgroundColor( nColour )    end    if startX == endX and startY == endY then        drawPixelInternal( startX, startY )        return    end    local minX = math.min( startX, endX )    if minX == startX then        minY = startY        maxX = endX        maxY = endY    else        minY = endY        maxX = startX        maxY = startY    end    for x=minX,maxX do        for y=minY,maxY do            drawPixelInternal( x, y )        end    endendfunction drawImage( tImage, xPos, yPos )    if type( tImage ) ~= "table" or type( xPos ) ~= "number" or type( yPos ) ~= "number" then        error( "Expected image, x, y", 2 )    end    for y=1,#tImage do        local tLine = tImage[y]        for x=1,#tLine do            if tLine[x] > 0 then                term.setBackgroundColor( tLine[x] )                drawPixelInternal( x + xPos - 1, y + yPos - 1 )            end        end    endend`nlocal function create( first, ... )	if first ~= nil then	    if type( first ) ~= "function" then    		error( "Expected function, got "..type( first ), 3 )    	end 		return coroutine.create(first), create( ... )    end    return nilendlocal function runUntilLimit( _routines, _limit )    local count = #_routines    local living = count        local tFilters = {}    local eventData = {}    while true do    	for n=1,count do    		local r = _routines[n]    		if r then    			if tFilters[r] == nil or tFilters[r] == eventData[1] or eventData[1] == "terminate" then	    			local ok, param = coroutine.resume( r, unpack(eventData) )					if not ok then						error( param, 0 )					else						tFilters[r] = param					end					if coroutine.status( r ) == "dead" then						_routines[n] = nil						living = living - 1						if living <= _limit then							return n						end					end				end    		end    	end		for n=1,count do    		local r = _routines[n]			if r and coroutine.status( r ) == "dead" then				_routines[n] = nil				living = living - 1				if living <= _limit then					return n				end			end		end    	eventData = { os.pullEventRaw() }    endendfunction waitForAny( ... )    local routines = { create( ... ) }    return runUntilLimit( routines, #routines - 1 )endfunction waitForAll( ... )    local routines = { create( ... ) }	runUntilLimit( routines, 0 )end`nlocal native = peripheralfunction getNames()	local tResults = {}	for n,sSide in ipairs( rs.getSides() ) do		if native.isPresent( sSide ) then			table.insert( tResults, sSide )			if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then				local tRemote = native.call( sSide, "getNamesRemote" )				for n,sName in ipairs( tRemote ) do					table.insert( tResults, sName )				end			end		end	end	return tResultsendfunction isPresent( _sSide )    if type( _sSide ) ~= "string" then        error( "Expected string", 2 )    end	if native.isPresent( _sSide ) then		return true	end	for n,sSide in ipairs( rs.getSides() ) do		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then			if native.call( sSide, "isPresentRemote", _sSide )  then				return true			end		end	end	return falseendfunction getType( _sSide )    if type( _sSide ) ~= "string" then        error( "Expected string", 2 )    end	if native.isPresent( _sSide ) then		return native.getType( _sSide )	end	for n,sSide in ipairs( rs.getSides() ) do		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then			if native.call( sSide, "isPresentRemote", _sSide )  then				return native.call( sSide, "getTypeRemote", _sSide ) 			end		end	end	return nilendfunction getMethods( _sSide )    if type( _sSide ) ~= "string" then        error( "Expected string", 2 )    end	if native.isPresent( _sSide ) then		return native.getMethods( _sSide )	end	for n,sSide in ipairs( rs.getSides() ) do		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then			if native.call( sSide, "isPresentRemote", _sSide )  then				return native.call( sSide, "getMethodsRemote", _sSide ) 			end		end	end	return nilendfunction call( _sSide, _sMethod, ... )    if type( _sSide ) ~= "string" or type( _sMethod ) ~= "string" then        error( "Expected string, string", 2 )    end	if native.isPresent( _sSide ) then		return native.call( _sSide, _sMethod, ... )	end	for n,sSide in ipairs( rs.getSides() ) do		if native.getType( sSide ) == "modem" and not native.call( sSide, "isWireless" ) then			if native.call( sSide, "isPresentRemote", _sSide )  then				return native.call( sSide, "callRemote", _sSide, _sMethod, ... ) 			end		end	end	return nilendfunction wrap( _sSide )    if type( _sSide ) ~= "string"  then        error( "Expected string", 2 )    end	if peripheral.isPresent( _sSide ) then		local tMethods = peripheral.getMethods( _sSide )		local tResult = {}		for n,sMethod in ipairs( tMethods ) do			tResult[sMethod] = function( ... )				return peripheral.call( _sSide, sMethod, ... )			end		end		return tResult	end	return nilendfunction find( sType, fnFilter )    if type( sType ) ~= "string" or (fnFilter ~= nil and type( fnFilter ) ~= "function") then        error( "Expected string, [function]", 2 )    end	local tResults = {}	for n,sName in ipairs( peripheral.getNames() ) do		if peripheral.getType( sName ) == sType then			local wrapped = peripheral.wrap( sName )			if fnFilter == nil or fnFilter( sName, wrapped ) then				table.insert( tResults, wrapped )			end		end	end	return unpack( tResults )end`nCHANNEL_BROADCAST = 65535CHANNEL_REPEAT = 65533local tReceivedMessages = {}local tReceivedMessageTimeouts = {}local tHostnames = {}function open( sModem )	if type( sModem ) ~= "string" then		error( "expected string", 2 )	end	if peripheral.getType( sModem ) ~= "modem" then			error( "No such modem: "..sModem, 2 )	end	peripheral.call( sModem, "open", os.getComputerID() )	peripheral.call( sModem, "open", CHANNEL_BROADCAST )endfunction close( sModem )    if sModem then        -- Close a specific modem        if type( sModem ) ~= "string" then            error( "expected string", 2 )        end        if peripheral.getType( sModem ) ~= "modem" then            error( "No such modem: "..sModem, 2 )        end        peripheral.call( sModem, "close", os.getComputerID() )        peripheral.call( sModem, "close", CHANNEL_BROADCAST )    else        -- Close all modems        for n,sModem in ipairs( peripheral.getNames() ) do            if isOpen( sModem ) then                close( sModem )            end        end    endendfunction isOpen( sModem )    if sModem then        -- Check if a specific modem is open        if type( sModem ) ~= "string" then            error( "expected string", 2 )        end        if peripheral.getType( sModem ) == "modem" then            return peripheral.call( sModem, "isOpen", os.getComputerID() ) and peripheral.call( sModem, "isOpen", CHANNEL_BROADCAST )        end    else        -- Check if any modem is open        for n,sModem in ipairs( peripheral.getNames() ) do            if isOpen( sModem ) then                return true            end        end    end	return falseendfunction send( nRecipient, message, sProtocol )    -- Generate a (probably) unique message ID    -- We could do other things to guarantee uniqueness, but we really don't need to    -- Store it to ensure we don't get our own messages back    local nMessageID = math.random( 1, 2147483647 )    tReceivedMessages[ nMessageID ] = true    tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID    -- Create the message    local nReplyChannel = os.getComputerID()    local tMessage = {        nMessageID = nMessageID,        nRecipient = nRecipient,        message = message,        sProtocol = sProtocol,    }    if nRecipient == os.getComputerID() then        -- Loopback to ourselves        os.queueEvent( "rednet_message", nReplyChannel, message, sProtocol )    else        -- Send on all open modems, to the target and to repeaters        local sent = false        for n,sModem in ipairs( peripheral.getNames() ) do            if isOpen( sModem ) then                peripheral.call( sModem, "transmit", nRecipient, nReplyChannel, tMessage );                peripheral.call( sModem, "transmit", CHANNEL_REPEAT, nReplyChannel, tMessage );                sent = true            end        end    endendfunction broadcast( message, sProtocol )	send( CHANNEL_BROADCAST, message, sProtocol )endfunction receive( sProtocolFilter, nTimeout )    -- The parameters used to be ( nTimeout ), detect this case for backwards compatibility    if type(sProtocolFilter) == "number" and nTimeout == nil then        sProtocolFilter, nTimeout = nil, sProtocolFilter    end    -- Start the timer	local timer = nil	local sFilter = nil	if nTimeout then		timer = os.startTimer( nTimeout )		sFilter = nil	else		sFilter = "rednet_message"	end	-- Wait for events	while true do		local sEvent, p1, p2, p3 = os.pullEvent( sFilter )		if sEvent == "rednet_message" then		    -- Return the first matching rednet_message			local nSenderID, message, sProtocol = p1, p2, p3			if sProtocolFilter == nil or sProtocol == sProtocolFilter then    			return nSenderID, message, sProtocol    	    end		elseif sEvent == "timer" then		    -- Return nil if we timeout		    if p1 == timer then    			return nil    		end		end	endendfunction host( sProtocol, sHostname )    if type( sProtocol ) ~= "string" or type( sHostname ) ~= "string" then        error( "expected string, string", 2 )    end    if sHostname == "localhost" then        error( "Reserved hostname", 2 )    end    if tHostnames[ sProtocol ] ~= sHostname then        if lookup( sProtocol, sHostname ) ~= nil then            error( "Hostname in use", 2 )        end        tHostnames[ sProtocol ] = sHostname    endendfunction unhost( sProtocol )    if type( sProtocol ) ~= "string" then        error( "expected string", 2 )    end    tHostnames[ sProtocol ] = nilendfunction lookup( sProtocol, sHostname )    if type( sProtocol ) ~= "string" then        error( "expected string", 2 )    end    -- Build list of host IDs    local tResults = nil    if sHostname == nil then        tResults = {}    end    -- Check localhost first    if tHostnames[ sProtocol ] then        if sHostname == nil then            table.insert( tResults, os.getComputerID() )        elseif sHostname == "localhost" or sHostname == tHostnames[ sProtocol ] then            return os.getComputerID()        end    end    if not isOpen() then        if tResults then            return unpack( tResults )        end        return nil    end    -- Broadcast a lookup packet    broadcast( {        sType = "lookup",        sProtocol = sProtocol,        sHostname = sHostname,    }, "dns" )    -- Start a timer    local timer = os.startTimer( 2 )    -- Wait for events    while true do        local event, p1, p2, p3 = os.pullEvent()        if event == "rednet_message" then            -- Got a rednet message, check if it's the response to our request            local nSenderID, tMessage, sMessageProtocol = p1, p2, p3            if sMessageProtocol == "dns" and tMessage.sType == "lookup response" then                if tMessage.sProtocol == sProtocol then                    if sHostname == nil then                        table.insert( tResults, nSenderID )                    elseif tMessage.sHostname == sHostname then                        return nSenderID                    end                end            end        else            -- Got a timer event, check it's the end of our timeout            if p1 == timer then                break            end        end    end    if tResults then        return unpack( tResults )    end    return nilendlocal bRunning = falsefunction run()	if bRunning then		error( "rednet is already running", 2 )	end	bRunning = true		while bRunning do		local sEvent, p1, p2, p3, p4 = os.pullEventRaw()		if sEvent == "modem_message" then			-- Got a modem message, process it and add it to the rednet event queue    		local sModem, nChannel, nReplyChannel, tMessage = p1, p2, p3, p4		    if isOpen( sModem ) and ( nChannel == os.getComputerID() or nChannel == CHANNEL_BROADCAST ) then    			if type( tMessage ) == "table" and tMessage.nMessageID then	    			if not tReceivedMessages[ tMessage.nMessageID ] then		    			tReceivedMessages[ tMessage.nMessageID ] = true                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID			    		os.queueEvent( "rednet_message", nReplyChannel, tMessage.message, tMessage.sProtocol )				    end			    end			end		elseif sEvent == "rednet_message" then		    -- Got a rednet message (queued from above), respond to dns lookup		    local nSenderID, tMessage, sProtocol = p1, p2, p3		    if sProtocol == "dns" and tMessage.sType == "lookup" then		        local sHostname = tHostnames[ tMessage.sProtocol ]		        if sHostname ~= nil and (tMessage.sHostname == nil or tMessage.sHostname == sHostname) then		            rednet.send( nSenderID, {		                sType = "lookup response",		                sHostname = sHostname,		                sProtocol = tMessage.sProtocol,		            }, "dns" )		        end		    end		elseif sEvent == "timer" then            -- Got a timer event, use it to clear the event queue            local nTimer = p1            local nMessage = tReceivedMessageTimeouts[ nTimer ]            if nMessage then                tReceivedMessageTimeouts[ nTimer ] = nil                tReceivedMessages[ nMessage ] = nil            end		end	endend`nlocal native = (term.native and term.native()) or termlocal redirectTarget = nativelocal function wrap( _sFunction )	return function( ... )		return redirectTarget[ _sFunction ]( ... )	endendlocal term = {}term.redirect = function( target )	if target == nil or type( target ) ~= "table" then		error( "Invalid redirect target", 2 )	end    if target == term then        error( "term is not a recommended redirect target, try term.current() instead", 2 )    end	for k,v in pairs( native ) do		if type( k ) == "string" and type( v ) == "function" then			if type( target[k] ) ~= "function" then				target[k] = function()					error( "Redirect object is missing method "..k..".", 2 )				end			end		end	end	local oldRedirectTarget = redirectTarget	redirectTarget = target	return oldRedirectTargetendterm.current = function()    return redirectTargetendterm.native = function()    -- NOTE: please don't use this function unless you have to.    -- If you're running in a redirected or multitasked enviorment, term.native() will NOT be    -- the current terminal when your program starts up. It is far better to use term.current()    return nativeendfor k,v in pairs( native ) do	if type( k ) == "string" and type( v ) == "function" then		if term[k] == nil then			term[k] = wrap( k )		end	endend	local env = getfenv()for k,v in pairs( term ) do	env[k] = vend`nfunction slowWrite( sText, nRate )    nRate = nRate or 20    if nRate < 0 then        error( "Rate must be positive", 2 )    end    local nSleep = 1 / nRate            sText = tostring( sText )    local x,y = term.getCursorPos(x,y)    local len = string.len( sText )        for n=1,len do        term.setCursorPos( x, y )        sleep( nSleep )        local nLines = write( string.sub( sText, 1, n ) )        local newX, newY = term.getCursorPos()        y = newY - nLines    endendfunction slowPrint( sText, nRate )    slowWrite( sText, nRate)    print()endfunction formatTime( nTime, bTwentyFourHour )    local sTOD = nil    if not bTwentyFourHour then        if nTime >= 12 then            sTOD = "PM"        else            sTOD = "AM"        end        if nTime >= 13 then            nTime = nTime - 12        end    end    local nHour = math.floor(nTime)    local nMinute = math.floor((nTime - nHour)*60)    if sTOD then        return string.format( "%d:%02d %s", nHour, nMinute, sTOD )    else        return string.format( "%d:%02d", nHour, nMinute )    endendlocal function makePagedScroll( _term, _nFreeLines )    local nativeScroll = _term.scroll    local nFreeLines = _nFreeLines or 0    return function( _n )        for n=1,_n do            nativeScroll( 1 )                        if nFreeLines <= 0 then                local w,h = _term.getSize()                _term.setCursorPos( 1, h )                _term.write( "Press any key to continue" )                os.pullEvent( "key" )                _term.clearLine()                _term.setCursorPos( 1, h )            else                nFreeLines = nFreeLines - 1            end        end    endendfunction pagedPrint( _sText, _nFreeLines )    -- Setup a redirector    local oldTerm = term.current()    local newTerm = {}    for k,v in pairs( oldTerm ) do        newTerm[k] = v    end    newTerm.scroll = makePagedScroll( oldTerm, _nFreeLines )    term.redirect( newTerm )    -- Print the text    local result    local ok, err = pcall( function()        result = print( _sText )    end )    -- Removed the redirector    term.redirect( oldTerm )    -- Propogate errors    if not ok then        error( err, 0 )    end    return resultendlocal function tabulateCommon( bPaged, ... )    local tAll = { ... }        local w,h = term.getSize()    local nMaxLen = w / 8    for n, t in ipairs( tAll ) do        if type(t) == "table" then            for n, sItem in pairs(t) do                nMaxLen = math.max( string.len( sItem ) + 1, nMaxLen )            end        end    end    local nCols = math.floor( w / nMaxLen )    local nLines = 0    local function newLine()        if bPaged and nLines >= (h-3) then            pagedPrint()        else            print()        end        nLines = nLines + 1    end        local function drawCols( _t )        local nCol = 1        for n, s in ipairs( _t ) do            if nCol > nCols then                nCol = 1                newLine()            end            local cx, cy = term.getCursorPos()            cx = 1 + ((nCol - 1) * nMaxLen)            term.setCursorPos( cx, cy )            term.write( s )            nCol = nCol + 1              end        print()    end    for n, t in ipairs( tAll ) do        if type(t) == "table" then            if #t > 0 then                drawCols( t )            end        elseif type(t) == "number" then            term.setTextColor( t )        end    end    endfunction tabulate( ... )    tabulateCommon( false, ... )endfunction pagedTabulate( ... )    tabulateCommon( true, ... )endlocal function serializeImpl( t, tTracking, sIndent )    local sType = type(t)    if sType == "table" then        if tTracking[t] ~= nil then            error( "Cannot serialize table with recursive entries", 0 )        end        tTracking[t] = true        if next(t) == nil then            -- Empty tables are simple            return "{}"        else            -- Other tables take more work            local sResult = "{\n"            local sSubIndent = sIndent .. "  "            local tSeen = {}            for k,v in ipairs(t) do                tSeen[k] = true                sResult = sResult .. sSubIndent .. serializeImpl( v, tTracking, sSubIndent ) .. ",\n"            end            for k,v in pairs(t) do                if not tSeen[k] then                    local sEntry                    if type(k) == "string" and string.match( k, "^[%a_][%a%d_]*$" ) then                        sEntry = k .. " = " .. serializeImpl( v, tTracking, sSubIndent ) .. ",\n"                    else                        sEntry = "[ " .. serializeImpl( k, tTracking, sSubIndent ) .. " ] = " .. serializeImpl( v, tTracking, sSubIndent ) .. ",\n"                    end                    sResult = sResult .. sSubIndent .. sEntry                end            end            sResult = sResult .. sIndent .. "}"            return sResult        end            elseif sType == "string" then        return string.format( "%q", t )        elseif sType == "number" or sType == "boolean" or sType == "nil" then        return tostring(t)            else        error( "Cannot serialize type "..sType, 0 )            endendfunction serialize( t )    local tTracking = {}    return serializeImpl( t, tTracking, "" )endfunction unserialize( s )    local func = loadstring( "return "..s, "unserialize" )    if func then        setfenv( func, {} )        local ok, result = pcall( func )        if ok then            return result        end    end    return nilendfunction urlEncode( str )    if str then        str = string.gsub(str, "\n", "\r\n")        str = string.gsub(str, "([^%w ])", function(c)            return string.format("%%%02X", string.byte(c))        end )        str = string.gsub(str, " ", "+")    end    return str    end-- GB versionsserialise = serializeunserialise = unserialize`nlocal vector = {	add = function( self, o )		return vector.new(			self.x + o.x,			self.y + o.y,			self.z + o.z		)	end,	sub = function( self, o )		return vector.new(			self.x - o.x,			self.y - o.y,			self.z - o.z		)	end,	mul = function( self, m )		return vector.new(			self.x * m,			self.y * m,			self.z * m		)	end,	dot = function( self, o )		return self.x*o.x + self.y*o.y + self.z*o.z	end,	cross = function( self, o )		return vector.new(			self.y*o.z - self.z*o.y,			self.z*o.x - self.x*o.z,			self.x*o.y - self.y*o.x		)	end,	length = function( self )		return math.sqrt( self.x*self.x + self.y*self.y + self.z*self.z )	end,	normalize = function( self )		return self:mul( 1 / self:length() )	end,	round = function( self, nTolerance )	    nTolerance = nTolerance or 1.0		return vector.new(			math.floor( (self.x + (nTolerance * 0.5)) / nTolerance ) * nTolerance,			math.floor( (self.y + (nTolerance * 0.5)) / nTolerance ) * nTolerance,			math.floor( (self.z + (nTolerance * 0.5)) / nTolerance ) * nTolerance		)	end,	tostring = function( self )		return self.x..","..self.y..","..self.z	end,}local vmetatable = {	__index = vector,	__add = vector.add,	__sub = vector.sub,	__mul = vector.mul,	__unm = function( v ) return v:mul(-1) end,	__tostring = vector.tostring,}function new( x, y, z )	local v = {		x = x or 0,		y = y or 0,		z = z or 0	}	setmetatable( v, vmetatable )	return vend`nfunction create( parent, nX, nY, nWidth, nHeight, bStartVisible )    if type( parent ) ~= "table" or       type( nX ) ~= "number" or       type( nY ) ~= "number" or       type( nWidth ) ~= "number" or       type( nHeight ) ~= "number" or       (bStartVisible ~= nil and type( bStartVisible ) ~= "boolean") then        error( "Expected object, number, number, number, number, [boolean]", 2 )    end    if parent == term then        error( "term is not a recommended window parent, try term.current() instead", 2 )    end    -- Setup    local bVisible = (bStartVisible ~= false)    local nCursorX = 1    local nCursorY = 1    local bCursorBlink = false    local nTextColor = colors.white    local nBackgroundColor = colors.black    local sEmpty = string.rep( " ", nWidth )    local tLines = {}    do        local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }        for y=1,nHeight do            tLines[y] = tEmpty        end    end    -- Helper functions    local function updateCursorPos()        if nCursorX >= 1 and nCursorY >= 1 and           nCursorX <= nWidth and nCursorY <= nHeight then            parent.setCursorPos( nX + nCursorX - 1, nY + nCursorY - 1 )        else            parent.setCursorPos( 0, 0 )        end    end        local function updateCursorBlink()        parent.setCursorBlink( bCursorBlink )    end        local function updateCursorColor()        parent.setTextColor( nTextColor )    end        local function redrawLine( n )        parent.setCursorPos( nX, nY + n - 1 )        local tLine = tLines[ n ]        for m=1,#tLine do            local tBit = tLine[ m ]            parent.setTextColor( tBit[2] )            parent.setBackgroundColor( tBit[3] )            parent.write( tBit[1] )        end    end    local function lineLen( tLine )        local nLength = 0        for n=1,#tLine do            nLength = nLength + string.len( tLine[n][1] )        end        return nLength    end    local function lineSub( tLine, nStart, nEnd )        --assert( math.floor(nStart) == nStart )        --assert( math.floor(nEnd) == nEnd )        --assert( nStart >= 1 )        --assert( nEnd >= nStart )        --assert( nEnd <= lineLen( tLine ) )        local tSubLine = {}        local nBitStart = 1        for n=1,#tLine do            local tBit = tLine[n]            local sBit = tBit[1]            local nBitEnd = nBitStart + string.len( sBit ) - 1            if nBitEnd >= nStart and nBitStart <= nEnd then                if nBitStart >= nStart and nBitEnd <= nEnd then                    -- Include bit wholesale                    table.insert( tSubLine, tBit )                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )                elseif nBitStart < nStart and nBitEnd <= nEnd then                    -- Include end of bit                    table.insert( tSubLine, {                        string.sub( sBit, nStart - nBitStart + 1 ),                        tBit[2], tBit[3]                    } )                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )                elseif nBitStart >= nStart and nBitEnd > nEnd then                    -- Include beginning of bit                    table.insert( tSubLine, {                        string.sub( sBit, 1, nEnd - nBitStart + 1 ),                        tBit[2], tBit[3]                    } )                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )                else                    -- Include middle of bit                    table.insert( tSubLine, {                        string.sub( sBit, nStart - nBitStart + 1, nEnd - nBitStart + 1 ),                        tBit[2], tBit[3]                    } )                    --assert( lineLen( tSubLine ) == (math.min(nEnd, nBitEnd) - nStart + 1) )                end            end            nBitStart = nBitEnd + 1        end        --assert( lineLen( tSubLine ) == (nEnd - nStart + 1) )        return tSubLine    end    local function lineJoin( tLine1, tLine2 )        local tNewLine = {}        if tLine1[#tLine1][2] == tLine2[1][2] and           tLine1[#tLine1][3] == tLine2[1][3] then            -- Merge middle bits            for n=1,#tLine1-1 do                table.insert( tNewLine, tLine1[n] )            end            table.insert( tNewLine, {                tLine1[#tLine1][1] .. tLine2[1][1],                tLine2[1][2], tLine2[1][3]            } )            for n=2,#tLine2 do                table.insert( tNewLine, tLine2[n] )            end            --assert( lineLen( tNewLine ) == lineLen(tLine1) + lineLen(tLine2) )        else            -- Just concatenate            for n=1,#tLine1 do                table.insert( tNewLine, tLine1[n] )            end            for n=1,#tLine2 do                table.insert( tNewLine, tLine2[n] )            end            --assert( lineLen( tNewLine ) == lineLen(tLine1) + lineLen(tLine2) )        end        return tNewLine    end    local function redraw()        for n=1,nHeight do            redrawLine( n )        end    end    local window = {}    -- Terminal implementation    function window.write( sText )        local nLen = string.len( sText )        local nStart = nCursorX        local nEnd = nStart + nLen - 1        if nCursorY >= 1 and nCursorY <= nHeight then            -- Work out where to put new line            --assert( math.floor(nStart) == nStart )            --assert( math.floor(nEnd) == nEnd )            if nStart <= nWidth and nEnd >= 1 then                -- Construct new line                local tLine = tLines[ nCursorY ]                if nStart == 1 and nEnd == nWidth then                    -- Exactly replace line                    tLine = {                        { sText, nTextColor, nBackgroundColor }                    }                    --assert( lineLen( tLine ) == nWidth )                elseif nStart <= 1 and nEnd >= nWidth then                    -- Overwrite line with subset                    tLine = {                        { string.sub( sText, 1 - nStart + 1, nWidth - nStart + 1 ), nTextColor, nBackgroundColor }                    }                    --assert( lineLen( tLine ) == nWidth )                elseif nStart <= 1 then                    -- Overwrite beginning of line                    tLine = lineJoin(                        { { string.sub( sText, 1 - nStart + 1 ), nTextColor, nBackgroundColor } },                        lineSub( tLine, nEnd + 1, nWidth )                    )                    --assert( lineLen( tLine ) == nWidth )                elseif nEnd >= nWidth then                    -- Overwrite end of line                    tLine = lineJoin(                        lineSub( tLine, 1, nStart - 1 ),                        { { string.sub( sText, 1, nWidth - nStart + 1 ), nTextColor, nBackgroundColor } }                    )                    --assert( lineLen( tLine ) == nWidth )                else                    -- Overwrite middle of line                    tLine = lineJoin(                        lineJoin(                            lineSub( tLine, 1, nStart - 1 ),                            { { sText, nTextColor, nBackgroundColor } }                        ),                        lineSub( tLine, nEnd + 1, nWidth )                    )                    --assert( lineLen( tLine ) == nWidth )                end                -- Store and redraw new line                tLines[ nCursorY ] = tLine                if bVisible then                    redrawLine( nCursorY )                end            end        end        -- Move and redraw cursor        nCursorX = nEnd + 1        if bVisible then            updateCursorColor()            updateCursorPos()        end    end    function window.clear()        local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }        for y=1,nHeight do            tLines[y] = tEmpty        end        if bVisible then            redraw()            updateCursorColor()            updateCursorPos()        end    end    function window.clearLine()        if nCursorY >= 1 and nCursorY <= nHeight then            tLines[ nCursorY ] = { { sEmpty, nTextColor, nBackgroundColor } }            if bVisible then                redrawLine( nCursorY )                updateCursorColor()                updateCursorPos()            end        end    end    function window.getCursorPos()        return nCursorX, nCursorY    end    function window.setCursorPos( x, y )        nCursorX = math.floor( x )        nCursorY = math.floor( y )        if bVisible then            updateCursorPos()        end    end    function window.setCursorBlink( blink )        bCursorBlink = blink        if bVisible then            updateCursorBlink()        end    end    function window.isColor()        return parent.isColor()    end    function window.isColour()        return parent.isColor()    end    local function setTextColor( color )        if not parent.isColor() then            if color ~= colors.white and color ~= colors.black then                error( "Colour not supported", 3 )            end        end        nTextColor = color        if bVisible then            updateCursorColor()        end    end    function window.setTextColor( color )        setTextColor( color )    end    function window.setTextColour( color )        setTextColor( color )    end    local function setBackgroundColor( color )        if not parent.isColor() then            if color ~= colors.white and color ~= colors.black then                error( "Colour not supported", 3 )            end        end        nBackgroundColor = color    end    function window.setBackgroundColor( color )        setBackgroundColor( color )    end    function window.setBackgroundColour( color )        setBackgroundColor( color )    end    function window.getSize()        return nWidth, nHeight    end    function window.scroll( n )        if n ~= 0 then            local tNewLines = {}            local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }            for newY=1,nHeight do                local y = newY + n                if y >= 1 and y <= nHeight then                    tNewLines[newY] = tLines[y]                else                    tNewLines[newY] = tEmpty                end            end            tLines = tNewLines            if bVisible then                redraw()                updateCursorColor()                updateCursorPos()            end        end    end    -- Other functions    function window.setVisible( bVis )        if bVisible ~= bVis then            bVisible = bVis            if bVisible then                window.redraw()            end        end    end    function window.redraw()        if bVisible then            redraw()            updateCursorBlink()            updateCursorColor()            updateCursorPos()        end    end    function window.restoreCursor()        if bVisible then            updateCursorBlink()            updateCursorColor()            updateCursorPos()        end    end    function window.getPosition()        return nX, nY    end    function window.reposition( nNewX, nNewY, nNewWidth, nNewHeight )        nX = nNewX        nY = nNewY        if nNewWidth and nNewHeight then            sEmpty = string.rep( " ", nNewWidth )            local tNewLines = {}            local tEmpty = { { sEmpty, nTextColor, nBackgroundColor } }            for y=1,nNewHeight do                if y > nHeight then                    tNewLines[y] = tEmpty                else                    if nNewWidth == nWidth then                        tNewLines[y] = tLines[y]                    elseif nNewWidth < nWidth then                        tNewLines[y] = lineSub( tLines[y], 1, nNewWidth )                    else                        tNewLines[y] = lineJoin( tLines[y], { { string.sub( sEmpty, nWidth + 1, nNewWidth ), nTextColor, nBackgroundColor } } )                    end                end            end            nWidth = nNewWidth            nHeight = nNewHeight            tLines = tNewLines        end        if bVisible then            window.redraw()        end    end    if bVisible then        window.redraw()    end    return windowend`nif not turtle then	error( "Cannot load turtle API on computer", 2 )endnative = turtle.native or turtlelocal function addCraftMethod( object )    if peripheral.getType( "left" ) == "workbench" then        object.craft = function( ... )            return peripheral.call( "left", "craft", ... )        end    elseif peripheral.getType( "right" ) == "workbench" then        object.craft = function( ... )            return peripheral.call( "right", "craft", ... )        end    else        object.craft = nil    endend-- Put commands into environment tablelocal env = getfenv()for k,v in pairs( native ) do    if k == "equipLeft" or k == "equipRight" then        env[k] = function( ... )            local result, err = v( ... )            addCraftMethod( turtle )            return result, err        end    else    	env[k] = v    endendaddCraftMethod( env )`n/rom/apis/turtle`n/rom/apis`n--[[Alright then, don't ignore me. This file is to ensure the existance of the "autorun" folder, files placed in this folderusing resource packs will always run when computers startup.]]`n/rom/autorun`nadventure is a text adventure game for CraftOS. To navigate around the world of adventure, type simple instructions to the interpreter, for example: "go north", "punch tree", "craft planks", "mine coal with pickaxe", "hit creeper with sword"`nalias assigns shell commands to run other programs.ex:"alias dir ls" will make the "dir" command run the "ls" program"alias dir" will remove the alias set on "dir""alias" will list all current aliases.`napis lists the currently loaded APIs available to programs in CraftOS.Type "help <api>" to see help for a specific api.Call os.loadAPI( path ) to load extra apis.`nbg is a program for Advanced Computers which opens a new tab in the background.ex:"bg" will open a background tab running the shell"bg worm" will open a background tab running the "worm" program`nFunctions in the bit manipulation API:bit.bnot(n)          -- bitwise not (~n)bit.band(m, n)       -- bitwise and (m & n)bit.bor(m, n)        -- bitwise or (m | n)bit.bxor(m, n)       -- bitwise xor (m ^ n)bit.brshift(n, bits) -- right shift (n >> bits)bit.blshift(n, bits) -- left shift (n << bits)`nTo set bundled outputs:c = colors.combine( colors.red, colors.blue )rs.setBundledOutput( "left", c )c = colors.combine( c, colors.green )rs.setBundledOutput( "left", c )c = colors.subtract( c, colors.blue )rs.setBundledOutput( "left", c )To get bundled inputs:c = rs.getBundledInput( "right" )red = colors.test( c, colors.red )Type "help colors" for the list of wire colors.`ncd changes the the directory you're in.ex:"cd rom" will move to "rom" folder."cd .." will move up one folder."cd /" will move to the root.`nNew Features in ComputerCraft 1.65:* Fixed a multiplayer-only crash with turtle.place()* Fixed some problems with http.post()* Fixed fs.getDrive() returning incorrect results on remote peripheralsNew Features in ComputerCraft 1.64:* Ported to Minecraft 1.7.10* New turtle functions: turtle.inspect(), turtle.inspectUp(), turtle.inspectDown(), turtle.getItemDetail()* Lots of bug and crash fixes, a huge stability improvement over previous versionsNew Features in ComputerCraft 1.63:* Turtles can now be painted with dyes, and cleaned with water buckets* Added a new game: Redirection - ComputerCraft Edition* Turtle label nameplates now only show when the Turtle is moused-over* The HTTP API is now enabled by default, and can be configured with a whitelist of permitted domains* http.get() and http.post() now accept parameters to control the request headers* New fs function: fs.getDir( path )* Fixed some bugsNew Features in ComputerCraft 1.62:* Added IRC-style commands to the "chat" program* Fixed some bugs and crashesNew Features in ComputerCraft 1.6:* Added Pocket Computers* Added a multi-tasking system for Advanced Computers and Turtles* Turtles can now swap out their tools and peripherals at runtime* Turtles can now carry two tools or peripherals at once in any combination* Turtles and Computers can now be labelled using Name Tags and Anvils* Added a configurable fuel limit for Turtles* Added hostnames, protocols and long distance routing to the rednet API* Added a peer-to-peer chat program to demonstrate new rednet capabilities* Added a new game, only on Pocket Computers: "falling" by GopherATL* File system commands in the shell now accept wildcard arguments* The shell now accepts long arguments in quotes* Terminal redirection now no longer uses a stack-based system. Instead: term.current() gets the current terminal object and term.redirect() replaces it. term.restore() has been removed.* Added a new Windowing API for addressing sub-areas of the terminal* New programs: fg, bg, multishell, chat, repeat, redstone, equip, unequip* Improved programs: copy, move, delete, rename, paint, shell* Removed programs: redset, redprobe, redpulse* New APIs: window, multishell* New turtle functions: turtle.equipLeft() and turtle.equipRight()* New peripheral functions: peripheral.find( [type] )* New rednet functions: rednet.host( protocol, hostname ), rednet.unhost( protocol ), rednet.locate( protocol, [hostname] )* New fs function: fs.find( wildcard )* New shell functions: shell.openTab(), shell.switchTab( [number] )* New event "term_resize" fired when the size of a terminal changes* Improved rednet functions: rednet.send(), rednet.broadcast() and rednet.receive() now take optional protocol parameters* turtle.craft(0) and turtle.refuel(0) now return true if there is a valid recipe or fuel item, but do not craft of refuel anything* turtle.suck( [limit] ) can now be used to limit the number of items picked up* Users of turtle.dig() and turtle.attack() can now specify which side of the turtle to look for a tool to use (by default, both will be considered)* textutils.serialise( text ) now produces human-readable output* Refactored most of the codebase and fixed many old bugs and instabilities, turtles should never ever lose their content now* Fixed the "turtle_inventory" event firing when it shouldn't have* Added error messages to many more turtle functions after they return false* Documented all new programs and API changes in the "help" systemNew Features in ComputerCraft 1.58:* Fixed a long standing bug where turtles could lose their identify if they travel too far away* Fixed use of deprecated code, ensuring mod compatibility with the latest versions of Minecraft Forge, and world compatibility with future versions of MinecraftNew Features in ComputerCraft 1.57:* Ported to Minecraft 1.6.4* Added two new Treasure Disks: Conways Game of Life by vilsol and Protector by fredthead* Fixed a very nasty item duplication bugNew Features in ComputerCraft 1.56:* Added Treasure Disks: Floppy Disks in dungeons which contain interesting community made programs. Find them all!* All turtle functions now return additional error messages when they fail.* Resource Packs with Lua Programs can now be edited when extracted to a folder, for easier editing.New Features in ComputerCraft 1.55:* Ported to Minecraft 1.6.2* Added Advanced Turtles* Added "turtle_inventory" event. Fires when any change is made to the inventory of a turtle* Added missing functions io.close, io.flush, io.input, io.lines, io.output* Tweaked the screen colours used by Advanced Computers, Monitors and Turtles* Added new features for Peripheral authors* Lua programs can now be included in Resource PacksNew Features in ComputerCraft 1.52:* Ported to Minecraft 1.5.1New Features in ComputerCraft 1.51:* Ported to Minecraft 1.5* Added Wired Modems* Added Networking Cables* Made Wireless Modems more expensive to craft* New redstone API functions: getAnalogInput(), setAnalogOutput(), getAnalogOutput()* Peripherals can now be controlled remotely over wired networks. New peripheral API function: getNames()* New event: "monitor_resize" when the size of a monitor changes* Except for labelled computers and turtles, ComputerCraft blocks no longer drop items in creative mode* The pick block function works in creative mode now works for all ComputerCraft blocks* All blocks and items now use the IDs numbers assigned by FTB by default* Fixed turtles sometimes placing blocks with incorrect orientations* Fixed Wireless modems being able to send messages to themselves* Fixed turtle.attack() having a very short range* Various bugfixesNew Features in ComputerCraft 1.5:* Redesigned Wireless Modems; they can now send and receive on multiple channels, independent of the computer ID. To use these features, interface with modem peripherals directly. The rednet API still functions as before* Floppy Disks can now be dyed with multiple dyes, just like armour* The "excavate" program now retains fuel in it's inventory, so can run unattended* turtle.place() now tries all possible block orientations before failing* turtle.refuel(0) returns true if a fuel item is selected* turtle.craft(0) returns true if the inventory is a valid recipe* The in-game help system now has documentation for all the peripherals and their methods, including the new modem functionality* A romantic surpriseNew Features in ComputerCraft 1.48:* Ported to Minecraft 1.4.6* Advanced Monitors now emit a "monitor_touch" event when right clicked* Advanced Monitors are now cheaper to craft* Turtles now get slightly less fuel from items* Computers can now interact with Command Blocks (if enabled in ComputerCraft.cfg)* New API function: os.day()* A christmas surpriseNew Features in ComputerCraft 1.45:* Added Advanced Computers* Added Advanced Monitors* New program: paint by nitrogenfingers* New API: paintutils* New term functions: term.setBackgroundColor, term.setTextColor, term.isColor* New turtle function: turtle.transferToNew Features in ComputerCraft 1.43:* Added Printed Pages* Added Printed Books* Fixed incompatibility with Forge 275 and above* Labelled Turtles now keep their fuel when brokenNew Features in ComputerCraft 1.42:* Ported to Minecraft 1.3.2* Added Printers* Floppy Disks can be dyed different colours* Wireless Crafty Turtles can now be crafted* New textures* New forge config file* Bug fixesNew Features in ComputerCraft 1.4:* Ported to Forge Mod Loader. ComputerCraft can now be ran directly from the .zip without extraction* Added Farming Turtles* Added Felling Turtles* Added Digging Turtles* Added Melee Turtles* Added Crafty Turtles* Added 14 new Turtle Combinations accessible by combining the turtle upgrades above* Labelled computers and turtles can now be crafted into turtles or other turtle types without losing their ID, label and data* Added a "Turtle Upgrade API" for mod developers to create their own tools and peripherals for turtles* Turtles can now attack entities with turtle.attack(), and collect their dropped items* Turtles can now use turtle.place() with any item the player can, and can interact with entities* Turtles can now craft items with turtle.craft()* Turtles can now place items into inventories with turtle.drop()* Changed the behaviour of turtle.place() and turtle.drop() to only consider the currently selected slot* Turtles can now pick up items from the ground, or from inventories, with turtle.suck()* Turtles can now compare items in their inventories* Turtles can place signs with text on them with turtle.place( [signText] )* Turtles now optionally require fuel items to move, and can refuel themselves* The size of the the turtle inventory has been increased to 16* The size of the turtle screen has been increased* New turtle functions: turtle.compareTo( [slotNum] ), turtle.craft(), turtle.attack(), turtle.attackUp(), turtle.attackDown(), turtle.dropUp(), turtle.dropDown(), turtle.getFuelLevel(), turtle.refuel()* New disk function: disk.getID()* New turtle programs: craft, refuel* "excavate" program now much smarter: Will return items to a chest when full, attack mobs, and refuel itself automatically* New API: keys* Added optional Floppy Disk and Hard Drive space limits for computers and turtles* New fs function: fs.getFreeSpace( path ), also fs.getDrive() works again* The send and receive range of wireless modems now increases with altitude, allowing long range networking from high-altitude computers (great for GPS networks)* http.request() now supports https:// URLs* Right clicking a Disk Drive with a Floppy Disk or a Record when sneaking will insert the item into the Disk Drive automatically* The default size of the computer screen has been increased* Several stability and security fixes. LuaJ can now no longer leave dangling threads when a computer is unloaded, turtles can no longer be destroyed by tree leaves or walking off the edge of the loaded map. Computers no longer crash when used with RedPower frames.New Features in ComputerCraft 1.31:* Ported to Minecraft 1.2.3* Added Monitors (thanks to Cloudy)* Updated LuaJ to a newer, less memory hungry version* rednet_message event now has a third parameter, "distance", to support position triangulation.* New programs: gps, monitor, pastebin.* Added a secret program. Use with large monitors!* New apis: gps, vector* New turtle functions: turtle.compare(), turtle.compareUp(), turtle.compareDown(), turtle.drop( quantity )* New http functions: http.post().* New term functions: term.redirect(), term.restore()* New textutils functions: textutils.urlEncode()* New rednet functions: rednet.isOpen()* New config options: modem_range, modem_rangeDuringStorm* Bug fixes, program tweaks, and help updatesNew Features in ComputerCraft 1.3:* Ported to Minecraft Forge* Added Turtles* Added Wireless Modems* Added Mining Turtles* Added Wireless Turtles* Added Wireless Mining Turtles* Computers and Disk Drives no longer get destroyed by water.* Computers and Turtles can now be labelled with the label program, and labelled devices keep their state when destroyed.* Computers/Turtles can connect to adjacent devices, and turn them on and off* User programs now give line numbers in their error messages* New APIs: turtle, peripheral* New programs for turtles: tunnel, excavate, go, turn, dance* New os functions: os.getComputerLabel(), os.setComputerLabel()* Added "filter" parameter to os.pullEvent()* New shell function: shell.getCurrentProgram()* New textutils functions: textutils.serialize(), textutils.unserialize(), textutils.tabulate(), textutils.pagedTabulate(), textutils.slowWrite()* New io file function: file:lines()* New fs function: fs.getSize()* Disk Drives can now play records from other mods* Bug fixes, program tweaks, and help updatesNew Features in ComputerCraft 1.2:* Added Disk Drives and Floppy Disks* Added Ctrl+T shortcut to terminate the current program (hold)* Added Ctrl+S shortcut to shutdown the computer (hold)* Added Ctrl+R shortcut to reboot the computer (hold)* New Programs: alias, apis, copy, delete, dj, drive, eject, id, label, list, move, reboot, redset, rename, time, worm.* New APIs: bit, colours, disk, help, rednet, parallel, textutils.* New color functions: colors.combine(), colors.subtract(), colors.test()* New fs functions: fs.getName(), new modes for fs.open()* New os functions: os.loadAPI(), os.unloadAPI(),os.clock(), os.time(), os.setAlarm(),os.reboot(), os.queueEvent()* New redstone function: redstone.getSides()* New shell functions: shell.setPath(), shell.programs(), shell.resolveProgram(), shell.setAlias()* Lots of updates to the help pages* Bug fixesNew Features in ComputerCraft 1.1:* Added Multiplayer support throughout.* Added connectivity with RedPower bundled cables* Added HTTP api, enabled via the mod config, to allow computers to access the real world internet* Added command history to the shell.* Programs which spin in an infinite loop without yielding will no longer freeze minecraft* Help updates and bug fixesNew Features in ComputerCraft 1.0:* First Release!`nSurf the rednet superhighway with "chat", the networked chat program for CraftOS! Host chatrooms and invite your friends! Requires a Wired or Wireless Modem on each computer. When running chat, type "/help" to see a list of available commands.ex:"chat host forgecraft" will create a chatroom with the name "forgecraft""chat join forgecraft direwolf20" will connect to the chatroom with the name "forgecraft", using the nickname "direwolf20"`nclear clears the screen.`nFunctions in the colors api(used for redstone.setBundledOutput):colors.combine( color1, color2, color3, ... )colors.subtract( colors, color1, color2, ... )colors.test( colors, color )Color constants in the colors api, in ascending bit order:colors.white, colors.orange, colors.magenta, colors.lightBlue, colors.yellow, colors.lime, colors.pink, colors.gray, colors.lightGray, colors.cyan, colors.purple, colors.blue, colors.brown, colors.green, colors.red, colors.black.`nFunctions in the colours api(used for redstone.setBundledOutput):colours.combine( colour1, colour2, colour3, ...)colours.subtract( colours, colour1, colour2, ...)colours.test( colours, colour )Colour constants in the colours api, in ascending bit order:colours.white, colours.orange, colours.magenta, colours.lightBlue, colours.yellow, colours.lime, colours.pink, colours.grey, colours.lightGrey, colours.cyan, colours.purple, colours.blue, colours.brown, colours.green, colours.red, colours.black.`ncp copies a file or directory from one location to another.ex:"cp rom myrom" copies "rom" to "myrom"."cp rom mystuff/rom" copies "rom" to "mystuff/rom"."cp disk/* disk2" copies the contents of one disk to another`ncoroutine is a standard Lua5.1 API.Refer to http://www.lua.org/manual/5.1/ for more information.`ncraft is a program for Crafty Turtles. Craft will craft a stack of items using the current inventory.ex:"craft" will craft as many items as possible"craft 5" will craft at most 5 times`nComputerCraft was created by Daniel "dan200" Ratcliffe, with additional code by Aaron "Cloudy" Mills.Thanks to nitrogenfingers, GopherATL and RamiLego for program contributions.Thanks to Mojang, the Forge team, and the MCP team.Uses LuaJ from http://luaj.sourceforge.net/Join the ComputerCraft community online at http://www.computercraft.infoFollow @DanTwoHundred on Twitter!`ndance is a program for Turtles. Turtles love to get funky.`nrm deletes a file or a directory and its contents.ex:"rm foo" will delete the file foo."rm disk/*" will delete the contents of a disk.`nFunctions in the disk API. These functions are for interacting with disk drives:disk.isPresent( drive )disk.setLabel( drive, label )disk.getLabel( drive )disk.hasData( drive )disk.getMountPath( drive )disk.hasAudio( drive )disk.getAudioTitle( drive )disk.playAudio( drive )disk.stopAudio( )disk.eject( drive )disk.getID( drive )Events fired by the disk API:"disk" when a disk or other item is inserted into a disk drive. Argument is the name of the drive"disk_eject" when a disk is removed from a disk drive. Argument is the name of the driveType "help events" to learn about the event system.`ndj plays Music Discs from disk drives attached to the computer.ex:"dj" or "dj play" plays a random disc."dj play left" plays the disc in the drive on the left of the computer."dj stop" stops the current disc.`ndrive tells you which disk drive the current or specified directory is located in.ex:"drive" tell you the disk drive of the current directory."drive foo" tells you the disk drive of the subdirectory "foo"`nThe Disk Drive is a peripheral device available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Disk Drive is connected, peripheral.getType() will return "drive".Methods exposed by the Disk Drive:isDiskPresent()getDiskLabel()setDiskLabel( label )hasData()getMountPath()hasAudio()getAudioTitle()playAudio()stopAudio()ejectDisk()getDiskID()Events fired by the Disk Drive:"disk" when a disk or other item is inserted into the drive. Argument is the name of the drive."disk_eject" when a disk is removed from a  drive. Argument is the name of the drive.Type "help events" to learn about the event system.`nMostly harmless.`nedit is a text editor for creating or modifying programs or text files. After creating a program with edit, type its filename in the shell to run it. You can open any of the builtin programs with edit to learn how to program.ex:"edit hello" opens a file called "hello" for editing.`neject ejects the contents of an attached disk drive.ex:"eject left" ejects the contents of the disk drive to the left of the computer.`nequip is a program for Turtles. equip will equip an item from the Turtle's inventory for use as a tool of peripheral.ex:"equip 5 left" will equip the item from slot 5 of the turtle onto the left side of the turtle`nThe function os.pullEvent() will yield the program until a system event occurs. The first return value is the event name, followed by any arguments.Some events which can occur are:"char" when text is typed on the keyboard. Argument is the letter typed."key" when a key is pressed on the keyboard. Argument is the numerical keycode. Compare to the values in keys API to see which key was pressed."paste" when text is pasted from the users keyboard. Argument is the line of text pasted.Events only on advanced computers:"mouse_click" when a user clicks the mouse. Arguments are button, xPos, yPos."mouse_drag" when a user moves the mouse when held. Arguments are button, xPos, yPos."mouse_scroll" when a user uses the scrollwheel on the mouse. Arguments are direction, xPos, yPos.Other APIs and peripherals will emit their own events. See their respective help pages for details.`nexcavate is a program for Mining Turtles. When excavate is run, the turtle will mine a rectangular shaft into the ground, collecting blocks as it goes, and return to the surface once bedrock is hit.ex:"excavate 3" will mine a 3x3 shaft.`nexit will exit the current shell.`n"From Russia with Fun" comes a fun, new, suspiciously-familiar falling block game for CraftOS. Only on Pocket Computers!`nfg is a program for Advanced Computers which opens a new tab in the foreground.ex:"fg" will open a foreground tab running the shell"fg worm" will open a foreground tab running the "worm" program`nFunctions in the Filesystem API:fs.list( path )fs.find( wildcard )fs.exists( path )fs.isDir( path )fs.isReadOnly( path )fs.getDir( path )fs.getName( path )fs.getSize( path )fs.getDrive( path )fs.getFreeSpace( path )fs.makeDir( path )fs.move( path, path )fs.copy( path, path )fs.delete( path )fs.combine( path, localpath )fs.open( path, mode )Available fs.open() modes are "r", "w", "a", "rb", "wb" and "ab".Functions on files opened with mode "r":readLine()readAll()close()Functions on files opened with mode "w" or "a":write( string )writeLine( string )flush()close()Functions on files opened with mode "rb":read()close()Functions on files opened with mode "wb" or "ab":write( byte )flush()close()`ngo is a program for Turtles, used to control the turtle without programming. It accepts one or more commands as a direction followed by a distance.ex:"go forward" moves the turtle 1 space forward."go forward 3" moves the turtle 3 spaces forward."go forward 3 up left 2" moves the turtle 3 spaces forward, 1 spaces up, then left 180 degrees.`ngps can be used to host a GPS server, or to determine a position using trilateration.Type "help gpsapi" for help using GPS functions in lua programs.ex:"gps locate" will connect to nearby GPS servers, and try to determine the position of the computer or turtle."gps host" will try to determine the position, and host a GPS server if successful."gps host 10 20 30" will host a GPS server, using the manually entered position 10,20,30. Take care when manually entering host positions. If the positions entered into multiple GPS hostsare not consistent, the results of locate calls will be incorrect.`nFunctions in the GPS API:gps.locate( timeout )The locate function will send a signal to nearby gps servers, and wait for responses before the timeout. If it receives enough responses to determine this computers position then x, y and z co-ordinates will be returned, otherwise it will return nil. If GPS hosts do not have their positions configured correctly, results will be inaccurate.`nhello prints the text "Hello World!" to the screen.`nhelp is the help tool you're currently using.Type "help index" to see all help topics.Type "help" to see the help intro.Type "help helpapi" for information on the help Lua API.`nFunctions in the help API:help.setPath( path )help.lookup( topic )help.topics()`nFunctions in the HTTP API:http.checkURL( url )http.request( url, [postData], [headers] )http.get( url, [headers] )http.post( url, postData, [headers] )The HTTP API may be disabled in ComputerCraft.cfgA period of time after a http.request() call is made, a "http_success" or "http_failure" event will be raised. Arguments are the url and a file handle if successful. http.get() and http.post() block until this event fires instead.`nid prints the unique identifier of this computer, or a Disk in an attached Disk Drive.ex:"id" will print this Computers ID and label"id left" will print the ID and label of the disk in the Disk Drive on the left`nWelcome to CraftOS!Type "programs" to see the programs you can run.Type "help <program>" to see help for a specific program.Type "help programming" to learn about programming.Type "help whatsnew" to find out about new features.Type "help credits" to learn who made all this.Type "help index" to see all help topics.`nio is a standard Lua5.1 API, reimplemented for CraftOS. Not all the features are availiable.Refer to http://www.lua.org/manual/5.1/ for more information.`nThe keys API contains constants for all the key codes that can be returned by the "key" event:Example usage:local sEvent, nKey = os.pullEvent()if sEvent == "key" and nKey == keys.enter then   -- Do something  endSee http://www.minecraftwiki.net/wiki/Key_codes, or the source code, for a complete reference.`nlabel gets or sets the label of the Computer, or of Floppy Disks in attached disk drives.ex:"label get" prints the label of the computer."label get left" prints the label of the disk in the left drive."label set "My Computer"" set the label of the computer to "My Computer"."label set left "My Programs"" - sets the label of the disk in the left drive to "My Programs"."label clear" clears the label of the computer."label clear left" clears the label of the disk in the left drive.`nls will list all the directories and files in the current location. Use "type" to find out if an item is a file or a directory.`nlua is an interactive prompt for the lua programming language. It's a useful tool for learning the language.`nmath is a standard Lua5.1 API.Refer to http://www.lua.org/manual/5.1/ for more information.`nmkdir creates a directory in the current location.ex:"mkdir foo" creates a directory named "foo"."mkdir ../foo" creates a directory named "foo" in the directory above the current directory.`nWired and Wireless Modems are peripheral devices available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Modem is connected, peripheral.getType() will return "modem".Methods exposed by Modems:open( channel )isOpen( channel )close( channel )closeAll()transmit( channel, replyChannel, message )isWireless()Events fired by Modems:"modem_message" when a message is received on an open channel. Arguments are name, channel, replyChannel, message, distance`nmonitor will connect to an attached Monitor peripheral, and run a program on its display.ex:"monitor left hello" will run the "hello" program on the monitor to the left of the computer."monitor top edit foo" will run the edit program on the top monitor, editing the file "foo".`nThe Monitor is a peripheral device available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Monitor is connected, peripheral.getType() will return "monitor". A wrapped monitor can be used with term.redirect() to send all terminal output to the monitor.Methods exposed by the Monitor:write( text )clear()clearLine()getCursorPos()setCursorPos( x, y )setCursorBlink( blink )isColor()setTextColor( color )setBackgroundColor( color )getSize()scroll( n )Events fired by the Monitor:"monitor_touch" when an Advanced Monitor is touched by the player. Arguments are name, x, y"monitor_resize" when the size of a Monitor changes. Argument is the name of the monitor.`nmv moves a file or directory from one location to another.ex:"mv foo bar" renames the file "foo" to "bar"."mv foo bar/foo" moves the file "foo" to a folder called "bar"."mv disk/* disk2" moves the contents of one disk to another`nmultishell is the toplevel program on Advanced Computers which manages background tabs.Type "help shellapi" for information about the shell lua api.`nFunctions in the os (Operating System) API:os.version()os.getComputerID()os.getComputerLabel()os.setComputerLabel()os.run( environment, programpath, arguments )os.loadAPI( path )os.unloadAPI( name )os.pullEvent( [filter] )os.queueEvent( event, arguments )os.clock()os.startTimer( timeout )os.cancelTimer( token )os.sleep( timeout )os.time()os.day()os.setAlarm( time )os.cancelAlarm( token )os.shutdown()os.reboot()Events emitted by the os API:"timer" when a timeout started by os.startTimer() completes. Argument is the token returned by os.startTimer()."alarm" when a time passed to os.setAlarm() is reached. Argument is the token returned by os.setAlarm().Type "help events" to learn about the event system.`npaint is a program for creating images on Advanced Computers. Select colors from the color pallette on the right, and click on the canvas to draw. Press Ctrl to access the menu and save your pictures.ex:"edit mario" opens an image called "mario" for editing.`nFunctions in the Paint Utilities API:paintutils.drawPixel( x, y, colour )paintutils.drawLine( startX, startY, endX, endY, colour )paintutils.drawBox( startX, startY, endX, endY, colour )paintutils.drawFilledBox( startX, startY, endX, endY, colour )paintutils.loadImage( path )paintutils.drawImage( image, x, y )`nFunctions in the Parallel API:parallel.waitForAny( function1, function2, ... )parallel.waitForAll( function1, function2, ... )These methods provide an easy way to run multiple lua functions simultaneously.`npastebin is a program for uploading files to and downloading files from pastebin.com. This is useful for sharing programs with other players.The HTTP API must be enabled in ComputerCraft.cfg to use this program.ex:"pastebin put foo" will upload the file "foo" to pastebin.com, and print the URL."pastebin get xq5gc7LB foo" will download the file from the URL http://pastebin.com/xq5gc7LB, and save it as "foo"."pastebin run CxaWmPrX" will download the file from the URL http://pastebin.com/CxaWmPrX, and immediately run it.`nThe peripheral API is for interacting with external peripheral devices. Type "help peripherals" to learn about the peripherals available.Functions in the peripheral API:peripheral.getNames()peripheral.isPresent( name )peripheral.getType( name )peripheral.getMethods( name )peripheral.call( name, methodName, param1, param2, etc )peripheral.wrap( name )peripheral.find( type, [fnFilter] )Events fired by the peripheral API:"peripheral" when a new peripheral is attached. Argument is the name."peripheral_detach" when a peripheral is removed. Argument is the name.Type "help events" to learn about the event system.`nPeripherals are external devices which CraftOS Computers and Turtles can interact with using the peripheral API.Type "help peripheral" to learn about using the peripheral API.Type "help drives" to learn about using Disk Drives.Type "help modems" to learn about using Wireless Modems.Type "help monitors" to learn about using Monitors.Type "help printers" to learn about using Printers.`nThe Printer is a peripheral device available for CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a Printer is connected, peripheral.getType() will return "printer".Methods exposed by the Printer:getInkLevel()getPaperLevel()newPage()setPageTitle( title )getPageSize()setCursorPos( x, y )getCursorPos()write( text )endPage()`nTo learn the lua programming language, visit http://lua-users.org/wiki/TutorialDirectory.To experiment with lua in CraftOS, run the "lua" program and start typing code.To create programs, use "edit" to create files, then type their names in the shell to run them. If you name a program "startup" and place it in the root or on a disk drive, it will run automatically when the computer starts.To terminate a program stuck in a loop, hold Ctrl+T for 1 second.To quickly shutdown a computer, hold Ctrl+S for 1 second.To quickly reboot a computer, hold Ctrl+R for 1 second.To learn about the programming APIs availiable, type "apis" or "help apis".If you get stuck, visit the forums at http://www.computercraft.info/ for advice and tutorials.`nprograms lists all the programs on the rom of the computer.`nreboot will turn the computer off and on again.You can also hold Ctrl+R at any time to quickly reboot.`nRedirection ComputerCraft Edition is the CraftOS version of a fun new puzzle game by Dan200, the author of ComputerCraft.Play it on any Advanced Computer, then visit http://www.redirectiongame.com to play the full game!`nThe rednet API provides a simple computer networking model using modems.Functions in the rednet API:rednet.open( side )rednet.close( [side] )rednet.isOpen( [side] )rednet.send( receiverID, message, [protocol] ) -- Send to a specific computerrednet.broadcast( message, [protocol] ) -- Send to all computersrednet.receive( [protocol], [timeout] ) -- Returns: senderID, message, protocolrednet.host( protocol, hostname )rednet.unhost( protocol )rednet.lookup( protocol, [hostname] ) -- Returns: IDEvents fired by the rednet API:"rednet_message" when a message is received. Arguments are senderID, message, protocolType "help events" to learn about the event system.Rednet is not the only way to use modems for networking. Interfacing with the modem directly using the peripheral API and listening for the "modem_message" event allows for lower level control, at the expense of powerful high level networking features.`nThe redstone program can be used to get, set or pulse redstone inputs and outputs from the computer.ex:"redstone probe" will list all the redstone inputs to the computer"redstone set left true" turns on the left redstone output."redstone set right blue false" turns off the blue wire in the bundled cable on the right redstone output."redstone pulse front 10 1" emits 10 one second redstone pulses on the front redstone output.Type "help redstoneapi" or "help rs" for information on the redstone Lua API.`nFunctions in the Redstone API:redstone.getSides( )redstone.getInput( side )redstone.setOutput( side, boolean )redstone.getOutput( side )redstone.getAnalogInput( side )redstone.setAnalogOutput( side, number )redstone.getAnalogOutput( side )Functions in the Redstone API for working with bundled cables:redstone.getBundledInput( side )redstone.testBundledInput( side, color )redstone.setBundledOutput( side, colors )redstone.getBundledOutput( side )Type "help bundled" for usage examples.Events emitted by the redstone API:"redstone", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changesType "help events" to learn about the event system.`nrefuel is a program for Turtles. Refuel will consume items from the inventory as fuel for turtle.ex:"refuel" will refuel with at most one fuel item"refuel 10" will refuel with at most 10 fuel items"refuel all" will refuel with as many fuel items as possible`nrename renames a file or directory.ex:"rename foo bar" renames the file "foo" to "bar".`nrepeat is a program for repeating rednet messages across long distances. To use, connect 2 or more modems to a computer and run the "repeat" program; from then on, any rednet message sent from any computer in wireless range or connected by networking cable to either of the modems will be repeated to those on the other side.`nFunctions in the Redstone API:rs.getSides( )rs.getInput( side )rs.setOutput( side, boolean )rs.getOutput( side )rs.getAnalogInput( side )rs.setAnalogOutput( side, number )rs.getAnalogOutput( side )Functions in the Redstone API for working with RedPower bundled cables:rs.getBundledInput( side )rs.testBundledInput( side, color )rs.setBundledOutput( side, colors )rs.getBundledOutput( side )Type "help bundled" for usage examples.Events emitted by the redstone API:"redstone", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changesType "help events" to learn about the event system.`nshell is the toplevel program which interprets commands and runs program.Type "help shellapi" for information about the shell lua api.`nFunctions in the Shell API:shell.exit()shell.dir()shell.setDir( path )shell.path()shell.setPath( path )shell.resolve( localpath )shell.resolveProgram( name )shell.aliases()shell.setAlias( alias, command )shell.clearAlias( alias )shell.programs()shell.run( program, arguments )shell.getRunningProgram()shell.openTab( program, arguments ) (Advanced Computer required)shell.switchTab( n ) (Advanced Computer required)`nshutdown will turn off the computer.`nsleep makes the computer idle for a specific number of seconds.ex:"sleep 10" puts the computer to sleep for 10 seconds`nstring is a standard Lua5.1 API.Refer to http://www.lua.org/manual/5.1/ for more information.`ntable is a standard Lua5.1 API.Refer to http://www.lua.org/manual/5.1/ for more information.`nFunctions in the Terminal API:term.write( text )term.clear()term.clearLine()term.getCursorPos()term.setCursorPos( x, y )term.setCursorBlink( blink )term.isColor()term.setTextColor( color )term.setBackgroundColor( color )term.getSize()term.scroll( n )term.redirect( object )term.current()Events emitted by the terminals:"term_resize", when the size of a terminal changes. This can happen in multitasking environments, or when the terminal out is being redirected by the "monitor" program.`nFunctions in the Text Utilities API:textutils.slowPrint( text )textutils.tabulate( table, table2, ... )textutils.pagedTabulate( table, table2, ... )textutils.formatTime( time, bTwentyFourHour )textutils.serialize( table )textutils.unserialize( string )textutils.urlEncode( string )`ntime prints the current time of day.`ntunnel is a program for Mining Turtles. Tunnel will mine a 3x2 tunnel of the depth specified.ex:"tunnel 20" will tunnel a tunnel 20 blocks long.`nturn is a program for Turtles, used to turn the turtle around without programming. It accepts one or more commands as a direction and a number of turns. The "go" program can also be used for turning.ex:"turn left" turns the turtle 90 degrees left."turn right 2" turns the turtle 180 degrees right."turn left 2 right" turns left 180 degrees, then right 90 degrees.`nturtle is an api availiable on Turtles, which controls their movement.Functions in the Turtle API:turtle.forward()turtle.back()turtle.up()turtle.down()turtle.turnLeft()turtle.turnRight()turtle.select( slotNum )turtle.getSelectedSlot()turtle.getItemCount( [slotNum] )turtle.getItemSpace( [slotNum] )turtle.getItemDetail( [slotNum] )turtle.equipLeft()turtle.equipRight()turtle.dig( [toolSide] )turtle.digUp( [toolSide] )turtle.digDown( [toolSide] )turtle.place()turtle.placeUp()turtle.placeDown()turtle.attack( [toolSide] )turtle.attackUp( [toolSide] )turtle.attackDown( [toolSide] )turtle.detect()turtle.detectUp()turtle.detectDown()turtle.compare()turtle.compareUp()turtle.compareDown()turtle.inspect()turtle.inspectUp()turtle.inspectDown()turtle.inspectSlot( [slotNum] )turtle.compareTo( slotNum )turtle.transferTo( slotNum, [quantity] )turtle.drop( [quantity] )turtle.dropUp( [quantity] )turtle.dropDown( [quantity] )turtle.suck( [quantity] )turtle.suckUp( [quantity] )turtle.suckDown( [quantity] )turtle.getFuelLevel()turtle.getFuelLimit()turtle.refuel( [quantity] )turtle.craft( [quantity] ) (requires Crafty Turtle)Events fired by the Turtle API:"turtle_inventory" when any of the items in the inventory are changed. Use comparison operations to inspect the changes.`ntype determines the type of a file or directory. Prints "file", "directory" or "does not exist".`nunequip is a program for Turtles. unequip will remove tools of peripherals from the specified side of the turtle.ex:"unequip left" will remove the item on the left side of the turtle`nFunctions in the 3D Vector Math API:vector.new( x,y,z )Vectors returned by vector.new() have the following fields and methods:vector.xvector.yvector.zvector:add( vector )vector:sub( vector )vector:mul( number )vector:dot( vector )vector:cross( vector )vector:length()vector:normalize()vector:round()vector:tostring()The +, - and * operators can also be used on vectors.`nNew Features in ComputerCraft 1.65:* Fixed a multiplayer-only crash with turtle.place()* Fixed some problems with http.post()* Fixed fs.getDrive() returning incorrect results on remote peripheralsType "help changelog" to see the full version history.`nFunctions in the window API:window.create( parent, x, y, width, height, visible )Windows created with the window API have the following methods:write( text )clear()clearLine()getCursorPos()setCursorPos( x, y )setCursorBlink( blink )isColor()setTextColor( color )setBackgroundColor( color )getSize()scroll( n )setVisible( bVisible )redraw()restoreCursor()getPosition()reposition( x, y, width, height )`nWorkbenches are peripheral devices found on Crafty Turtles running CraftOS. Type "help peripheral" to learn about using the Peripheral API to connect with peripherals. When a workbench is attached to a turtle, peripheral.getType() will return "workbench".Methods exposed by Workbenches:craft( channel )`nYou've played it in the arcades, now experience the high-octane thrills of the hit game "WORM!" on your home computer! Only on CraftOS!`nCopyright (c) 2007 LuaJ. All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.`n/rom/help/licenses`n/rom/help`nlocal tArgs = { ... }if #tArgs > 2 then	print( "Usage: alias <alias> <program>" )	returnendlocal sAlias = tArgs[1]local sProgram = tArgs[2]if sAlias and sProgram then	-- Set alias	shell.setAlias( sAlias, sProgram )elseif sAlias then	-- Clear alias	shell.clearAlias( sAlias )else	-- List aliases	local tAliases = shell.aliases()	local tList = {}	for sAlias, sCommand in pairs( tAliases ) do		table.insert( tList, sAlias )	end	table.sort( tList )	textutils.pagedTabulate( tList )end	`nlocal tApis = {}for k,v in pairs( _G ) do	if type(k) == "string" and type(v) == "table" and k ~= "_G" then		table.insert( tApis, k )	endendtable.insert( tApis, "shell" )table.sort( tApis )textutils.pagedTabulate( tApis )`nlocal tArgs = { ... }if #tArgs < 1 then	print( "Usage: cd <path>" )	returnendlocal sNewDir = shell.resolve( tArgs[1] )if fs.isDir( sNewDir ) then	shell.setDir( sNewDir )else  	print( "Not a directory" )  	returnend`nterm.clear()term.setCursorPos( 1, 1 )`nlocal tArgs = { ... }if #tArgs < 2 then	print( "Usage: cp <source> <destination>" )	returnendlocal sSource = shell.resolve( tArgs[1] )local sDest = shell.resolve( tArgs[2] )local tFiles = fs.find( sSource )if #tFiles > 0 then    for n,sFile in ipairs( tFiles ) do        if fs.isDir( sDest ) then            fs.copy( sFile, fs.combine( sDest, fs.getName(sFile) ) )        elseif #tFiles == 1 then            fs.copy( sFile, sDest )        else            printError( "Cannot overwrite file multiple times" )            return        end    endelse    printError( "No matching files" )end`nlocal tArgs = { ... }if #tArgs < 1 then	print( "Usage: rm <path>" )	returnendlocal sPath = shell.resolve( tArgs[1] )local tFiles = fs.find( sPath )if #tFiles > 0 then    for n,sFile in ipairs( tFiles ) do        fs.delete( sFile )    endelse    printError( "No matching files" )end`nlocal tArgs = { ... }-- Get where a directory is mountedlocal sPath = shell.dir()if tArgs[1] ~= nil then	sPath = shell.resolve( tArgs[1] )endif fs.exists( sPath ) then	write( fs.getDrive( sPath ) .. " (" )	local nSpace = fs.getFreeSpace( sPath )	if nSpace > 1024 * 1024 then		print( (math.floor( nSpace / (100 * 1000) ) / 10) .. "MB remaining)" )	elseif nSpace > 1024 then		print( math.floor( nSpace / 1000 ) .. "KB remaining)" )	else		print ( nSpace .. "B remaining)" )	endelse	print( "No such path" )end`n-- Get file to editlocal tArgs = { ... }if #tArgs == 0 then	print( "Usage: edit <path>" )	returnend-- Error checkinglocal sPath = shell.resolve( tArgs[1] )local bReadOnly = fs.isReadOnly( sPath )if fs.exists( sPath ) and fs.isDir( sPath ) then	print( "Cannot edit a directory." )	returnendlocal x,y = 1,1local w,h = term.getSize()local scrollX, scrollY = 0,0local tLines = {}local bRunning = true-- Colourslocal highlightColour, keywordColour, commentColour, textColour, bgColourif term.isColour() then	bgColour = colours.black	textColour = colours.white	highlightColour = colours.yellow	keywordColour = colours.yellow	commentColour = colours.green	stringColour = colours.redelse	bgColour = colours.black	textColour = colours.white	highlightColour = colours.white	keywordColour = colours.white	commentColour = colours.white	stringColour = colours.whiteend-- Menuslocal bMenu = falselocal nMenuItem = 1local tMenuItemsif bReadOnly then	tMenuItems = { "Exit", "Print" }else	tMenuItems = { "Save", "Exit", "Print" }end	local sStatus = "Press Ctrl to access menu"local function load( _sPath )	tLines = {}	if fs.exists( _sPath ) then		local file = io.open( _sPath, "r" )		local sLine = file:read()		while sLine do			table.insert( tLines, sLine )			sLine = file:read()		end		file:close()	end		if #tLines == 0 then		table.insert( tLines, "" )	endendlocal function save( _sPath )	-- Create intervening folder	local sDir = sPath:sub(1, sPath:len() - fs.getName(sPath):len() )	if not fs.exists( sDir ) then		fs.makeDir( sDir )	end	-- Save	local file = nil	local function innerSave()		file = fs.open( _sPath, "w" )		if file then			for n, sLine in ipairs( tLines ) do				file.write( sLine .. "\n" )			end		else			error( "Failed to open ".._sPath )		end	end		local ok = pcall( innerSave )	if file then 		file.close()	end	return okendlocal tKeywords = {	["and"] = true,	["break"] = true,	["do"] = true,	["else"] = true,	["elseif"] = true,	["end"] = true,	["false"] = true,	["for"] = true,	["function"] = true,	["if"] = true,	["in"] = true,	["local"] = true,	["nil"] = true,	["not"] = true,	["or"] = true,	["repeat"] = true,	["return"] = true,	["then"] = true,	["true"] = true,	["until"]= true,	["while"] = true,}local function tryWrite( sLine, regex, colour )	local match = string.match( sLine, regex )	if match then		if type(colour) == "number" then			term.setTextColour( colour )		else			term.setTextColour( colour(match) )		end		term.write( match )		term.setTextColour( textColour )		return string.sub( sLine, string.len(match) + 1 )	end	return nilendlocal function writeHighlighted( sLine )	while string.len(sLine) > 0 do			sLine = 			tryWrite( sLine, "^%-%-%[%[.-%]%]", commentColour ) or			tryWrite( sLine, "^%-%-.*", commentColour ) or			tryWrite( sLine, "^\".-[^\\]\"", stringColour ) or			tryWrite( sLine, "^\'.-[^\\]\'", stringColour ) or			tryWrite( sLine, "^%[%[.-%]%]", stringColour ) or			tryWrite( sLine, "^[%w_]+", function( match )				if tKeywords[ match ] then					return keywordColour				end				return textColour			end ) or			tryWrite( sLine, "^[^%w_]", textColour )	endendlocal function redrawText()	for y=1,h-1 do		term.setCursorPos( 1 - scrollX, y )		term.clearLine()		local sLine = tLines[ y + scrollY ]		if sLine ~= nil then			writeHighlighted( sLine )		end	end	term.setCursorPos( x - scrollX, y - scrollY )endlocal function redrawLine(_nY)	local sLine = tLines[_nY]	term.setCursorPos( 1 - scrollX, _nY - scrollY )	term.clearLine()	writeHighlighted( sLine )	term.setCursorPos( x - scrollX, _nY - scrollY )endlocal function redrawMenu()    -- Clear line    term.setCursorPos( 1, h )	term.clearLine()    -- Draw line numbers    term.setCursorPos( w - string.len( "Ln "..y ) + 1, h )    term.setTextColour( highlightColour )    term.write( "Ln " )    term.setTextColour( textColour )    term.write( y )    term.setCursorPos( 1, h )	if bMenu then        -- Draw menu		term.setTextColour( textColour )		for nItem,sItem in pairs( tMenuItems ) do			if nItem == nMenuItem then				term.setTextColour( highlightColour )				term.write( "[" )				term.setTextColour( textColour )				term.write( sItem )				term.setTextColour( highlightColour )				term.write( "]" )        		term.setTextColour( textColour )			else				term.write( " "..sItem.." " )			end		end    else        -- Draw status        term.setTextColour( highlightColour )        term.write( sStatus )        term.setTextColour( textColour )    end	-- Reset cursor	term.setCursorPos( x - scrollX, y - scrollY )endlocal tMenuFuncs = { 	Save=function()		if bReadOnly then			sStatus = "Access denied"		else			local ok, err = save( sPath )			if ok then				sStatus="Saved to "..sPath			else				sStatus="Error saving to "..sPath			end		end		redrawMenu()	end,	Print=function()		local printer = peripheral.find( "printer" )		if not printer then			sStatus = "No printer attached"			return		end		local nPage = 0		local sName = fs.getName( sPath )		if printer.getInkLevel() < 1 then			sStatus = "Printer out of ink"			return		elseif printer.getPaperLevel() < 1 then			sStatus = "Printer out of paper"			return		end		local screenTerminal = term.current()		local printerTerminal = {			getCursorPos = printer.getCursorPos,			setCursorPos = printer.setCursorPos,			getSize = printer.getPageSize,			write = printer.write,		}		printerTerminal.scroll = function()			if nPage == 1 then				printer.setPageTitle( sName.." (page "..nPage..")" )						end						while not printer.newPage()	do				if printer.getInkLevel() < 1 then					sStatus = "Printer out of ink, please refill"				elseif printer.getPaperLevel() < 1 then					sStatus = "Printer out of paper, please refill"				else					sStatus = "Printer output tray full, please empty"				end					term.redirect( screenTerminal )				redrawMenu()				term.redirect( printerTerminal )								local timer = os.startTimer(0.5)				sleep(0.5)			end			nPage = nPage + 1			if nPage == 1 then				printer.setPageTitle( sName )			else				printer.setPageTitle( sName.." (page "..nPage..")" )			end		end				bMenu = false		term.redirect( printerTerminal )		local ok, error = pcall( function()			term.scroll()			for n, sLine in ipairs( tLines ) do				print( sLine )			end		end )        term.redirect( screenTerminal )		if not ok then			print( error )		end				while not printer.endPage() do			sStatus = "Printer output tray full, please empty"			redrawMenu()			sleep( 0.5 )		end		bMenu = true					if nPage > 1 then			sStatus = "Printed "..nPage.." Pages"		else			sStatus = "Printed 1 Page"		end		redrawMenu()	end,	Exit=function()		bRunning = false	end}local function doMenuItem( _n )	tMenuFuncs[tMenuItems[_n]]()	if bMenu then		bMenu = false		term.setCursorBlink( true )	end	redrawMenu()endlocal function setCursor( x, y )	local screenX = x - scrollX	local screenY = y - scrollY		local bRedraw = false	if screenX < 1 then		scrollX = x - 1		screenX = 1		bRedraw = true	elseif screenX > w then		scrollX = x - w		screenX = w		bRedraw = true	end		if screenY < 1 then		scrollY = y - 1		screenY = 1		bRedraw = true	elseif screenY > h-1 then		scrollY = y - (h-1)		screenY = h-1		bRedraw = true	end		if bRedraw then		redrawText()	end	term.setCursorPos( screenX, screenY )		-- Statusbar now pertains to menu, it would probably be safe to redraw the menu on every key event.	redrawMenu()end-- Actual program functionality beginsload(sPath)term.setBackgroundColour( bgColour )term.clear()term.setCursorPos(x,y)term.setCursorBlink( true )redrawText()redrawMenu()-- Handle inputwhile bRunning do	local sEvent, param, param2, param3 = os.pullEvent()	if sEvent == "key" then		if param == keys.up then			-- Up			if not bMenu then				if y > 1 then					-- Move cursor up					y = y - 1					x = math.min( x, string.len( tLines[y] ) + 1 )					setCursor( x, y )				end			end		elseif param == keys.down then			-- Down			if not bMenu then				-- Move cursor down				if y < #tLines then					y = y + 1					x = math.min( x, string.len( tLines[y] ) + 1 )					setCursor( x, y )				end			end		elseif param == keys.tab then			-- Tab			if not bMenu and not bReadOnly then				-- Indent line				tLines[y]="  "..tLines[y]				x = x + 2				setCursor( x, y )				redrawLine(y)			end		elseif param == keys.pageUp then			-- Page Up			if not bMenu then				-- Move up a page				if y - (h - 1) >= 1 then					y = y - (h - 1)				else					y = 1				end				x = math.min( x, string.len( tLines[y] ) + 1 )				setCursor( x, y )			end		elseif param == keys.pageDown then			-- Page Down			if not bMenu then				-- Move down a page				if y + (h - 1) <= #tLines then					y = y + (h - 1)				else					y = #tLines				end				x = math.min( x, string.len( tLines[y] ) + 1 )				setCursor( x, y )			end		elseif param == keys.home then			-- Home			if not bMenu then				-- Move cursor to the beginning				x=1				setCursor(x,y)			end		elseif param == keys["end"] then			-- End			if not bMenu then				-- Move cursor to the end				x = string.len( tLines[y] ) + 1				setCursor(x,y)			end		elseif param == keys.left then			-- Left			if not bMenu then				if x > 1 then					-- Move cursor left					x = x - 1				elseif x==1 and y>1 then					x = string.len( tLines[y-1] ) + 1					y = y - 1				end				setCursor( x, y )			else				-- Move menu left				nMenuItem = nMenuItem - 1				if nMenuItem < 1 then					nMenuItem = #tMenuItems				end				redrawMenu()			end		elseif param == keys.right then			-- Right			if not bMenu then				if x < string.len( tLines[y] ) + 1 then					-- Move cursor right					x = x + 1				elseif x==string.len( tLines[y] ) + 1 and y<#tLines then					x = 1					y = y + 1				end				setCursor( x, y )			else				-- Move menu right				nMenuItem = nMenuItem + 1				if nMenuItem > #tMenuItems then					nMenuItem = 1				end				redrawMenu()			end		elseif param == keys.delete then			-- Delete			if not bMenu and not bReadOnly then				if  x < string.len( tLines[y] ) + 1 then					local sLine = tLines[y]					tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)					redrawLine(y)				elseif y<#tLines then					tLines[y] = tLines[y] .. tLines[y+1]					table.remove( tLines, y+1 )					redrawText()					redrawMenu()				end			end		elseif param == keys.backspace then			-- Backspace			if not bMenu and not bReadOnly then				if x > 1 then					-- Remove character					local sLine = tLines[y]					tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)					redrawLine(y)								x = x - 1					setCursor( x, y )				elseif y > 1 then					-- Remove newline					local sPrevLen = string.len( tLines[y-1] )					tLines[y-1] = tLines[y-1] .. tLines[y]					table.remove( tLines, y )					redrawText()									x = sPrevLen + 1					y = y - 1					setCursor( x, y )				end			end		elseif param == keys.enter then			-- Enter			if not bMenu and not bReadOnly then				-- Newline				local sLine = tLines[y]				local _,spaces=string.find(sLine,"^[ ]+")				if not spaces then					spaces=0				end				tLines[y] = string.sub(sLine,1,x-1)				table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )				redrawText()							x = spaces+1				y = y + 1				setCursor( x, y )			elseif bMenu then				-- Menu selection				doMenuItem( nMenuItem )			end		elseif param == keys.leftCtrl or param == keys.rightCtrl then			-- Menu toggle			bMenu = not bMenu			if bMenu then				term.setCursorBlink( false )			else				term.setCursorBlink( true )			end			redrawMenu()		end			elseif sEvent == "char" then		if not bMenu and not bReadOnly then			-- Input text			local sLine = tLines[y]			tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)			redrawLine(y)					x = x + 1			setCursor( x, y )		elseif bMenu then			-- Select menu items			for n,sMenuItem in ipairs( tMenuItems ) do				if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then					doMenuItem( n )					break				end			end		end	elseif sEvent == "paste" then		if not bMenu and not bReadOnly then			-- Input text			local sLine = tLines[y]			tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)			redrawLine(y)			x = x + string.len( param )			setCursor( x, y )		end			elseif sEvent == "mouse_click" then		if not bMenu then			if param == 1 then				-- Left click				local cx,cy = param2, param3				if cy < h then					y = math.min( math.max( scrollY + cy, 1 ), #tLines )					x = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[y] ) + 1 )					setCursor( x, y )				end			end		end			elseif sEvent == "mouse_scroll" then		if not bMenu then			if param == -1 then				-- Scroll up				if scrollY > 0 then					-- Move cursor up					scrollY = scrollY - 1					redrawText()				end						elseif param == 1 then				-- Scroll down				local nMaxScroll = #tLines - (h-1)				if scrollY < nMaxScroll then					-- Move cursor down					scrollY = scrollY + 1					redrawText()				end							end		end	elseif sEvent == "term_resize" then	    w,h = term.getSize()        setCursor( x, y )        redrawMenu()        redrawText()	endend-- Cleanupterm.clear()term.setCursorBlink( false )term.setCursorPos( 1, 1 )`n-- Get argumentslocal tArgs = { ... }if #tArgs == 0 then	print( "Usage: eject <drive>" )	returnendlocal sDrive = tArgs[1]-- Check the disk existslocal bPresent = disk.isPresent( sDrive )if not bPresent then	print( "Nothing in "..sDrive.." drive" )	returnenddisk.eject( sDrive )`nshell.exit()`nlocal function printUsage()	print( "Usages:" )	print( "gps host" )	print( "gps host <x> <y> <z>" )	print( "gps locate" )endlocal tArgs = { ... }if #tArgs < 1 then	printUsage()	returnend	local sCommand = tArgs[1]if sCommand == "locate" then	-- "gps locate"	-- Just locate this computer (this will print the results)	gps.locate( 2, true )	elseif sCommand == "host" then	-- "gps host"	-- Act as a GPS host	if pocket then	    print( "GPS Hosts must be stationary" )	    return	end	-- Find a modem	local sModemSide = nil	for n,sSide in ipairs( rs.getSides() ) do		if peripheral.getType( sSide ) == "modem" and peripheral.call( sSide, "isWireless" ) then				sModemSide = sSide			break		end	end	if sModemSide == nil then		print( "No wireless modems found. 1 required." )		return	end		-- Open a channel	local modem = peripheral.wrap( sModemSide )    print( "Opening channel on modem "..sModemSide )    modem.open( gps.CHANNEL_GPS )	-- Determine position	local x,y,z	if #tArgs >= 4 then		-- Position is manually specified		x = tonumber(tArgs[2])		y = tonumber(tArgs[3])		z = tonumber(tArgs[4])		if x == nil or y == nil or z == nil then			printUsage()			return		end		print( "Position is "..x..","..y..","..z )	else		-- Position is to be determined using locate				x,y,z = gps.locate( 2, true )		if x == nil then			print( "Run \"gps host <x> <y> <z>\" to set position manually" )			if bCloseChannel then				print( "Closing GPS channel" )				modem.close( gps.CHANNEL_GPS )			end			return		end	end		-- Serve requests indefinately	local nServed = 0	while true do		local e, p1, p2, p3, p4, p5 = os.pullEvent( "modem_message" )		if e == "modem_message" then			-- We received a message from a modem			local sSide, sChannel, sReplyChannel, sMessage, nDistance = p1, p2, p3, p4, p5			if sSide == sModemSide and sChannel == gps.CHANNEL_GPS and sMessage == "PING" then				-- We received a ping message on the GPS channel, send a response				modem.transmit( sReplyChannel, gps.CHANNEL_GPS, { x, y, z } )							-- Print the number of requests handled				nServed = nServed + 1				if nServed > 1 then					local x,y = term.getCursorPos()					term.setCursorPos(1,y-1)				end				print( nServed.." GPS requests served" )			end		end	end	    print( "Closing channel" )    modem.close( gps.CHANNEL_GPS )else	-- "gps somethingelse"	-- Error	printUsage()	end`ntArgs = { ... }if #tArgs > 0 then	sTopic = tArgs[1]else	sTopic = "intro"endif sTopic == "index" then	print( "Help topics availiable:" )	local tTopics = help.topics()	textutils.pagedTabulate( tTopics )	returnend	local w,h = term.getSize()local sFile = help.lookup( sTopic )local file = ((sFile ~= nil) and io.open( sFile )) or nillocal nLinesPrinted = 0if file then	local sLine = file:read()	local nLines = 0	while sLine do		nLines = nLines + textutils.pagedPrint( sLine, (h-3) - nLines )    	sLine = file:read()    end	file:close()else	print( "No help available" )end`nlocal sDrive = nillocal tArgs = { ... }if #tArgs > 0 then	sDrive = tostring( tArgs[1] )endif sDrive == nil then	print( "This is computer #"..os.getComputerID() )		local label = os.getComputerLabel()	if label then		print( "This computer is labelled \""..label.."\"" )	endelse	local bData = disk.hasData( sDrive )	if not bData then		print( "No disk in drive "..sDrive )		return	end		print( "The disk is #"..disk.getID( sDrive ) )	local label = disk.getLabel( sDrive )	if label then		print( "The disk is labelled \""..label.."\"" )	endend`nlocal function printUsage()	print( "Usages:" )	print( "label get" )	print( "label get <drive>" )	print( "label set <text>" )	print( "label set <drive> <text>" )	print( "label clear" )	print( "label clear <drive>" )endlocal function checkDrive( sDrive )    if peripheral.getType( sDrive ) == "drive" then        -- Check the disk exists        local bData = disk.hasData( sDrive )        if not bData then            print( "No disk in "..sDrive.." drive" )            return false        end    else	    print( "No disk drive named "..sDrive )        return false	end	return trueendlocal function get( sDrive )	if sDrive ~= nil then	    if checkDrive( sDrive ) then            local sLabel = disk.getLabel( sDrive )            if sLabel then                print( "Disk label is \""..sLabel.."\"" )            else                print( "No Disk label" )            end        end	else		local sLabel = os.getComputerLabel()		if sLabel then			print( "Computer label is \""..sLabel.."\"" )		else			print( "No Computer label" )		end	endendlocal function set( sDrive, sText )	if sDrive ~= nil then	    if checkDrive( sDrive ) then            disk.setLabel( sDrive, sText )            local sLabel = disk.getLabel( sDrive )            if sLabel then                print( "Disk label set to \""..sLabel.."\"" )            else                print( "Disk label cleared" )            end        end	else		os.setComputerLabel( sText )		local sLabel = os.getComputerLabel()		if sLabel then			print( "Computer label set to \""..sLabel.."\"" )		else			print( "Computer label cleared" )		end	endendlocal tArgs = { ... }local sCommand = tArgs[1]if sCommand == "get" then    -- Get a label    if #tArgs == 1 then        get( nil )    elseif #tArgs == 2 then        get( tArgs[2] )    else        printUsage()    endelseif sCommand == "set" then    -- Set a label    if #tArgs == 2 then        set( nil, tArgs[2] )    elseif #tArgs == 3 then        set( tArgs[2], tArgs[3] )    else        printUsage()    endelseif sCommand == "clear" then    -- Clear a label    if #tArgs == 1 then        set( nil, nil )    elseif #tArgs == 2 then        set( tArgs[2], nil )    else        printUsage()    endelse    printUsage()end`nlocal tArgs = { ... }-- Get all the files in the directorylocal sDir = shell.dir()if tArgs[1] ~= nil then	sDir = shell.resolve( tArgs[1] )end-- Sort into dirs/files, and calculate column countlocal tAll = fs.list( sDir )local tFiles = {}local tDirs = {}for n, sItem in pairs( tAll ) do	if string.sub( sItem, 1, 1 ) ~= "." then		local sPath = fs.combine( sDir, sItem )		if fs.isDir( sPath ) then			table.insert( tDirs, sItem )		else			table.insert( tFiles, sItem )		end	endendtable.sort( tDirs )table.sort( tFiles )if term.isColour() then	textutils.pagedTabulate( colors.green, tDirs, colors.white, tFiles )else	textutils.pagedTabulate( tDirs, tFiles )end`nlocal tArgs = { ... }if #tArgs > 0 then	print( "This is an interactive Lua prompt." )	print( "To run a lua program, just type its name." )	returnendlocal bRunning = truelocal tCommandHistory = {}local tEnv = {	["exit"] = function()		bRunning = false	end,	["_echo"] = function( ... )	    return ...	end,}setmetatable( tEnv, { __index = getfenv() } )if term.isColour() then	term.setTextColour( colours.yellow )endprint( "Interactive Lua prompt." )print( "Call exit() to exit." )term.setTextColour( colours.white )while bRunning do	--if term.isColour() then	--	term.setTextColour( colours.yellow )	--end	write( "lua> " )	--term.setTextColour( colours.white )		local s = read( nil, tCommandHistory )	table.insert( tCommandHistory, s )		local nForcePrint = 0	local func, e = loadstring( s, "lua" )	local func2, e2 = loadstring( "return _echo("..s..");", "lua" )	if not func then		if func2 then			func = func2			e = nil			nForcePrint = 1		end	else		if func2 then			func = func2		end	end		if func then        setfenv( func, tEnv )        local tResults = { pcall( func ) }        if tResults[1] then        	local n = 1        	while (tResults[n + 1] ~= nil) or (n <= nForcePrint) do        	    local value = tResults[ n + 1 ]        	    if type( value ) == "table" then            	    local ok, serialised = pcall( textutils.serialise, value )            	    if ok then            	        print( serialised )            	    else            	        print( tostring( value ) )            	    end            	else            	    print( tostring( value ) )            	end        		n = n + 1        	end        else        	printError( tResults[2] )        end    else    	printError( e )    end    end`nlocal tArgs = { ... }if #tArgs < 1 then	print( "Usage: mkdir <path>" )	returnendlocal sNewDir = shell.resolve( tArgs[1] )fs.makeDir( sNewDir )`nfunction printUsage()	print( "Usage: monitor <name> <program> <arguments>" )	returnendlocal tArgs = { ... }if #tArgs < 2 then	printUsage()	returnendlocal sName = tArgs[1]if peripheral.getType( sName ) ~= "monitor" then	print( "No monitor named ".. sName )	returnendlocal sProgram = tArgs[2]local sPath = shell.resolveProgram( sProgram )if sPath == nil then	print( "No such program: "..sProgram )	returnendprint( "Running "..sProgram.." on monitor "..sName )local monitor = peripheral.wrap( sName )local previousTerm = term.redirect( monitor )local co = coroutine.create( function()    shell.run( sProgram, unpack( tArgs, 3 ) )end )local function resume( ... )    local ok, param = coroutine.resume( co, ... )    if not ok then    	printError( param )    end    return paramendlocal ok, param = pcall( function()	local sFilter = resume()	while coroutine.status( co ) ~= "dead" do		local tEvent = { os.pullEventRaw() }		if sFilter == nil or tEvent[1] == sFilter or tEvent[1] == "terminate" then			sFilter = resume( unpack( tEvent ) )		end		if coroutine.status( co ) ~= "dead" and (sFilter == nil or sFilter == "mouse_click") then			if tEvent[1] == "monitor_touch" and tEvent[2] == sName then				sFilter = resume( "mouse_click", 1, unpack( tEvent, 3 ) )			end		end		if coroutine.status( co ) ~= "dead" and (sFilter == nil or sFilter == "term_resize") then			if tEvent[1] == "monitor_resize" and tEvent[2] == sName then				sFilter = resume( "term_resize" )			end		end	endend )term.redirect( previousTerm )if not ok then	printError( param )end	`nlocal tArgs = { ... }if #tArgs < 2 then	print( "Usage: mv <source> <destination>" )	returnendlocal sSource = shell.resolve( tArgs[1] )local sDest = shell.resolve( tArgs[2] )local tFiles = fs.find( sSource )if #tFiles > 0 then    for n,sFile in ipairs( tFiles ) do        if fs.isDir( sDest ) then            fs.move( sFile, fs.combine( sDest, fs.getName(sFile) ) )        elseif #tFiles == 1 then            fs.move( sFile, sDest )        else            printError( "Cannot overwrite file multiple times" )            return        end    endelse    printError( "No matching files" )end`nlocal bAll = falselocal tArgs = { ... }if #tArgs > 0 and tArgs[1] == "all" then	bAll = trueendlocal tPrograms = shell.programs( bAll )textutils.pagedTabulate( tPrograms )`nif term.isColour() then	term.setTextColour( colours.yellow )endprint( "Goodbye" )term.setTextColour( colours.white )sleep( 1 )os.reboot()`nlocal tArgs = { ... }local function printUsage()    print( "Usages:" )    print( "redstone probe" )    print( "redstone set <side> <value>" )    print( "redstone set <side> <color> <value>" )    print( "redstone pulse <side> <count> <period>" )endlocal sCommand = tArgs[1]if sCommand == "probe" then    -- "redstone probe"    -- Regular input    print( "Redstone inputs: " )    local count = 0    local bundledCount = 0    for n,sSide in ipairs( redstone.getSides() ) do        if redstone.getBundledInput( sSide ) > 0 then            bundledCount = bundledCount + 1        end        if redstone.getInput( sSide ) then            if count > 0 then                io.write( ", " )            end            io.write( sSide )            count = count + 1        end    end    if count > 0 then        print( "." )    else        print( "None." )    end    -- Bundled input    if bundledCount > 0 then        print()        print( "Bundled inputs:" )        for i,sSide in ipairs( redstone.getSides() ) do            local nInput = redstone.getBundledInput( sSide )            if nInput ~= 0 then                write( sSide..": " )                local count = 0                for sColour,nColour in pairs( colors ) do                    if type( nColour ) == "number" and colors.test( nInput, nColour ) then                        if count > 0 then                            write( ", " )                        end                        if term.isColour() then                            term.setTextColour( nColour )                        end                        write( sColour )                        if term.isColour() then                            term.setTextColour( colours.white )                        end                        count = count + 1                    end                end                print( "." )            end        end    endelseif sCommand == "pulse" then    -- "redstone pulse"    local sSide = tArgs[2]    local nCount = tonumber( tArgs[3] ) or 1    local nPeriod = tonumber( tArgs[4] ) or 0.5    for n=1,nCount do        redstone.setOutput( sSide, true )        sleep( nPeriod / 2 )        redstone.setOutput( sSide, false )        sleep( nPeriod / 2 )    endelseif sCommand == "set" then    -- "redstone set"    local sSide = tArgs[2]    if #tArgs > 3 then        -- Bundled cable output        local sColour = tArgs[3]        local nColour = colors[sColour] or colours[sColour]        if type(nColour) ~= "number" then            printError( "No such color" )            return        end        local sValue = tArgs[4]        if sValue == "true" then            rs.setBundledOutput( sSide, colors.combine( rs.getBundledOutput( sSide ), nColour ) )        elseif sValue == "false" then            rs.setBundledOutput( sSide, colors.subtract( rs.getBundledOutput( sSide ), nColour ) )        else            print( "Value must be boolean" )        end    else        -- Regular output        local sValue = tArgs[3]        local nValue = tonumber(sValue)        if sValue == "true" then            rs.setOutput( sSide, true )        elseif sValue == "false" then            rs.setOutput( sSide, false )        elseif nValue and nValue >= 0 and nValue <= 15 then            rs.setAnalogOutput( sSide, nValue )        else            print( "Value must be boolean or 0-15" )        end    endelse    -- Something else    printUsage()end`nlocal tArgs = { ... }if #tArgs < 2 then	print( "Usage: rename <source> <destination>" )	returnendlocal sSource = shell.resolve( tArgs[1] )local sDest = shell.resolve( tArgs[2] )fs.move( sSource, sDest )`nlocal multishell = multishelllocal parentShell = shelllocal parentTerm = term.current()if multishell then    multishell.setTitle( multishell.getCurrent(), "shell" )endlocal bExit = falselocal sDir = (parentShell and parentShell.dir()) or ""local sPath = (parentShell and parentShell.path()) or ".:/rom/programs"local tAliases = (parentShell and parentShell.aliases()) or {}local tProgramStack = {}local shell = {}local tEnv = {	[ "shell" ] = shell,	[ "multishell" ] = multishell,}-- Colourslocal promptColour, textColour, bgColourif term.isColour() then	promptColour = colours.yellow	textColour = colours.white	bgColour = colours.blackelse	promptColour = colours.white	textColour = colours.white	bgColour = colours.blackendlocal function run( _sCommand, ... )	local sPath = shell.resolveProgram( _sCommand )	if sPath ~= nil then		tProgramStack[#tProgramStack + 1] = sPath		if multishell then		    multishell.setTitle( multishell.getCurrent(), fs.getName( sPath ) )		end   		local result = os.run( tEnv, sPath, ... )		tProgramStack[#tProgramStack] = nil		if multishell then		    if #tProgramStack > 0 then    		    multishell.setTitle( multishell.getCurrent(), fs.getName( tProgramStack[#tProgramStack] ) )    		else    		    multishell.setTitle( multishell.getCurrent(), "shell" )    		end		end		return result   	else    	printError( "No such program" )    	return false    endendlocal function tokenise( ... )    local sLine = table.concat( { ... }, " " )	local tWords = {}    local bQuoted = false    for match in string.gmatch( sLine .. "\"", "(.-)\"" ) do        if bQuoted then            table.insert( tWords, match )        else            for m in string.gmatch( match, "[^ \t]+" ) do                table.insert( tWords, m )            end        end        bQuoted = not bQuoted    end    return tWordsend-- Install shell APIfunction shell.run( ... )	local tWords = tokenise( ... )	local sCommand = tWords[1]	if sCommand then		return run( sCommand, unpack( tWords, 2 ) )	end	return falseendfunction shell.exit()    bExit = trueendfunction shell.dir()	return sDirendfunction shell.setDir( _sDir )	sDir = _sDirendfunction shell.path()	return sPathendfunction shell.setPath( _sPath )	sPath = _sPathendfunction shell.resolve( _sPath )	local sStartChar = string.sub( _sPath, 1, 1 )	if sStartChar == "/" or sStartChar == "\\" then		return fs.combine( "", _sPath )	else		return fs.combine( sDir, _sPath )	endendfunction shell.resolveProgram( _sCommand )	-- Substitute aliases firsts	if tAliases[ _sCommand ] ~= nil then		_sCommand = tAliases[ _sCommand ]	end    -- If the path is a global path, use it directly    local sStartChar = string.sub( _sCommand, 1, 1 )    if sStartChar == "/" or sStartChar == "\\" then    	local sPath = fs.combine( "", _sCommand )    	if fs.exists( sPath ) and not fs.isDir( sPath ) then			return sPath    	end		return nil    end     	-- Otherwise, look on the path variable    for sPath in string.gmatch(sPath, "[^:]+") do    	sPath = fs.combine( shell.resolve( sPath ), _sCommand )    	if fs.exists( sPath ) and not fs.isDir( sPath ) then			return sPath    	end    end		-- Not found	return nilendfunction shell.programs( _bIncludeHidden )	local tItems = {}		-- Add programs from the path    for sPath in string.gmatch(sPath, "[^:]+") do    	sPath = shell.resolve( sPath )		if fs.isDir( sPath ) then			local tList = fs.list( sPath )			for n,sFile in pairs( tList ) do				if not fs.isDir( fs.combine( sPath, sFile ) ) and				   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= ".") then					tItems[ sFile ] = true				end			end		end    end		-- Sort and return	local tItemList = {}	for sItem, b in pairs( tItems ) do		table.insert( tItemList, sItem )	end	table.sort( tItemList )	return tItemListendfunction shell.getRunningProgram()	if #tProgramStack > 0 then		return tProgramStack[#tProgramStack]	end	return nilendfunction shell.setAlias( _sCommand, _sProgram )	tAliases[ _sCommand ] = _sProgramendfunction shell.clearAlias( _sCommand )	tAliases[ _sCommand ] = nilendfunction shell.aliases()	-- Add aliases	local tCopy = {}	for sAlias, sCommand in pairs( tAliases ) do		tCopy[sAlias] = sCommand	end	return tCopyendif multishell then    function shell.openTab( ... )        local tWords = tokenise( ... )        local sCommand = tWords[1]        if sCommand then        	local sPath = shell.resolveProgram( sCommand )        	if sPath == "rom/programs/shell" then                return multishell.launch( tEnv, sPath, unpack( tWords, 2 ) )            elseif sPath ~= nil then                return multishell.launch( tEnv, "rom/programs/shell", sPath, unpack( tWords, 2 ) )            else                printError( "No such program" )            end        end    end    function shell.switchTab( nID )        multishell.setFocus( nID )    endendlocal tArgs = { ... }if #tArgs > 0 then    -- "shell x y z"    -- Run the program specified on the commandline    shell.run( ... )else    -- "shell"    -- Print the header    term.setBackgroundColor( bgColour )    term.setTextColour( promptColour )    print( os.version() )    term.setTextColour( textColour )    -- Run the startup program    if parentShell == nil then        shell.run( "/rom/startup" )    end    -- Read commands and execute them    local tCommandHistory = {}    while not bExit do        term.redirect( parentTerm )        term.setBackgroundColor( bgColour )        term.setTextColour( promptColour )        write( shell.dir() .. "> " )        term.setTextColour( textColour )        local sLine = read( nil, tCommandHistory )        table.insert( tCommandHistory, sLine )        shell.run( sLine )    endend`nif term.isColour() then	term.setTextColour( colours.yellow )endprint( "Goodbye" )term.setTextColour( colours.white )sleep( 1 )os.shutdown()`nlocal nTime = os.time()local nDay = os.day()print( "The time is "..textutils.formatTime( nTime, false ).." on Day "..nDay )`nlocal tArgs = { ... }if #tArgs < 1 then	print( "Usage: type <path>" )  	returnendlocal sPath = shell.resolve( tArgs[1] )if fs.exists( sPath ) then	if fs.isDir( sPath ) then		print( "directory" )	else		print( "file" )	endelse	print( "No such path" )end`nlocal tArgs = { ... }if #tArgs > 0 then    shell.openTab( unpack( tArgs ) )else    shell.openTab( "shell" )end`nlocal tArgs = { ... }if #tArgs > 0 then    local nTask = shell.openTab( unpack( tArgs ) )    if nTask then        shell.switchTab( nTask )    endelse    local nTask = shell.openTab( "shell" )    if nTask then        shell.switchTab( nTask )    endend`n-- Setup process switchinglocal parentTerm = term.current()local w,h = parentTerm.getSize()local tProcesses = {}local nCurrentProcess = nillocal nRunningProcess = nillocal bShowMenu = falselocal bWindowsResized = falselocal function selectProcess( n )    if nCurrentProcess ~= n then        if nCurrentProcess then            local tOldProcess = tProcesses[ nCurrentProcess ]            tOldProcess.window.setVisible( false )        end        nCurrentProcess = n        if nCurrentProcess then            local tNewProcess = tProcesses[ nCurrentProcess ]            tNewProcess.window.setVisible( true )            tNewProcess.bInteracted = true        end    endendlocal function setProcessTitle( n, sTitle )    tProcesses[ n ].sTitle = sTitleendlocal function resumeProcess( nProcess, sEvent, ... )    local tProcess = tProcesses[ nProcess ]    local sFilter = tProcess.sFilter    if sFilter == nil or sFilter == sEvent or sEvent == "terminate" then        local nPreviousProcess = nRunningProcess        nRunningProcess = nProcess        term.redirect( tProcess.terminal )        local ok, result = coroutine.resume( tProcess.co, sEvent, ... )        tProcess.terminal = term.current()        if ok then            tProcess.sFilter = result        else            printError( result )        end        nRunningProcess = nPreviousProcess    endendlocal function launchProcess( tProgramEnv, sProgramPath, ... )    local tProgramArgs = { ... }    local nProcess = #tProcesses + 1    local tProcess = {}    tProcess.sTitle = fs.getName( sProgramPath )    if bShowMenu then        tProcess.window = window.create( parentTerm, 1, 2, w, h-1, false )    else        tProcess.window = window.create( parentTerm, 1, 1, w, h, false )    end    tProcess.co = coroutine.create( function()        os.run( tProgramEnv, sProgramPath, unpack( tProgramArgs ) )        if not tProcess.bInteracted then            term.setCursorBlink( false )            print( "Press any key to continue" )            os.pullEvent( "char" )        end    end )    tProcess.sFilter = nil    tProcess.terminal = tProcess.window    tProcess.bInteracted = false    tProcesses[ nProcess ] = tProcess    resumeProcess( nProcess )    return nProcessendlocal function cullProcess( nProcess )    local tProcess = tProcesses[ nProcess ]    if coroutine.status( tProcess.co ) == "dead" then        if nCurrentProcess == nProcess then            selectProcess( nil )        end        table.remove( tProcesses, nProcess )        if nCurrentProcess == nil then            if nProcess > 1 then                selectProcess( nProcess - 1 )            elseif #tProcesses > 0 then                selectProcess( 1 )            end        end        return true    end    return falseendlocal function cullProcesses()    local culled = false    for n=#tProcesses,1,-1 do        culled = culled or cullProcess( n )    end    return culledend-- Setup the main menulocal menuMainTextColor, menuMainBgColor, menuOtherTextColor, menuOtherBgColorif parentTerm.isColor() then    menuMainTextColor, menuMainBgColor = colors.yellow, colors.black    menuOtherTextColor, menuOtherBgColor = colors.black, colors.grayelse    menuMainTextColor, menuMainBgColor = colors.white, colors.black    menuOtherTextColor, menuOtherBgColor = colors.black, colors.whiteendlocal function redrawMenu()    if bShowMenu then        -- Draw menu        parentTerm.setCursorPos( 1, 1 )        parentTerm.setBackgroundColor( menuOtherBgColor )        parentTerm.clearLine()        for n=1,#tProcesses do            if n == nCurrentProcess then                parentTerm.setTextColor( menuMainTextColor )                parentTerm.setBackgroundColor( menuMainBgColor )            else                parentTerm.setTextColor( menuOtherTextColor )                parentTerm.setBackgroundColor( menuOtherBgColor )            end            parentTerm.write( " " .. tProcesses[n].sTitle .. " " )        end        -- Put the cursor back where it should be        local tProcess = tProcesses[ nCurrentProcess ]        if tProcess then            tProcess.window.restoreCursor()        end    endendlocal function resizeWindows()    local windowY, windowHeight    if bShowMenu then        windowY = 2        windowHeight = h-1    else        windowY = 1        windowHeight = h    end    for n=1,#tProcesses do        local tProcess = tProcesses[n]        local window = tProcess.window        local x,y = tProcess.window.getCursorPos()        if y > windowHeight then            tProcess.window.scroll( y - windowHeight )            tProcess.window.setCursorPos( x, windowHeight )        end        tProcess.window.reposition( 1, windowY, w, windowHeight )    end    bWindowsResized = trueendlocal function setMenuVisible( bVis )    if bShowMenu ~= bVis then        bShowMenu = bVis        resizeWindows()        redrawMenu()    endendlocal multishell = {}function multishell.getFocus()    return nCurrentProcessendfunction multishell.setFocus( n )    if n >= 1 and n <= #tProcesses then        selectProcess( n )        redrawMenu()        return true    end    return falseendfunction multishell.getTitle( n )    if n >= 1 and n <= #tProcesses then        return tProcesses[n].sTitle    end    return nilendfunction multishell.setTitle( n, sTitle )    if n >= 1 and n <= #tProcesses then        setProcessTitle( n, sTitle )        redrawMenu()    endendfunction multishell.getCurrent()    return nRunningProcessendfunction multishell.launch( tProgramEnv, sProgramPath, ... )    local previousTerm = term.current()    setMenuVisible( (#tProcesses + 1) >= 2 )    local nResult = launchProcess( tProgramEnv, sProgramPath, ... )    redrawMenu()    term.redirect( previousTerm )    return nResultendfunction multishell.getCount()    return #tProcessesend-- BeginparentTerm.clear()setMenuVisible( false )selectProcess( launchProcess( {    ["shell"] = shell,    ["multishell"] = multishell,}, "/rom/programs/shell" ) )redrawMenu()-- Run processeswhile #tProcesses > 0 do    -- Get the event    local tEventData = { os.pullEventRaw() }    local sEvent = tEventData[1]    if sEvent == "term_resize" then        -- Resize event        w,h = parentTerm.getSize()        resizeWindows()        redrawMenu()    elseif sEvent == "char" or sEvent == "key" or sEvent == "paste" or sEvent == "terminate" then        -- Keyboard event        -- Passthrough to current process        resumeProcess( nCurrentProcess, unpack( tEventData ) )        if cullProcess( nCurrentProcess ) then            setMenuVisible( #tProcesses >= 2 )            redrawMenu()        end    elseif sEvent == "mouse_click" then        -- Click event        local button, x, y = tEventData[2], tEventData[3], tEventData[4]        if bShowMenu and y == 1 then            -- Switch process            local tabStart = 1            for n=1,#tProcesses do                tabEnd = tabStart + string.len( tProcesses[n].sTitle ) + 1                if x >= tabStart and x <= tabEnd then                    selectProcess( n )                    redrawMenu()                    break                end                tabStart = tabEnd + 1            end        else            -- Passthrough to current process            resumeProcess( nCurrentProcess, sEvent, button, x, (bShowMenu and y-1) or y )            if cullProcess( nCurrentProcess ) then                setMenuVisible( #tProcesses >= 2 )                redrawMenu()            end        end    elseif sEvent == "mouse_drag" or sEvent == "mouse_scroll" then        -- Other mouse event        local p1, x, y = tEventData[2], tEventData[3], tEventData[4]        if not (bShowMenu and y == 1) then            -- Passthrough to current process            resumeProcess( nCurrentProcess, sEvent, p1, x, (bShowMenu and y-1) or y )            if cullProcess( nCurrentProcess ) then                setMenuVisible( #tProcesses >= 2 )                redrawMenu()            end        end    else        -- Other event        -- Passthrough to all processes        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event        for n=1,nLimit do            resumeProcess( n, unpack( tEventData ) )        end        if cullProcesses() then            setMenuVisible( #tProcesses >= 2 )            redrawMenu()        end    end    if bWindowsResized then        -- Pass term_resize to all processes        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event        for n=1,nLimit do            resumeProcess( n, "term_resize" )        end        bWindowsResized = false        if cullProcesses() then            setMenuVisible( #tProcesses >= 2 )            redrawMenu()        end    endend-- Shutdownterm.redirect( parentTerm )`n/rom/programs/advanced`nlocal tBiomes = {	"in a forest",	"in a pine forest",	"knee deep in a swamp",	"in a mountain range",	"in a desert",	"in a grassy plain",	"in frozen tundra",}local function hasTrees( _nBiome )	return _nBiome <= 3endlocal function hasStone( _nBiome )	return _nBiome == 4endlocal function hasRivers( _nBiome )	return _nBiome ~= 3 and _nBiome ~= 5endlocal items = {	["no tea"] = {		droppable = false,		desc = "Pull yourself together man.",	},	["a pig"] = {		heavy = true,		creature = true,		drops = { "some pork" },		aliases = { "pig" },		desc = "The pig has a square nose.",	},	["a cow"] = {		heavy = true,		creature = true,		aliases = { "cow" },		desc = "The cow stares at you blankly.",	},	["a sheep"] = {		heavy = true,		creature = true,		hitDrops = { "some wool" },		aliases = { "sheep" },		desc = "The sheep is fluffy.",	},	["a chicken"] = {		heavy = true,		creature = true,		drops = { "some chicken" },		aliases = { "chicken" },		desc = "The chicken looks delicious.",	},	["a creeper"] = {		heavy = true,		creature = true,		monster = true,		aliases = { "creeper" },		desc = "The creeper needs a hug.",	},	["a skeleton"] = {		heavy = true,		creature = true,		monster = true,		aliases = { "skeleton" },		nocturnal = true,		desc = "The head bone's connected to the neck bone, the neck bone's connected to the chest bone, the chest bone's connected to the arm bone, the arm bone's connected to the bow, and the bow is pointed at you.",	},	["a zombie"] = {		heavy = true,		creature = true,		monster = true,		aliases = { "zombie" },		nocturnal = true,		desc = "All he wants to do is eat your brains.",	},	["a spider"] = {		heavy = true,		creature = true,		monster = true,		aliases = { "spider" },		desc = "Dozens of eyes stare back at you.",	},	["a cave entrance"] = {		heavy = true,		aliases = { "cave entance", "cave", "entrance" },		desc = "The entrance to the cave is dark, but it looks like you can climb down.",	},	["an exit to the surface"] = {		heavy = true,		aliases = { "exit to the surface", "exit", "opening" },		desc = "You can just see the sky through the opening.",	},	["a river"] = {		heavy = true,		aliases = { "river" },		desc = "The river flows majestically towards the horizon. It doesn't do anything else.",	},	["some wood"] = {		aliases = { "wood" },		material = true,		desc = "You could easilly craft this wood into planks.",	},	["some planks"] = {		aliases = { "planks", "wooden planks", "wood planks" },		desc = "You could easilly craft these planks into sticks.",	},	["some sticks"] = {		aliases = { "sticks", "wooden sticks", "wood sticks" },		desc = "A perfect handle for torches or a pickaxe.",	},	["a crafting table"] = {		aliases = { "crafting table", "craft table", "work bench", "workbench", "crafting bench", "table", },		desc = "It's a crafting table. I shouldn't tell you this, but these don't actually do anything in this game, you can craft tools whenever you like.",	},	["a furnace"] = {		aliases = { "furnace" },		desc = "It's a furnace. Between you and me, these don't actually do anything in this game.",	},	["a wooden pickaxe"] = {		aliases = { "pickaxe", "pick", "wooden pick", "wooden pickaxe", "wood pick", "wood pickaxe" },		tool = true,		toolLevel = 1,		toolType = "pick",		desc = "The pickaxe looks good for breaking stone and coal.",	},	["a stone pickaxe"] = {		aliases = { "pickaxe", "pick", "stone pick", "stone pickaxe" },		tool = true,		toolLevel = 2,		toolType = "pick",		desc = "The pickaxe looks good for breaking iron.",	},	["an iron pickaxe"] = {		aliases = { "pickaxe", "pick", "iron pick", "iron pickaxe" },		tool = true,		toolLevel = 3,		toolType = "pick",		desc = "The pickaxe looks strong enough to break diamond.",	},	["a diamond pickaxe"] = {		aliases = { "pickaxe", "pick", "diamond pick", "diamond pickaxe" },		tool = true,		toolLevel = 4,		toolType = "pick",		desc = "Best. Pickaxe. Ever.",	},	["a wooden sword"] = {		aliases = { "sword", "wooden sword", "wood sword" },		tool = true,		toolLevel = 1,		toolType = "sword",		desc = "Flimsy, but better than nothing.",	},	["a stone sword"] = {		aliases = { "sword", "stone sword" },		tool = true,		toolLevel = 2,		toolType = "sword",		desc = "A pretty good sword.",	},	["an iron sword"] = {		aliases = { "sword", "iron sword" },		tool = true,		toolLevel = 3,		toolType = "sword",		desc = "This sword can slay any enemy.",	},	["a diamond sword"] = {		aliases = { "sword", "diamond sword" },		tool = true,		toolLevel = 4,		toolType = "sword",		desc = "Best. Sword. Ever.",	},	["a wooden shovel"] = {		aliases = { "shovel", "wooden shovel", "wood shovel" },		tool = true,		toolLevel = 1,		toolType = "shovel",		desc = "Good for digging holes.",	},	["a stone shovel"] = {		aliases = { "shovel", "stone shovel" },		tool = true,		toolLevel = 2,		toolType = "shovel",		desc = "Good for digging holes.",	},	["an iron shovel"] = {		aliases = { "shovel", "iron shovel" },		tool = true,		toolLevel = 3,		toolType = "shovel",		desc = "Good for digging holes.",	},	["a diamond shovel"] = {		aliases = { "shovel", "diamond shovel" },		tool = true,		toolLevel = 4,		toolType = "shovel",		desc = "Good for digging holes.",	},	["some coal"] = {		aliases = { "coal" },		ore = true,		toolLevel = 1,		toolType = "pick",		desc = "That coal looks useful for building torches, if only you had a pickaxe to mine it.",	},	["some dirt"] = {		aliases = { "dirt" },		material = true,		desc = "Why not build a mud hut?",	},	["some stone"] = {		aliases = { "stone", "cobblestone" },		material = true,		ore = true,		infinite = true,		toolLevel = 1,		toolType = "pick",		desc = "Stone is useful for building things, and making stone pickaxes.",	},	["some iron"] = {		aliases = { "iron" },		material = true,		ore = true,		toolLevel = 2,		toolType = "pick",		desc = "That iron looks mighty strong, you'll need a stone pickaxe to mine it.",	},	["some diamond"] = {		aliases = { "diamond", "diamonds" },		material = true,		ore = true,		toolLevel = 3,		toolType = "pick",		desc = "Sparkly, rare, and impossible to mine without an iron pickaxe.",	},	["some torches"] = {		aliases = { "torches", "torch" },		desc = "These won't run out for a while.",	},	["a torch"] = {		aliases = { "torch" },		desc = "Fire, fire, burn so bright, won't you light my cave tonight?",	},	["some wool"] = {		aliases = { "wool" },		material = true,		desc = "Soft and good for building.",	},	["some pork"] = {		aliases = { "pork", "porkchops" },		food = true,		desc = "Delicious and nutricious.",	},	["some chicken"] = {		aliases = { "chicken" },		food = true,		desc = "Finger licking good.",	},}local tAnimals = {	"a pig", "a cow", "a sheep", "a chicken",}local tMonsters = {	"a creeper", "a skeleton", "a zombie", "a spider"}local tRecipes = {	["some planks"] = { "some wood" },	["some sticks"] = { "some planks" },	["some sticks"] = { "some planks" },	["a crafting table"] = { "some planks" },	["a furnace"] = { "some stone" },	["some torches"] = { "some sticks", "some coal" },		["a wooden pickaxe"] = { "some planks", "some sticks" },	["a stone pickaxe"] = { "some stone", "some sticks" },	["an iron pickaxe"] = { "some iron", "some sticks" },	["a diamond pickaxe"] = { "some diamond", "some sticks" },	["a wooden sword"] = { "some planks", "some sticks" },	["a stone sword"] = { "some stone", "some sticks" },	["an iron sword"] = { "some iron", "some sticks" },	["a diamond sword"] = { "some diamond", "some sticks" },	["a wooden shovel"] = { "some planks", "some sticks" },	["a stone shovel"] = { "some stone", "some sticks" },	["an iron shovel"] = { "some iron", "some sticks" },	["a diamond shovel"] = { "some diamond", "some sticks" },}local tGoWest = {	"(life is peaceful there)",	"(lots of open air)",	"(to begin life anew)",	"(this is what we'll do)",	"(sun in winter time)",	"(we will do just fine)",	"(where the skies are blue)",	"(this and more we'll do)",}local nGoWest = 0local bRunning = truelocal tMap = { { {}, }, }local x,y,z = 0,0,0local inventory = {	["no tea"] = items["no tea"],}local nTurn = 0local nTimeInRoom = 0local bInjured = falselocal tDayCycle = {	"It is daytime.",	"It is daytime.",	"It is daytime.",	"It is daytime.",	"It is daytime.",	"It is daytime.",	"It is daytime.",	"It is daytime.",	"The sun is setting.",	"It is night.",	"It is night.",	"It is night.",	"It is night.",	"It is night.",	"The sun is rising.",}local function getTimeOfDay()	return math.fmod( math.floor(nTurn/3), #tDayCycle ) + 1endlocal function isSunny()	return (getTimeOfDay() < 10)endlocal function getRoom( x, y, z, dontCreate )	tMap[x] = tMap[x] or {}	tMap[x][y] = tMap[x][y] or {}	if not tMap[x][y][z] and dontCreate ~= true then 		local room = { 			items = {}, 			exits = {}, 			nMonsters = 0, 		}		tMap[x][y][z] = room				if y == 0 then			-- Room is above ground			-- Pick biome			room.nBiome = math.random( 1, #tBiomes )			room.trees = hasTrees( room.nBiome )					-- Add animals			if math.random(1,3) == 1 then				for n = 1,math.random(1,2) do					local sAnimal = tAnimals[ math.random( 1, #tAnimals ) ]					room.items[ sAnimal ] = items[ sAnimal ]				end			end						-- Add surface ore			if math.random(1,5) == 1 or hasStone( room.nBiome ) then				room.items[ "some stone" ] = items[ "some stone" ]			end			if math.random(1,8) == 1 then				room.items[ "some coal" ] = items[ "some coal" ]			end			if math.random(1,8) == 1 and hasRivers( room.nBiome ) then				room.items[ "a river" ] = items[ "a river" ]			end			-- Add exits			room.exits = {				["north"] = true,				["south"] = true,				["east"] = true,				["west"] = true,			}			if math.random(1,8) == 1 then				room.exits["down"] = true				room.items["a cave entrance"] = items["a cave entrance"]			end								else			-- Room is underground			-- Add exits			local function tryExit( sDir, sOpp, x, y, z )				local adj = getRoom( x, y, z, true )				if adj then					if adj.exits[sOpp] then						room.exits[sDir] = true					end				else					if math.random(1,3) == 1 then						room.exits[sDir] = true					end				end			end						if y == -1 then				local above = getRoom( x, y + 1, z )				if above.exits["down"] then					room.exits["up"] = true					room.items["an exit to the surface"] = items["an exit to the surface"]				end			else				tryExit( "up", "down", x, y + 1, z )			end						if y > -3 then				tryExit( "down", "up", x, y - 1, z )			end						tryExit( "east", "west", x - 1, y, z )			tryExit( "west", "east", x + 1, y, z )			tryExit( "north", "south", x, y, z + 1 )			tryExit( "south", "north", x, y, z - 1 )							-- Add ores			room.items[ "some stone" ] = items[ "some stone" ]			if math.random(1,3) == 1 then				room.items[ "some coal" ] = items[ "some coal" ]			end			if math.random(1,8) == 1 then				room.items[ "some iron" ] = items[ "some iron" ]			end			if y == -3 and math.random(1,15) == 1 then				room.items[ "some diamond" ] = items[ "some diamond" ]			end						-- Turn out the lights			room.dark = true		end	end	return tMap[x][y][z]endlocal function itemize( t )	local item = next( t )	if item == nil then		return "nothing"	end		local text = ""	while item do		text = text .. item				local nextItem = next( t, item )		if nextItem ~= nil then			local nextNextItem = next( t, nextItem )			if nextNextItem == nil then				text = text .. " and "			else				text = text .. ", "			end		end		item = nextItem	end	return textendfunction findItem( _tList, _sQuery )	for sItem, tItem in pairs( _tList ) do		if sItem == _sQuery then			return sItem		end		if tItem.aliases ~= nil then			for n, sAlias in pairs( tItem.aliases ) do				if sAlias == _sQuery then					return sItem				end			end		end	end	return nilendlocal tMatches = {	["wait"] = {		"wait",	},	["look"] = {		"look at the ([%a ]+)",		"look at ([%a ]+)",		"look",		"inspect ([%a ]+)",		"inspect the ([%a ]+)",		"inspect",	},	["inventory"] = {		"check self",		"check inventory",		"inventory",		"i",	},	["go"] = {		"go (%a+)",		"travel (%a+)",		"walk (%a+)",		"run (%a+)",		"go",	},	["dig"] = {		"dig (%a+) using ([%a ]+)",		"dig (%a+) with ([%a ]+)",		"dig (%a+)",		"dig",	},	["take"] = {		"pick up the ([%a ]+)",		"pick up ([%a ]+)",		"pickup ([%a ]+)",		"take the ([%a ]+)",		"take ([%a ]+)",		"take",	},	["drop"] = {		"put down the ([%a ]+)",		"put down ([%a ]+)",		"drop the ([%a ]+)",		"drop ([%a ]+)",		"drop",	},	["place"] = {		"place the ([%a ]+)",		"place ([%a ]+)",		"place",	},	["cbreak"] = {		"punch the ([%a ]+)",		"punch ([%a ]+)",		"punch",		"break the ([%a ]+) with the ([%a ]+)",		"break ([%a ]+) with ([%a ]+) ",		"break the ([%a ]+)",		"break ([%a ]+)",		"break",	},	["mine"] = {		"mine the ([%a ]+) with the ([%a ]+)",		"mine ([%a ]+) with ([%a ]+)",		"mine ([%a ]+)",		"mine",	},	["attack"] = {		"attack the ([%a ]+) with the ([%a ]+)",		"attack ([%a ]+) with ([%a ]+)",		"attack ([%a ]+)",		"attack",		"kill the ([%a ]+) with the ([%a ]+)",		"kill ([%a ]+) with ([%a ]+)",		"kill ([%a ]+)",		"kill",		"hit the ([%a ]+) with the ([%a ]+)",		"hit ([%a ]+) with ([%a ]+)",		"hit ([%a ]+)",		"hit",	},	["craft"] = {		"craft a ([%a ]+)",		"craft some ([%a ]+)",		"craft ([%a ]+)",		"craft",		"make a ([%a ]+)",		"make some ([%a ]+)",		"make ([%a ]+)",		"make",	},	["build"] = {		"build ([%a ]+) out of ([%a ]+)",		"build ([%a ]+) from ([%a ]+)",		"build ([%a ]+)",		"build",	},	["eat"] = {		"eat a ([%a ]+)",		"eat the ([%a ]+)",		"eat ([%a ]+)",		"eat",	},	["help"] = {		"help me",		"help",	},	["exit"] = {		"exit",		"quit",		"goodbye",		"good bye",		"bye",		"farewell",	},}local commands = {}function doCommand( text )	if text == "" then		commands[ "noinput" ]()		return	end		for sCommand, t in pairs( tMatches ) do		for n, sMatch in pairs( t ) do			local tCaptures = { string.match( text, "^" .. sMatch .. "$" ) }			if #tCaptures ~= 0 then				local fnCommand = commands[ sCommand ]				if #tCaptures == 1 and tCaptures[1] == sMatch then					fnCommand()				else					fnCommand( unpack( tCaptures ) )				end				return			end		end	end	commands[ "badinput" ]()endfunction commands.wait()	print( "Time passes..." )endfunction commands.look( _sTarget )	local room = getRoom( x,y,z )	if room.dark then		print( "It is pitch dark." )		return	end	if _sTarget == nil then		-- Look at the world		if y == 0 then			io.write( "You are standing " .. tBiomes[room.nBiome] .. ". " )			print( tDayCycle[ getTimeOfDay() ] )		else			io.write( "You are underground. " )			if next( room.exits ) ~= nil then				print( "You can travel "..itemize( room.exits ).."." )			else				print()			end		end		if next( room.items ) ~= nil then			print( "There is " .. itemize( room.items ) .. " here." )		end		if room.trees then			print( "There are trees here." )		end			else		-- Look at stuff		if room.trees and (_sTarget == "tree" or _sTarget == "trees") then			print( "The trees look easy to break." )		elseif _sTarget == "self" or _sTarget == "myself" then			print( "Very handsome." )		else			local tItem = nil			local sItem = findItem( room.items, _sTarget )			if sItem then				tItem = room.items[sItem]			else				sItem = findItem( inventory, _sTarget )				if sItem then					tItem = inventory[sItem]				end			end						if tItem then				print( tItem.desc or ("You see nothing special about "..sItem..".") )			else				print( "You don't see any ".._sTarget.." here." )			end		end	endendfunction commands.go( _sDir )	local room = getRoom( x,y,z )	if _sDir == nil then		print( "Go where?" )		return	end		if nGoWest ~= nil then		if _sDir == "west" then			nGoWest = nGoWest + 1			if nGoWest > #tGoWest then				nGoWest = 1			end			print( tGoWest[ nGoWest ] )		else			if nGoWest > 0 or nTurn > 6 then				nGoWest = nil			end		end	end		if room.exits[_sDir] == nil then		print( "You can't go that way." )		return	end		if _sDir == "north" then		z = z + 1	elseif _sDir == "south" then		z = z - 1	elseif _sDir == "east" then		x = x - 1	elseif _sDir == "west" then		x = x + 1	elseif _sDir == "up" then		y = y + 1	elseif _sDir == "down" then		y = y - 1	else		print( "I don't understand that direction." )		return	end		nTimeInRoom = 0	doCommand( "look" )endfunction commands.dig( _sDir, _sTool )	local room = getRoom( x,y,z )	if _sDir == nil then		print( "Dig where?" )		return	end		local sTool = nil	local tTool = nil	if _sTool ~= nil then		sTool = findItem( inventory, _sTool )		if not sTool then			print( "You're not carrying a ".._sTool.."." )			return		end		tTool = inventory[ sTool ]	end		local room = getRoom( x, y, z )	local bActuallyDigging = (room.exits[ _sDir ] ~= true)	if bActuallyDigging then		if sTool == nil or tTool.toolType ~= "pick" then			print( "You need to use a pickaxe to dig through stone." )			return		end	end		if _sDir == "north" then		room.exits["north"] = true		z = z + 1		getRoom( x, y, z ).exits["south"] = true	elseif _sDir == "south" then		room.exits["south"] = true		z = z - 1		getRoom( x, y, z ).exits["north"] = true			elseif _sDir == "east" then		room.exits["east"] = true		x = x - 1		getRoom( x, y, z ).exits["west"] = true			elseif _sDir == "west" then		room.exits["west"] = true		x = x + 1		getRoom( x, y, z ).exits["east"] = true			elseif _sDir == "up" then		if y == 0 then			print( "You can't dig that way." )			return		end		room.exits["up"] = true		if y == -1 then			room.items[ "an exit to the surface" ] = items[ "an exit to the surface" ]		end		y = y + 1				room = getRoom( x, y, z )		room.exits["down"] = true		if y == 0 then			room.items[ "a cave entrance" ] = items[ "a cave entrance" ]		end			elseif _sDir == "down" then		if y <= -3 then			print( "You hit bedrock." )			return		end		room.exits["down"] = true		if y == 0 then			room.items[ "a cave entrance" ] = items[ "a cave entrance" ]		end		y = y - 1				room = getRoom( x, y, z )		room.exits["up"] = true		if y == -1 then			room.items[ "an exit to the surface" ] = items[ "an exit to the surface" ]		end			else		print( "I don't understand that direction." )		return	end		--	if bActuallyDigging then		if _sDir == "down" and y == -1 or		   _sDir == "up" and y == 0 then			inventory[ "some dirt" ] = items[ "some dirt" ]			inventory[ "some stone" ] = items[ "some stone" ]			print( "You dig ".._sDir.." using "..sTool.." and collect some dirt and stone." )		else			inventory[ "some stone" ] = items[ "some stone" ]			print( "You dig ".._sDir.." using "..sTool.." and collect some stone." )		end	end		nTimeInRoom = 0	doCommand( "look" )endfunction commands.inventory()	print( "You are carrying " .. itemize( inventory ) .. "." )endfunction commands.drop( _sItem )	if _sItem == nil then		print( "Drop what?" )		return	end		local room = getRoom( x,y,z )	local sItem = findItem( inventory, _sItem )	if sItem then		local tItem = inventory[ sItem ]		if tItem.droppable == false then			print( "You can't drop that." )		else			room.items[ sItem ] = tItem			inventory[ sItem ] = nil			print( "Dropped." )		end	else		print( "You don't have a ".._sItem.."." )	endendfunction commands.place( _sItem )	if _sItem == nil then		print( "Place what?" )		return	end		if _sItem == "torch" or _sItem == "a torch" then		local room = getRoom( x,y,z )		if inventory["some torches"] or inventory["a torch"] then			inventory["a torch"] = nil			room.items["a torch"] = items["a torch"]			if room.dark then				print( "The cave lights up under the torchflame." )				room.dark = false			elseif y == 0 and not isSunny() then				print( "The night gets a little brighter." )			else				print( "Placed." )			end		else			print( "You don't have torches." )		end		return	end		commands.drop( _sItem )endfunction commands.take( _sItem )	if _sItem == nil then		print( "Take what?" )		return	end	local room = getRoom( x,y,z )	local sItem = findItem( room.items, _sItem )	if sItem then		local tItem = room.items[ sItem ]		if tItem.heavy == true then			print( "You can't carry "..sItem.."." )		elseif tItem.ore == true then			print( "You need to mine this ore." )		else			if tItem.infinite ~= true then				room.items[ sItem ] = nil			end			inventory[ sItem ] = tItem						if inventory["some torches"] and inventory["a torch"] then				inventory["a torch"] = nil			end			if sItem == "a torch" and y < 0 then				room.dark = true				print( "The cave plunges into darkness." )			else				print( "Taken." )			end		end	else		print( "You don't see a ".._sItem.." here." )	endendfunction commands.mine( _sItem, _sTool )	if _sItem == nil then		print( "Mine what?" )		return	end	if _sTool == nil then		print( "Mine ".._sItem.." with what?" )		return	end		commands.cbreak( _sItem, _sTool )endfunction commands.attack( _sItem, _sTool )	if _sItem == nil then		print( "Attack what?" )		return	end	commands.cbreak( _sItem, _sTool )endfunction commands.cbreak( _sItem, _sTool )	if _sItem == nil then		print( "Break what?" )		return	end		local sTool = nil	if _sTool ~= nil then		sTool = findItem( inventory, _sTool )		if sTool == nil then			print( "You're not carrying a ".._sTool.."." )			return		end	end	local room = getRoom( x,y,z )	if _sItem == "tree" or _sItem == "trees" or _sItem == "a tree" then		print( "The tree breaks into blocks of wood, which you pick up." )		inventory[ "some wood" ] = items[ "some wood" ]		return	elseif _sItem == "self" or _sItem == "myself" then		if term.isColour() then			term.setTextColour( colours.red )		end		print( "You have died." )		print( "Score: &e0" )		term.setTextColour( colours.white )		bRunning = false		return	end		local sItem = findItem( room.items, _sItem )	if sItem then		local tItem = room.items[ sItem ]		if tItem.ore == true then			-- Breaking ore			if not sTool then				print( "You need a tool to break this ore." )				return			end			local tTool = inventory[ sTool ]			if tTool.tool then				if tTool.toolLevel < tItem.toolLevel then					print( sTool .." is not strong enough to break this ore." )				elseif tTool.toolType ~= tItem.toolType then					print( "You need a different kind of tool to break this ore." )				else					print( "The ore breaks, dropping "..sItem..", which you pick up." )					inventory[ sItem ] = items[ sItem ]					if tItem.infinite ~= true then						room.items[ sItem ] = nil					end				end			else				print( "You can't break "..sItem.." with "..sTool..".")			end					elseif tItem.creature == true then			-- Fighting monsters (or pigs)			local toolLevel = 0			local tTool = nil			if sTool then				tTool = inventory[ sTool ]				if tTool.toolType == "sword" then					toolLevel = tTool.toolLevel				end			end									local tChances = { 0.2, 0.4, 0.55, 0.8, 1 }			if math.random() <= tChances[ toolLevel + 1 ] then				room.items[ sItem ] = nil				print( "The "..tItem.aliases[1].." dies." )					if tItem.drops then					for n, sDrop in pairs( tItem.drops ) do						if not room.items[sDrop] then							print( "The "..tItem.aliases[1].." dropped "..sDrop.."." )							room.items[sDrop] = items[sDrop]						end					end				end								if tItem.monster then					room.nMonsters = room.nMonsters - 1				end			else				print( "The "..tItem.aliases[1].." is injured by your blow." )			end						if tItem.hitDrops then				for n, sDrop in pairs( tItem.hitDrops ) do					if not room.items[sDrop] then						print( "The "..tItem.aliases[1].." dropped "..sDrop.."." )						room.items[sDrop] = items[sDrop]					end				end			end				else			print( "You can't break "..sItem.."." )		end	else		print( "You don't see a ".._sItem.." here." )	endendfunction commands.craft( _sItem )	if _sItem == nil then		print( "Craft what?" )		return	end		if _sItem == "computer" or _sItem == "a computer" then		print( "By creating a computer in a computer in a computer, you tear a hole in the spacetime continuum from which no mortal being can escape." )		if term.isColour() then			term.setTextColour( colours.red )		end		print( "You have died." )		print( "Score: &e0" )		term.setTextColour( colours.white )		bRunning = false		return	end		local room = getRoom( x,y,z )	local sItem = findItem( items, _sItem )	local tRecipe = (sItem and tRecipes[ sItem ]) or nil	if tRecipe then		for n,sReq in ipairs( tRecipe ) do			if inventory[sReq] == nil then				print( "You don't have the items you need to craft "..sItem.."." )				return			end		end				for n,sReq in ipairs( tRecipe ) do			inventory[sReq] = nil		end		inventory[ sItem ] = items[ sItem ]		if inventory["some torches"] and inventory["a torch"] then			inventory["a torch"] = nil		end		print( "Crafted." )	else		print( "You don't know how to make "..(sItem or _sItem).."." )	end	endfunction commands.build( _sThing, _sMaterial )	if _sThing == nil then		print( "Build what?" )		return	end			local sMaterial = nil	if _sMaterial == nil then		for sItem, tItem in pairs( inventory ) do			if tItem.material then				sMaterial = sItem				break			end		end		if sMaterial == nil then			print( "You don't have any building materials." )			return		end	else		sMaterial = findItem( inventory, _sMaterial )		if not sMaterial then			print( "You don't have any ".._sMaterial )			return		end				if inventory[sMaterial].material ~= true then			print( sMaterial.." is not a good building material." )			return		end	end		local alias = nil	if string.sub(_sThing, 1, 1) == "a" then		alias = string.match( _sThing, "a ([%a ]+)" )	end		local room = getRoom( x,y,z )	inventory[sMaterial] = nil	room.items[ _sThing ] = {		heavy = true,		aliases = { alias },		desc = "As you look at your creation (made from "..sMaterial.."), you feel a swelling sense of pride.",	}	print( "Your construction is complete." )endfunction commands.help()	local sText = 		"Welcome to adventure, the greatest text adventure game on CraftOS. " ..		"To get around the world, type actions, and the adventure will " ..		"be read back to you. The actions availiable to you are go, look, inspect, inventory, " ..		"take, drop, place, punch, attack, mine, dig, craft, build, eat and exit."	print( sText )endfunction commands.eat( _sItem )	if _sItem == nil then		print( "Eat what?" )		return	end	local sItem = findItem( inventory, _sItem )	if not sItem then		print( "You don't have any ".._sItem.."." )		return	end		local tItem = inventory[sItem]	if tItem.food then		print( "That was delicious!" )		inventory[sItem] = nil				if bInjured then			print( "You are no longer injured." )			bInjured = false		end	else		print( "You can't eat "..sItem.."." )	endendfunction commands.exit()	bRunning = falseendfunction commands.badinput()	local tResponses = {		"I don't understand.",		"I don't understand you.",		"You can't do that.",		"Nope.",		"Huh?",		"Say again?",		"That's crazy talk.",		"Speak clearly.",		"I'll think about it.",		"Let me get back to you on that one.",		"That doesn't make any sense.",		"What?",	}	print( tResponses[ math.random(1,#tResponses) ] )endfunction commands.noinput()	local tResponses = {		"Speak up.",		"Enunciate.",		"Project your voice.",		"Don't be shy.",		"Use your words.",	}	print( tResponses[ math.random(1,#tResponses) ] )endlocal function simulate()	local bNewMonstersThisRoom = false		-- Spawn monsters in nearby rooms	for sx = -2,2 do		for sy = -1,1 do			for sz = -2,2 do				local h = y + sy				if h >= -3 and h <= 0 then					local room = getRoom( x + sx, h, z + sz )										-- Spawn monsters					if room.nMonsters < 2 and					   ((h == 0 and not isSunny() and not room.items["a torch"]) or room.dark) and					   math.random(1,6) == 1 then					   						local sMonster = tMonsters[ math.random(1,#tMonsters) ]						if room.items[ sMonster ] == nil then					   		room.items[ sMonster ] = items[ sMonster ]					   		room.nMonsters = room.nMonsters + 1					   							   		if sx == 0 and sy == 0 and sz == 0 and not room.dark then					   			print( "From the shadows, "..sMonster.." appears." )					   			bNewMonstersThisRoom = true					   		end						end						end										-- Burn monsters					if h == 0 and isSunny() then						for n,sMonster in ipairs( tMonsters ) do							if room.items[sMonster] and items[sMonster].nocturnal then								room.items[sMonster] = nil						   		if sx == 0 and sy == 0 and sz == 0 and not room.dark then						   			print( "With the sun high in the sky, the "..items[sMonster].aliases[1].." bursts into flame and dies." )						   		end						   		room.nMonsters = room.nMonsters - 1						   	end						end					end					end			end		end	end	-- Make monsters attack	local room = getRoom( x, y, z )	if nTimeInRoom >= 2 and not bNewMonstersThisRoom then		for n,sMonster in ipairs( tMonsters ) do			if room.items[sMonster] then				if math.random(1,4) == 1 and				   not (y == 0 and isSunny() and (sMonster == "a spider")) then					if sMonster == "a creeper" then						if room.dark then							print( "A creeper explodes." )						else							print( "The creeper explodes." )						end						room.items[sMonster] = nil						room.nMonsters = room.nMonsters - 1					else						if room.dark then							print( "A "..items[sMonster].aliases[1].." attacks you." )						else							print( "The "..items[sMonster].aliases[1].." attacks you." )						end					end										if bInjured then						if term.isColour() then							term.setTextColour( colours.red )						end						print( "You have died." )						print( "Score: &e0" )						term.setTextColour( colours.white )						bRunning = false						return					else						bInjured = true					end										break				end			end		end	end		-- Always print this	if bInjured then		if term.isColour() then			term.setTextColour( colours.red )		end		print( "You are injured." )		term.setTextColour( colours.white )	end		-- Advance time	nTurn = nTurn + 1	nTimeInRoom = nTimeInRoom + 1enddoCommand( "look" )simulate()local tCommandHistory = {}while bRunning do	if term.isColour() then		term.setTextColour( colours.yellow )	end    write( "? " )	term.setTextColour( colours.white )		    local sRawLine = read( nil, tCommandHistory )    table.insert( tCommandHistory, sRawLine )        local sLine = nil	for match in string.gmatch(sRawLine, "%a+") do		if sLine then			sLine = sLine .. " " .. string.lower(match)		else			sLine = string.lower(match)		end	end		doCommand( sLine or "" )    if bRunning then	    simulate()	endend`nlocal tArgs = { ... }local function printUsage()	print( "Usages:")	print( "dj play" )	print( "dj play <drive>" )	print( "dj stop" )endif #tArgs > 2 then	printUsage()	returnendlocal sCommand = tArgs[1]if sCommand == "stop" then	-- Stop audio	disk.stopAudio()elseif sCommand == "play" or sCommand == nil then	-- Play audio	local sName = tArgs[2]	if sName == nil then		-- No disc specified, pick one at random		local tNames = {}		for n,sName in ipairs( peripheral.getNames() ) do			if disk.isPresent( sName ) and disk.hasAudio( sName ) then				table.insert( tNames, sName )			end		end		if #tNames == 0 then			print( "No Music Discs in attached disk drives" )			return		end		sName = tNames[ math.random(1,#tNames) ]	end	-- Play the disc	if disk.isPresent( sName ) and disk.hasAudio( sName ) then		print( "Playing "..disk.getAudioTitle( sName ) )		disk.playAudio( sName )	else		print( "No Music Disc in disk drive: "..sName )		return	end	else	printUsage()	end`nif term.isColour() then	term.setTextColour( 2^math.random(0,15) )endtextutils.slowPrint( "Hello World!" )term.setTextColour( colours.white )`n-- Display the start screenlocal w,h = term.getSize()local titleColour, headingColour, textColour, wormColour, fruitColourif term.isColour() then    titleColour = colours.red	headingColour = colours.yellow	textColour = colours.white	wormColour = colours.green	fruitColour = colours.redelse    titleColour = colours.white	headingColour = colours.white	textColour = colours.white	wormColour = colours.white	fruitColour = colours.whiteendfunction printCentred( y, s )	local x = math.floor((w - string.len(s)) / 2)	term.setCursorPos(x,y)	--term.clearLine()	term.write( s )endlocal xVel,yVel = 1,0local xPos, yPos = math.floor(w/2), math.floor(h/2)local pxVel, pyVel = nil, nillocal nLength = 1local nExtraLength = 6local bRunning = truelocal tailX,tailY = xPos,yPoslocal nScore = 0local nDifficulty = 2local nSpeed, nInterval-- Setup the screenlocal screen = {}for x=1,w do	screen[x] = {}	for y=1,h do		screen[x][y] = {}	endendscreen[xPos][yPos] = { snake = true }local nFruit = 1local tFruits = {	"A", "B", "C", "D", "E", "F", "G", "H",	"I", "J", "K", "L", "M", "N", "O", "P",	"Q", "R", "S", "T", "U", "V", "W", "X",	"Y", "Z",	"a", "b", "c", "d", "e", "f", "g", "h",	"i", "j", "k", "l", "m", "n", "o", "p",	"q", "r", "s", "t", "u", "v", "w", "x",	"y", "z",	"1", "2", "3", "4", "5", "6", "7", "8", "9", "0",	"@", "$", "%", "#", "&", "!", "?", "+", "*", "~"}local function addFruit()	while true do		local x = math.random(1,w)		local y = math.random(2,h)		local fruit = screen[x][y]		if fruit.snake == nil and fruit.wall == nil and fruit.fruit == nil then			screen[x][y] = { fruit = true }			term.setCursorPos(x,y)			term.setBackgroundColour( fruitColour )			term.write(" ")			term.setBackgroundColour( colours.black )			break		end	end		nFruit = nFruit + 1	if nFruit > #tFruits then		nFruit = 1	endendlocal function drawMenu()	term.setTextColour( headingColour )	term.setCursorPos(1,1)	term.write( "SCORE " )		term.setTextColour( textColour )	term.setCursorPos(7,1)	term.write( tostring(nScore) )	term.setTextColour( headingColour )	term.setCursorPos(w-11,1)	term.write( "DIFFICULTY ")	term.setTextColour( textColour )	term.setCursorPos(w,1)	term.write( tostring(nDifficulty or "?") ) 	term.setTextColour( colours.white )endlocal function update( )	local x,y = xPos,yPos	if pxVel and pyVel then		xVel, yVel = pxVel, pyVel		pxVel, pyVel = nil, nil	end	-- Remove the tail	if nExtraLength == 0 then		local tail = screen[tailX][tailY]		screen[tailX][tailY] = {}		term.setCursorPos(tailX,tailY)		term.write(" ")		tailX = tail.nextX		tailY = tail.nextY	else		nExtraLength = nExtraLength - 1	end		-- Update the head	local head = screen[xPos][yPos]	local newXPos = xPos + xVel	local newYPos = yPos + yVel	if newXPos < 1 then		newXPos = w	elseif newXPos > w then		newXPos = 1	end	if newYPos < 2 then		newYPos = h	elseif newYPos > h then		newYPos = 2	end		local newHead = screen[newXPos][newYPos]	term.setCursorPos(1,1);	print( newHead.snake )	if newHead.snake == true or newHead.wall == true then		bRunning = false			else		if newHead.fruit == true then			nScore = nScore + 10			nExtraLength = nExtraLength + 1			addFruit()		end		xPos = newXPos		yPos = newYPos		head.nextX = newXPos		head.nextY = newYPos		screen[newXPos][newYPos] = { snake = true }			end		term.setCursorPos(xPos,yPos)	term.setBackgroundColour( wormColour )	term.write(" ")	term.setBackgroundColour( colours.black )	drawMenu()end-- Display the frontendterm.clear()local function drawFrontend()	--term.setTextColour( titleColour )    --printCentred( math.floor(h/2) - 4, " W O R M " )	term.setTextColour( headingColour )	printCentred( math.floor(h/2) - 3, "" )	printCentred( math.floor(h/2) - 2, " SELECT DIFFICULTY " )	printCentred( math.floor(h/2) - 1, "" )		printCentred( math.floor(h/2) + 0, "            " )	printCentred( math.floor(h/2) + 1, "            " )	printCentred( math.floor(h/2) + 2, "            " )	printCentred( math.floor(h/2) - 1 + nDifficulty, " [        ] " )	term.setTextColour( textColour )	printCentred( math.floor(h/2) + 0, "EASY" )	printCentred( math.floor(h/2) + 1, "MEDIUM" )	printCentred( math.floor(h/2) + 2, "HARD" )	printCentred( math.floor(h/2) + 3, "" )	term.setTextColour( colours.white )enddrawMenu()drawFrontend()while true do	local e,key = os.pullEvent( "key" )	if key == keys.up or key == keys.w then		-- Up		if nDifficulty > 1 then			nDifficulty = nDifficulty - 1			drawMenu()			drawFrontend()		end	elseif key == keys.down or key == keys.s then		-- Down		if nDifficulty < 3 then			nDifficulty = nDifficulty + 1			drawMenu()			drawFrontend()		end	elseif key == keys.enter then		-- Enter		break	endendlocal tSpeeds = { 5, 10, 25 }nSpeed = tSpeeds[nDifficulty]nInterval = 1 / nSpeed-- Grow the snake to its intended sizeterm.clear()drawMenu()screen[tailX][tailY].snake = truewhile nExtraLength > 0 do	update()endaddFruit()addFruit()-- Play the gamelocal timer = os.startTimer(0)while bRunning do	local event, p1, p2 = os.pullEvent()	if event == "timer" and p1 == timer then		timer = os.startTimer(nInterval)		update( false )		elseif event == "key" then		local key = p1		if key == keys.up or key == keys.w then			-- Up			if yVel == 0 then				pxVel,pyVel = 0,-1			end		elseif key == keys.down or key == keys.s then			-- Down			if yVel == 0 then				pxVel,pyVel = 0,1			end		elseif key == keys.left or key == keys.a then			-- Left			if xVel == 0 then				pxVel,pyVel = -1,0			end				elseif key == keys.right or key == keys.d then			-- Right			if xVel == 0 then				pxVel,pyVel = 1,0			end				end		endend-- Display the gameover screenterm.setTextColour( headingColour )printCentred( math.floor(h/2) - 2, "                   " )printCentred( math.floor(h/2) - 1, " G A M E   O V E R " )term.setTextColour( textColour )printCentred( math.floor(h/2) + 0, "                 " )printCentred( math.floor(h/2) + 1, " FINAL SCORE "..nScore.." " )printCentred( math.floor(h/2) + 2, "                 " )term.setTextColour( colours.white )local timer = os.startTimer(2.5)repeat	local e,p = os.pullEvent()	if e == "timer" and p == timer then		term.setTextColour( textColour )		printCentred( math.floor(h/2) + 2, " PRESS ANY KEY " )		printCentred( math.floor(h/2) + 3, "               " )		term.setTextColour( colours.white )	enduntil e == "char"term.clear()term.setCursorPos(1,1)		`n-- Paint created by nitrogenfingers (edited by dan200)-- http://www.youtube.com/user/NitrogenFingers-------------- Fields ---------------- The width and height of the terminallocal w,h = term.getSize()-- The selected colours on the left and right mouse button, and the colour of the canvaslocal leftColour, rightColour = colours.white, nillocal canvasColour = colours.black-- The values stored in the canvaslocal canvas = {}-- The menu optionslocal mChoices = { "Save","Exit" }-- The message displayed in the footer barlocal fMessage = "Press Ctrl to access menu"--------------------------- Initialisation ----------------------------- Determine if we can even run thisif not term.isColour() then	print("Requires an Advanced Computer")	returnend-- Determines if the file exists, and can be edited on this computerlocal tArgs = {...}if #tArgs == 0 then	print("Usage: paint <path>")	returnendlocal sPath = shell.resolve(tArgs[1])local bReadOnly = fs.isReadOnly(sPath)if fs.exists(sPath) and fs.isDir(sPath) then	print("Cannot edit a directory.")	returnend----------------- Functions -----------------local function getCanvasPixel( x, y )    if canvas[y] then        return canvas[y][x]    end    return nilend--[[	Converts a colour value to a text character	params: colour = the number to convert to a hex value	returns: a string representing the chosen colour]]local function getCharOf( colour )	-- Incorrect values always convert to nil	if type(colour) == "number" then		local value = math.floor( math.log(colour) / math.log(2) ) + 1		if value >= 1 and value <= 16 then			return string.sub( "0123456789abcdef", value, value )		end	end	return " "end	--[[	Converts a text character to colour value	params: char = the char (from string.byte) to convert to number	returns: the colour number of the hex value]]local tColourLookup = {}for n=1,16 do	tColourLookup[ string.byte( "0123456789abcdef",n,n ) ] = 2^(n-1)endlocal function getColourOf( char )	-- Values not in the hex table are transparent (canvas coloured)	return tColourLookup[char]end--[[ 	Loads the file into the canvas	params: path = the path of the file to open	returns: nil]]local function load(path)	-- Load the file	if fs.exists(path) then		local file = fs.open(sPath, "r")		local sLine = file.readLine()		while sLine do			local line = {}			for x=1,w-2 do				line[x] = getColourOf( string.byte(sLine,x,x) )			end			table.insert( canvas, line )			sLine = file.readLine()		end		file.close()	endend--[[  	Saves the current canvas to file  	params: path = the path of the file to save	returns: true if save was successful, false otherwise]]local function save(path)    -- Open file	local sDir = string.sub(sPath, 1, #sPath - #fs.getName(sPath))	if not fs.exists(sDir) then		fs.makeDir(sDir)	end	local file = fs.open( path, "w" )	if not file then	    return false	end    -- Encode (and trim)	local tLines = {}	local nLastLine = 0	for y=1,h-1 do	    local sLine = ""	    local nLastChar = 0		for x=1,w-2 do		    local c = getCharOf( getCanvasPixel( x, y ) )		    sLine = sLine .. c		    if c ~= " " then		        nLastChar = x		    end		end		sLine = string.sub( sLine, 1, nLastChar )		tLines[y] = sLine		if string.len( sLine ) > 0 then		    nLastLine = y		end	end    -- Save out	for n=1,nLastLine do   	    file.writeLine( tLines[ n ] )	end	file.close()	return trueend--[[  	Draws colour picker sidebar, the pallette and the footer	returns: nil]]local function drawInterface()	-- Footer	term.setCursorPos(1, h)	term.setBackgroundColour(colours.black)	term.setTextColour(colours.yellow)	term.clearLine()	term.write(fMessage)		-- Colour Picker	for i=1,16 do		term.setCursorPos(w-1, i)		term.setBackgroundColour( 2^(i-1) )		term.write("  ")	end	term.setCursorPos(w-1, 17)	term.setBackgroundColour( canvasColour )	term.setTextColour( colours.grey )	term.write("XX")				-- Left and Right Selected Colours	for i=18,18 do		term.setCursorPos(w-1, i)		if leftColour ~= nil then			term.setBackgroundColour( leftColour )			term.write(" ")		else			term.setBackgroundColour( canvasColour )			term.setTextColour( colours.grey )			term.write("X")		end		if rightColour ~= nil then			term.setBackgroundColour( rightColour )			term.write(" ")		else			term.setBackgroundColour( canvasColour )			term.setTextColour( colours.grey )			term.write("X")		end	end	-- Padding	term.setBackgroundColour( canvasColour )	for i=20,h-1 do		term.setCursorPos(w-1, i)		term.write("  ")	endend--[[  	Converts a single pixel of a single line of the canvas and draws it	returns: nil]]local function drawCanvasPixel( x, y )	local pixel = getCanvasPixel( x, y )	if pixel then		term.setBackgroundColour( pixel or canvasColour )		term.setCursorPos(x, y)		term.write(" ")	else		term.setBackgroundColour( canvasColour )		term.setTextColour( colours.grey )		term.setCursorPos(x, y)        term.write("-")	endend--[[  	Converts each colour in a single line of the canvas and draws it	returns: nil]]local function drawCanvasLine( y )	for x = 1, w-2 do		drawCanvasPixel( x, y )	endend--[[  	Converts each colour in the canvas and draws it	returns: nil]]local function drawCanvas()	for y = 1, h-1 do		drawCanvasLine( y )	endend--[[	Draws menu options and handles input from within the menu.	returns: true if the program is to be exited; false otherwise]]local function accessMenu()	-- Selected menu option	local selection = 1		term.setBackgroundColour(colours.black)	while true do		-- Draw the menu		term.setCursorPos(1,h)		term.clearLine()		term.setTextColour(colours.white)		for k,v in pairs(mChoices) do			if selection==k then 				term.setTextColour(colours.yellow)				local ox,_ = term.getCursorPos()				term.write("["..string.rep(" ",#v).."]")				term.setCursorPos(ox+1,h)				term.setTextColour(colours.white)				term.write(v)				term.setCursorPos(term.getCursorPos()+1,h)			else				term.write(" "..v.." ")			end		end				-- Handle input in the menu		local id,key = os.pullEvent("key")		if id == "key" then			-- S and E are shortcuts			if key == keys.s then				selection = 1				key = keys.enter			elseif key == keys.e then				selection = 2				key = keys.enter			end					if key == keys.right then				-- Move right				selection = selection + 1				if selection > #mChoices then					selection = 1				end							elseif key == keys.left and selection > 1 then				-- Move left				selection = selection - 1				if selection < 1 then					selection = #mChoices				end							elseif key == keys.enter then				-- Select an option				if mChoices[selection]=="Save" then 					if bReadOnly then 						fMessage = "Access Denied"						return false					end					local success = save(sPath)					if success then						fMessage = "Saved to "..sPath					else						fMessage = "Error saving to "..sPath					end					return false				elseif mChoices[selection]=="Exit" then 					return true				end			elseif key == keys.leftCtrl or keys == keys.rightCtrl then				-- Cancel the menu				return false 			end		end	endend--[[  	Runs the main thread of execution. Draws the canvas and interface, and handles	mouse and key events.	returns: nil]]local function handleEvents()	local programActive = true	while programActive do		local id,p1,p2,p3 = os.pullEvent()		if id=="mouse_click" or id=="mouse_drag" then			if p2 >= w-1 and p3 >= 1 and p3 <= 17 then				if id ~= "mouse_drag" then					-- Selecting an items in the colour picker					if p3 <= 16 then						if p1==1 then							leftColour = 2^(p3-1)						else							rightColour = 2^(p3-1)						end					else						if p1==1 then							leftColour = nil						else							rightColour = nil						end					end					--drawCanvas()					drawInterface()				end			elseif p2 < w-1 and p3 <= h-1 then				-- Clicking on the canvas				local paintColour = nil				if p1==1 then					paintColour = leftColour				elseif p1==2 then					paintColour = rightColour				end				if not canvas[p3] then                    canvas[p3] = {}    			end                canvas[p3][p2] = paintColour				drawCanvasPixel( p2, p3 )			end		elseif id=="key" then			if p1==keys.leftCtrl or p1==keys.rightCtrl then				programActive = not accessMenu()				drawInterface()			end		elseif id=="term_resize" then		    w,h = term.getSize()            drawCanvas()            drawInterface()        end	endend-- Initload(sPath)drawCanvas()drawInterface()-- Main loophandleEvents()-- Shutdownterm.setBackgroundColour(colours.black)term.setTextColour(colours.white)term.clear()term.setCursorPos(1,1)`n--CCRedirection by : RamiLego4Game and Dan200----Based on Redirection by Dan200: http://www.redirectiongame.com----Clearing Screen----Vars--local TermW,TermH = term.getSize()local sLevelTitlelocal tScreenlocal oScreenlocal SizeW,SizeHlocal aExitslocal fExitlocal nSpeedlocal Speedlocal fSpeedlocal fSpeedSlocal bPausedlocal Ticklocal Blockslocal XOrgin,YOrginlocal function reset()    sLevelTitle = ""    tScreen = {}    oScreen = {}    SizeW,SizeH = TermW,TermH    aExits = 0    fExit = "nop"    nSpeed = 0.6    Speed = nSpeed    fSpeed = 0.2    fSpeedS = false    bPaused = false    Tick = os.startTimer(Speed)    Blocks = 0    XOrgin,YOrgin = 1,1    term.setBackgroundColor(colors.black)    term.setTextColor(colors.white)    term.clear()endlocal InterFace = {}InterFace.cExit = colors.redInterFace.cSpeedD = colors.whiteInterFace.cSpeedA = colors.redInterFace.cTitle = colors.redlocal cG = colors.lightGraylocal cW = colors.graylocal cS = colors.blacklocal cR1 = colors.bluelocal cR2 = colors.redlocal cR3 = colors.greenlocal cR4 = colors.yellowlocal tArgs = { ... }--Functions--local function printCentred( yc, stg )	local xc = math.floor((TermW - string.len(stg)) / 2) + 1	term.setCursorPos(xc,yc)	term.write( stg )endlocal function centerOrgin()	XOrgin = math.floor((TermW/2)-(SizeW/2))	YOrgin = math.floor((TermH/2)-(SizeH/2))endlocal function reMap()	tScreen = nil	tScreen = {}	for x=1,SizeW do		tScreen[x] = {}		for y=1,SizeH do			tScreen[x][y] = { space = true, wall = false, ground = false, robot = "zz", start = "zz", exit = "zz" }		end	endendlocal function tablecopy(t)  local t2 = {}  for k,v in pairs(t) do    t2[k] = v  end  return t2endlocal function buMap()	oScreen = nil	oScreen = {}	for x=1,SizeW do		oScreen[x] = {}		for y=1,SizeH do			oScreen[x][y] = tablecopy(tScreen[x][y])		end	endendlocal function addRobot(x,y,side,color)	local obj = tScreen[x][y]	local data = side..color	if obj.wall == nil and obj.robot == nil then		tScreen[x][y].robot = data	else		obj.wall = nil		obj.robot = "zz"		tScreen[x][y].robot = data	endendlocal function addStart(x,y,side,color)	local obj = tScreen[x][y]	local data = side..color	if obj.wall == nil and obj.space == nil then		tScreen[x][y].start = data	else		obj.wall = nil		obj.space = nil		tScreen[x][y].start = data	end	aExits = aExits+1endlocal function addGround(x,y)	local obj = tScreen[x][y]	if obj.space == nil and obj.exit == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then		tScreen[x][y].ground = true	else		obj.space = nil		obj.exit = "zz"		obj.wall = nil		obj.robot = "zz"		obj.start = "zz"		tScreen[x][y].ground = true	endendlocal function addExit(x,y,cl)	local obj = tScreen[x][y]	if obj.space == nil and obj.ground == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then		tScreen[x][y].exit = cl	else		obj.space = nil		obj.ground = nil		obj.wall = nil		obj.robot = "zz"		obj.start = "zz"		tScreen[x][y].exit = cl	endendlocal function addWall(x,y)	local obj = tScreen[x][y]	if obj == nil then		return error("Here X"..x.." Y"..y)	end	if obj.space == nil and obj.exit == nil and obj.ground == nil and obj.robot == nil and obj.start == nil then		tScreen[x][y].wall = true	else		obj.space = nil		obj.exit = nil		obj.ground = nil		obj.robot = nil		obj.start = nil		tScreen[x][y].wall = true	endendlocal function loadLevel(nNum)    sLevelTitle = "Level "..nNum	if nNum == nil then return error("nNum == nil") end	local sDir = fs.getDir( shell.getRunningProgram() )	local sLevelD = sDir .. "/levels/" .. tostring(nNum)	if not ( fs.exists(sLevelD) or fs.isDir(sLevelD) ) then return error("Level Not Exists : "..sLevelD) end	fLevel = fs.open(sLevelD,"r")	local Line = 0	local wl = true	Blocks = tonumber(string.sub(fLevel.readLine(),1,1))	local xSize = string.len(fLevel.readLine())+2	local Lines = 3	while wl do		local wLine = fLevel.readLine()		if wLine == nil then			fLevel.close()			wl = false		else    	    xSize = math.max(string.len(wLine)+2,xSize)			Lines = Lines + 1		end	end	SizeW,SizeH = xSize,Lines	reMap()	fLevel = fs.open(sLevelD,"r")	fLevel.readLine()	for Line=2,Lines-1 do		sLine = fLevel.readLine()		local chars = string.len(sLine)		for char = 1, chars do			local el = string.sub(sLine,char,char)			if el == "8" then				addGround(char+1,Line)			elseif el == "0" then				addStart(char+1,Line,"a","a")			elseif el == "1" then				addStart(char+1,Line,"b","a")			elseif el == "2" then				addStart(char+1,Line,"c","a")			elseif el == "3" then				addStart(char+1,Line,"d","a")			elseif el == "4" then				addStart(char+1,Line,"a","b")			elseif el == "5" then				addStart(char+1,Line,"b","b")			elseif el == "6" then				addStart(char+1,Line,"c","b")			elseif el == "9" then				addStart(char+1,Line,"d","b")			elseif el == "b" then				addExit(char+1,Line,"a")			elseif el == "e" then				addExit(char+1,Line,"b")			elseif el == "7" then				addWall(char+1,Line)			end		end	end	fLevel.close()endlocal function drawStars()	--CCR Background By : RamiLego--	local cStar,cStarG,crStar,crStarB = colors.lightGray,colors.gray,".","*"	local DStar,BStar,nStar,gStar = 14,10,16,3	local TermW,TermH = term.getSize()    term.clear()    term.setCursorPos(1,1)	for x=1,TermW do		for y=1,TermH do			local StarT = math.random(1,30)			if StarT == DStar then				term.setCursorPos(x,y)				term.setTextColor(cStar)				write(crStar)			elseif StarT == BStar then				term.setCursorPos(x,y)				term.setTextColor(cStar)				write(crStarB)			elseif StarT == nStar then				term.setCursorPos(x,y)				term.setTextColor(cStarG)				write(crStar)			elseif StarT == gStar then				term.setCursorPos(x,y)				term.setTextColor(cStarG)				write(crStarB)			end		end	endendlocal function drawMap()	for x=1,SizeW do		for y=1,SizeH do		  			local obj = tScreen[x][y]			if obj.ground == true then				paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cG)			end			if obj.wall == true then				paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cW)			end		 		 local ex = tostring(tScreen[x][y].exit)			if not(ex == "zz" or ex == "nil") then				if ex == "a" then					ex = cR1				elseif ex == "b" then					ex = cR2				elseif ex == "c" then					ex = cR3				elseif ex == "d" then					ex = cR4				else					return error("Exit Color Out")				end				term.setBackgroundColor(cG)				term.setTextColor(ex)				term.setCursorPos(XOrgin+x,YOrgin+y+1)				print("X")			end		 		 local st = tostring(tScreen[x][y].start)			if not(st == "zz" or st == "nil") then				local Cr = string.sub(st,2,2)				if Cr == "a" then					Cr = cR1				elseif Cr == "b" then					Cr = cR2				elseif Cr == "c" then					Cr = cR3				elseif Cr == "d" then					Cr = cR4				else					return error("Start Color Out")				end							term.setTextColor(Cr)			term.setBackgroundColor(cG)				term.setCursorPos(XOrgin+x,YOrgin+y+1)							sSide = string.sub(st,1,1)				if sSide == "a" then					print("^")				elseif sSide == "b" then					print(">")				elseif sSide == "c" then					print("v")				elseif sSide == "d" then					print("<")				else					print("@")				end			end						if obj.space == true then				paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cS)			end						local rb = tostring(tScreen[x][y].robot)			if not(rb == "zz" or rb == "nil") then				local Cr = string.sub(rb,2,2)				if Cr == "a" then					Cr = cR1				elseif Cr == "b" then					Cr = cR2				elseif Cr == "c" then					Cr = cR3				elseif Cr == "d" then					Cr = cR4				else					Cr = colors.white				end				term.setBackgroundColor(Cr)				term.setTextColor(colors.white)				term.setCursorPos(XOrgin+x,YOrgin+y+1)				sSide = string.sub(rb,1,1)				if sSide == "a" then					print("^")				elseif sSide == "b" then					print(">")				elseif sSide == "c" then					print("v")				elseif sSide == "d" then					print("<")				else					print("@")				end			end		end	endendlocal function isBrick(x,y)	local brb = tostring(tScreen[x][y].robot)	local bobj = oScreen[x][y]	if (brb == "zz" or brb == "nil") and not bobj.wall == true then		return false	else		return true	endendlocal function gRender(sContext)	if sContext == "start" then		for x=1,SizeW do			for y=1,SizeH do				local st = tostring(tScreen[x][y].start)				if not(st == "zz" or st == "nil") then					local Cr = string.sub(st,2,2)					local sSide = string.sub(st,1,1)					addRobot(x,y,sSide,Cr)				end			end		end	elseif sContext == "tick" then		buMap()        for x=1,SizeW do            for y=1,SizeH do                local rb = tostring(oScreen[x][y].robot)                if not(rb == "zz" or rb == "nil") then                    local Cr = string.sub(rb,2,2)                    local sSide = string.sub(rb,1,1)                    local sobj = oScreen[x][y]                    if sobj.space == true then                        tScreen[x][y].robot = "zz"                        if not sSide == "g" then                            addRobot(x,y,"g",Cr)                        end                    elseif sobj.exit == Cr then                        if sSide == "a" or sSide == "b" or sSide == "c" or sSide == "d" then                        tScreen[x][y].robot = "zz"                        addRobot(x,y,"g",Cr)                        aExits = aExits-1                        end                    elseif sSide == "a" then                        local obj = isBrick(x,y-1)                        tScreen[x][y].robot = "zz"                        if not obj == true then                            addRobot(x,y-1,sSide,Cr)                        else                            local obj2 = isBrick(x-1,y)                            local obj3 = isBrick(x+1,y)                            if not obj2 == true and not obj3 == true then                                if Cr == "a" then                                    addRobot(x,y,"d",Cr)                                elseif Cr == "b" then                                    addRobot(x,y,"b",Cr)                                end                            elseif obj == true and obj2 == true and obj3 == true then                                addRobot(x,y,"c",Cr)                            else                                if obj3 == true then                                    addRobot(x,y,"d",Cr)                                elseif obj2 == true then                                    addRobot(x,y,"b",Cr)                                end                            end                        end                    elseif sSide == "b" then                        local obj = isBrick(x+1,y)                        tScreen[x][y].robot = "zz"                        if not obj == true then                            addRobot(x+1,y,sSide,Cr)                        else                            local obj2 = isBrick(x,y-1)                            local obj3 = isBrick(x,y+1)                            if not obj2 == true and not obj3 == true then                                if Cr == "a" then                                    addRobot(x,y,"a",Cr)                                elseif Cr == "b" then                                    addRobot(x,y,"c",Cr)                                end                            elseif obj == true and obj2 == true and obj3 == true then                                addRobot(x,y,"d",Cr)                            else                                if obj3 == true then                                    addRobot(x,y,"a",Cr)                                elseif obj2 == true then                                    addRobot(x,y,"c",Cr)                                end                            end                        end                    elseif sSide == "c" then                        local obj = isBrick(x,y+1)                        tScreen[x][y].robot = "zz"                        if not obj == true then                            addRobot(x,y+1,sSide,Cr)                        else                            local obj2 = isBrick(x-1,y)                            local obj3 = isBrick(x+1,y)                            if not obj2 == true and not obj3 == true then                                if Cr == "a" then                                    addRobot(x,y,"b",Cr)                                elseif Cr == "b" then                                    addRobot(x,y,"d",Cr)                                end                            elseif obj == true and obj2 == true and obj3 == true then                                addRobot(x,y,"a",Cr)                            else                                if obj3 == true then                                    addRobot(x,y,"d",Cr)                                elseif obj2 == true then                                    addRobot(x,y,"b",Cr)                                end                            end                        end                    elseif sSide == "d" then                        local obj = isBrick(x-1,y)                        tScreen[x][y].robot = "zz"                        if not obj == true then                            addRobot(x-1,y,sSide,Cr)                        else                            local obj2 = isBrick(x,y-1)                            local obj3 = isBrick(x,y+1)                            if not obj2 == true and not obj3 == true then                                if Cr == "a" then                                    addRobot(x,y,"c",Cr)                                elseif Cr == "b" then                                    addRobot(x,y,"a",Cr)                                end                            elseif obj == true and obj2 == true and obj3 == true then                                addRobot(x,y,"b",Cr)                            else                                if obj3 == true then                                    addRobot(x,y,"a",Cr)                                elseif obj2 == true then                                    addRobot(x,y,"c",Cr)                                end                            end                        end                    else                        addRobot(x,y,sSide,"g")                    end                end            end        end    endendfunction InterFace.drawBar()	term.setBackgroundColor( colors.black )	term.setTextColor( InterFace.cTitle )	printCentred( 1, "  "..sLevelTitle.."  " )		term.setCursorPos(1,1)	term.setBackgroundColor( cW )	write( " " )	term.setBackgroundColor( colors.black )	write( " x "..tostring(Blocks).." " )		term.setCursorPos( TermW-8,TermH )	term.setBackgroundColor( colors.black )    term.setTextColour(InterFace.cSpeedD)	write(" <<" )	if bPaused then		term.setTextColour(InterFace.cSpeedA)	else		term.setTextColour(InterFace.cSpeedD)	end	write(" ||")	if fSpeedS then		term.setTextColour(InterFace.cSpeedA)	else		term.setTextColour(InterFace.cSpeedD)	end	write(" >>")	term.setCursorPos( TermW-1, 1 )	term.setBackgroundColor( colors.black )	term.setTextColour( InterFace.cExit )	write(" X")	term.setBackgroundColor(colors.black)endfunction InterFace.render()	local id,p1,p2,p3 = os.pullEvent()	if id == "mouse_click" then		if p3 == 1 and p2 == TermW then            return "end"        elseif p3 == TermH and p2 >= TermW-7 and p2 <= TermW-6 then            return "retry"        elseif p3 == TermH and p2 >= TermW-4 and p2 <= TermW-3 then            bPaused = not bPaused            fSpeedS = false            Speed = (bPaused and 0) or nSpeed            if Speed > 0 then                Tick = os.startTimer(Speed)            else                Tick = nil            end            InterFace.drawBar()        elseif p3 == TermH and p2 >= TermW-1 then            bPaused = false            fSpeedS = not fSpeedS            Speed = (fSpeedS and fSpeed) or nSpeed            Tick = os.startTimer(Speed)            InterFace.drawBar()		elseif p3-1 < YOrgin+SizeH+1 and p3-1 > YOrgin and               p2 < XOrgin+SizeW+1 and p2 > XOrgin then            local eobj = tScreen[p2-XOrgin][p3-YOrgin-1]            local erobj = tostring(tScreen[p2-XOrgin][p3-YOrgin-1].robot)            if (erobj == "zz" or erobj == "nil") and not eobj.wall == true and not eobj.space == true and Blocks > 0 then                addWall(p2-XOrgin,p3-YOrgin-1)                Blocks = Blocks-1                InterFace.drawBar()                drawMap()            end		end	elseif id == "timer" and p1 == Tick then		gRender("tick")        drawMap()        if Speed > 0 then            Tick = os.startTimer(Speed)        else            Tick = nil        end	endendlocal function startG(LevelN)	drawStars()	loadLevel(LevelN)	centerOrgin()	local create = true	drawMap()	InterFace.drawBar()	gRender("start")	drawMap()		local NExit = true	if aExits == 0 then		NExit = false	end		while true do		local isExit = InterFace.render()		if isExit == "end" then		    return nil		elseif isExit == "retry" then		    return LevelN		elseif fExit == "yes" then			if fs.exists( fs.getDir( shell.getRunningProgram() ) .. "/levels/" .. tostring(LevelN + 1) ) then			    return LevelN + 1			else			    return nil			end		end		if aExits == 0 and NExit == true then			fExit = "yes"		end	endendlocal ok, err = true, nil--Menu--local sStartLevel = tArgs[1]if ok and not sStartLevel then    ok, err = pcall( function()        term.setTextColor(colors.white)        term.setBackgroundColor( colors.black )        term.clear()        drawStars()        term.setTextColor( colors.red )        printCentred( TermH/2 - 1, "  REDIRECTION  " )        printCentred( TermH/2 - 0, "  ComputerCraft Edition  " )        term.setTextColor( colors.yellow )        printCentred( TermH/2 + 2, "  Click to Begin  " )        os.pullEvent( "mouse_click" )    end )end--Game--if ok then    ok,err = pcall( function()        local nLevel        if sStartLevel then            nLevel = tonumber( sStartLevel )        else            nLevel = 1        end        while nLevel do            reset()            nLevel = startG(nLevel)        end    end )end--Upsell screen--if ok then    ok, err = pcall( function()        term.setTextColor(colors.white)        term.setBackgroundColor( colors.black )        term.clear()        drawStars()        term.setTextColor( colors.red )        if TermW >= 40 then            printCentred( TermH/2 - 1, "  Thank you for playing Redirection  " )            printCentred( TermH/2 - 0, "  ComputerCraft Edition  " )            printCentred( TermH/2 + 2, "  Check out the full game:  " )            term.setTextColor( colors.yellow )            printCentred( TermH/2 + 3, "  http://www.redirectiongame.com  " )        else            printCentred( TermH/2 - 2, "  Thank you for  " )            printCentred( TermH/2 - 1, "  playing Redirection  " )            printCentred( TermH/2 - 0, "  ComputerCraft Edition  " )            printCentred( TermH/2 + 2, "  Check out the full game:  " )            term.setTextColor( colors.yellow )            printCentred( TermH/2 + 3, "  www.redirectiongame.com  " )        end        parallel.waitForAll(            function() sleep(2) end,            function() os.pullEvent( "mouse_click" ) end        )    end )end--Clear and exit--term.setCursorPos(1,1)term.setTextColor(colors.white)term.setBackgroundColor(colors.black)term.clear()if not ok then    if err == "Terminated" then        print( "Check out the full version of Redirection:" )        print( "http://www.redirectiongame.com" )    else        printError( err )    endend`n077     77718888887 8     8 8     8 8     878888889777     77`n1     777     7b7     787777777877771888888877777777777`n5 777    77777 727777778837 788888878787 787777888887778777787777777e8b7888b888e77787787b777877 777887887887   7487807487   7777777777`n4   777777777   727872787   7878787877777878787877777be888888888be7777787878787777   787878787   787478747   777777777`n677  777  7772888888897 8   8   8 8 8b888 878 e8888 877888878888778 8888e 87 8 888b8 8 8   8   87588888880777  777  77`n17777777777888888b7787778887787 78777787778778888877777787    707    777`n2  777777777778881887777b78777787b778787  7878778787  7878778887  78887777877778777  78838887  77777777`n2    777777777777788888877888887777877b77787  787787 787  7877b77787  7877888887  7877777707  707    777  777`n377777777778888888778778778778778778778888888778778778778778778778e748887777777777`n47777777777728888883778      87788888b 87788888b 87788888b 87788888b 8778      8771888888077777777777`n3728777778b77888888888778777877787787 787 787787 7877788787 788888988777877777e8888877777887`n4777777 77777287b7 7867788787 788777878777877 7888eb8887 77877787877 7887 787887 7487 7e7807 7777 777777`n2    777  777  777877778777  7888388888877778bbbbbbbb87777888b888888b88977878be8888eb87877588b888888b88877778bbbbbbbb8777  788888818887  777877778777    777  777`n/rom/programs/fun/advanced/levels`n/rom/programs/fun/advanced`n/rom/programs/fun`nlocal function printUsage()    print( "Usages:" )    print( "pastebin put <filename>" )    print( "pastebin get <code> <filename>" )    print( "pastebin run <code> <arguments>" )end local tArgs = { ... }if #tArgs < 2 then    printUsage()    returnend if not http then    printError( "Pastebin requires http API" )    printError( "Set http_enable to true in ComputerCraft.cfg" )    returnend local function get(paste)    write( "Connecting to pastebin.com... " )    local response = http.get(        "http://pastebin.com/raw.php?i="..textutils.urlEncode( paste )    )            if response then        print( "Success." )                local sResponse = response.readAll()        response.close()        return sResponse    else        printError( "Failed." )    endend local sCommand = tArgs[1]if sCommand == "put" then    -- Upload a file to pastebin.com    -- Determine file to upload    local sFile = tArgs[2]    local sPath = shell.resolve( sFile )    if not fs.exists( sPath ) or fs.isDir( sPath ) then        print( "No such file" )        return    end        -- Read in the file    local sName = fs.getName( sPath )    local file = fs.open( sPath, "r" )    local sText = file.readAll()    file.close()        -- POST the contents to pastebin    write( "Connecting to pastebin.com... " )    local key = "0ec2eb25b6166c0c27a394ae118ad829"    local response = http.post(        "http://pastebin.com/api/api_post.php",         "api_option=paste&"..        "api_dev_key="..key.."&"..        "api_paste_format=lua&"..        "api_paste_name="..textutils.urlEncode(sName).."&"..        "api_paste_code="..textutils.urlEncode(sText)    )            if response then        print( "Success." )                local sResponse = response.readAll()        response.close()                        local sCode = string.match( sResponse, "[^/]+$" )        print( "Uploaded as "..sResponse )        print( "Run \"pastebin get "..sCode.."\" to download anywhere" )     else        print( "Failed." )    end    elseif sCommand == "get" then    -- Download a file from pastebin.com    if #tArgs < 3 then        printUsage()        return    end     -- Determine file to download    local sCode = tArgs[2]    local sFile = tArgs[3]    local sPath = shell.resolve( sFile )    if fs.exists( sPath ) then        print( "File already exists" )        return    end        -- GET the contents from pastebin    local res = get(sCode)    if res then                local file = fs.open( sPath, "w" )        file.write( res )        file.close()                print( "Downloaded as "..sFile )    end elseif sCommand == "run" then    local sCode = tArgs[2]     local res = get(sCode)    if res then        local func, err = loadstring(res)        if not func then            printError( err )            return        end        setfenv(func, getfenv())        local success, msg = pcall(func, unpack(tArgs, 3))        if not success then            printError( msg )        end    endelse    printUsage()    returnend`n/rom/programs/http`n--[[Falling - Based on Tetris by Alexey PajitnovThis version written by Gopher, at the request of Dan200, forComputerCraft v1.6. No particular rights are reserved.--]]local function colorass(c,bw)  return term.isColor() and c or bwendlocal block_s1= {    {      { 1,0,0,0, },      { 1,1,0,0, },      { 0,1,0,0, },      { 0,0,0,0, },    },    {      { 0,0,0,0, },      { 0,1,1,0, },      { 1,1,0,0, },      { 0,0,0,0, },    },    ch=colorass("  ","{}"),    fg=colorass(colors.blue,colors.black),    bg=colorass(colors.cyan,colors.white),  }local block_s2= {    {      { 0,1,0,0, },      { 1,1,0,0, },      { 1,0,0,0, },      { 0,0,0,0, },    },    {      { 0,0,0,0, },      { 1,1,0,0, },      { 0,1,1,0, },      { 0,0,0,0, },    },    ch=colorass("  ","{}"),    fg=colorass(colors.green,colors.black),    bg=colorass(colors.lime,colors.white),  }local block_line = {    {      { 0,1,0,0, },      { 0,1,0,0, },      { 0,1,0,0, },      { 0,1,0,0, },    },    {      { 0,0,0,0, },      { 1,1,1,1, },      { 0,0,0,0, },      { 0,0,0,0, },    },    ch=colorass("  ","[]"),    fg=colorass(colors.pink,colors.black),    bg=colorass(colors.red,colors.white),  }local block_square = {    {      { 1,1,0,0, },      { 1,1,0,0, },      { 0,0,0,0, },      { 0,0,0,0, },    },    ch=colorass("  ","[]"),    fg=colorass(colors.lightBlue,colors.black),    bg=colorass(colors.blue,colors.white),  }local block_L1 = {    {      { 1,1,0,0, },      { 0,1,0,0, },      { 0,1,0,0, },      { 0,0,0,0, },    },    {      { 0,0,0,0, },      { 1,1,1,0, },      { 1,0,0,0, },      { 0,0,0,0, },    },    {      { 0,1,0,0, },      { 0,1,0,0, },      { 0,1,1,0, },      { 0,0,0,0, },    },    {      { 0,0,1,0, },      { 1,1,1,0, },      { 0,0,0,0, },      { 0,0,0,0, },    },    ch=colorass("  ","()"),    fg=colorass(colors.orange,colors.black),    bg=colorass(colors.yellow,colors.white),  }local block_L2 = {    {      { 0,1,0,0, },      { 0,1,0,0, },      { 1,1,0,0, },      { 0,0,0,0, },    },    {      { 0,0,0,0, },      { 1,1,1,0, },      { 0,0,1,0, },      { 0,0,0,0, },    },    {      { 0,1,1,0, },      { 0,1,0,0, },      { 0,1,0,0, },      { 0,0,0,0, },    },    {      { 1,0,0,0, },      { 1,1,1,0, },      { 0,0,0,0, },      { 0,0,0,0, },    },    ch=colorass("  ","()"),    fg=colorass(colors.brown,colors.black),    bg=colorass(colors.orange,colors.white),  }local block_T = {    {      { 0,1,0,0, },      { 1,1,0,0, },      { 0,1,0,0, },      { 0,0,0,0, },    },    {      { 0,0,0,0, },      { 1,1,1,0, },      { 0,1,0,0, },      { 0,0,0,0, },    },    {      { 0,1,0,0, },      { 0,1,1,0, },      { 0,1,0,0, },      { 0,0,0,0, },    },    {      { 0,1,0,0, },      { 1,1,1,0, },      { 0,0,0,0, },      { 0,0,0,0, },    },    ch=colorass("  ","<>"),    fg=colorass(colors.cyan,colors.black),    bg=colorass(colors.purple,colors.white),  }local blocks={ block_line, block_square, block_s1, block_s2, block_L1, block_L2, block_T}local points={4,10,30,120}local function lpad(text,amt)  text=tostring(text)  return string.rep(" ",amt-#text)..textendlocal width,height=term.getSize()if height<19 or width<26 then  print("Your screen is too small to play :(")  returnendlocal speedsByLevel={  1.2,  1.0,   .8,   .65,   .5,   .4,   .3,   .25,   .2,   .15,   .1,   .05,}local level=1local function playGame()  local score=0  local lines=0  local initialLevel=level  local next=blocks[math.random(1,#blocks)]  local pit={}  local heightAdjust=0  if height<=19 then    heightAdjust=1  end  local function drawScreen()    term.setTextColor(colors.white)    term.setBackgroundColor(colors.black)    term.clear()    term.setTextColor(colors.black)    term.setBackgroundColor(colorass(colors.lightGray, colors.white))    term.setCursorPos(22,2)    term.write("Score") --score    term.setCursorPos(22,5)    term.write("Level")  --level    term.setCursorPos(22,8)    term.write("Lines")  --lines    term.setCursorPos(22,12)    term.write("Next") --next    term.setCursorPos(21,1)    term.write("      ")    term.setCursorPos(21,2)    term.write(" ") --score    term.setCursorPos(21,3)    term.write(" ")    term.setCursorPos(21,4)    term.write("      ")    term.setCursorPos(21,5)    term.write(" ")  --level    term.setCursorPos(21,6)    term.write(" ")    term.setCursorPos(21,7)    term.write("      ")    term.setCursorPos(21,8)    term.write(" ")  --lines    term.setCursorPos(21,9)    term.write(" ")    term.setCursorPos(21,10)    term.write("      ")    term.setCursorPos(21,11)    term.write("      ")    term.setCursorPos(21,12)    term.write(" ") --next    term.setCursorPos(26,12)    term.write(" ") --next    term.setCursorPos(21,13)    term.write("      ")    term.setCursorPos(21,14)    term.write(" ")    term.setCursorPos(21,15)    term.write(" ")    term.setCursorPos(21,16)    term.write(" ")    term.setCursorPos(21,17)    term.write(" ")    term.setCursorPos(21,18)    term.write(" ")    term.setCursorPos(21,19)    term.write("      ")    term.setCursorPos(21,20)    term.write("      ")  end  local function updateNumbers()    term.setTextColor(colors.white)    term.setBackgroundColor(colors.black)    term.setCursorPos(22,3)    term.write(lpad(score,5)) --score    term.setCursorPos(22,6)    term.write(lpad(level,5))  --level    term.setCursorPos(22,9)    term.write(lpad(lines,5))  --lines  end  local function drawBlockAt(block,xp,yp,rot)    term.setTextColor(block.fg)    term.setBackgroundColor(block.bg)    for y=1,4 do      for x=1,4 do        if block[rot][y][x]==1 then          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)          term.write(block.ch)        end      end    end  end  local function eraseBlockAt(block,xp,yp,rot)    term.setTextColor(colors.white)    term.setBackgroundColor(colors.black)    for y=1,4 do      for x=1,4 do        if block[rot][y][x]==1 then          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)          term.write("  ")        end      end    end  end  local function testBlockAt(block,xp,yp,rot)    for y=1,4 do      local ty=yp+y-1      for x=1,4 do        local tx=xp+x-1        if block[rot][y][x]==1 then          if tx>10 or tx<1 or ty>20 or pit[ty][tx]~=0 then            return true          end        end      end    end  end  local function pitBlock(block,xp,yp,rot)    for y=1,4 do      for x=1,4 do        if block[rot][y][x]==1 then          pit[yp+y-1][xp+x-1]=block        end      end    end  end  local function clearPit()    for row=1,20 do      pit[row]={}      for col=1,10 do        pit[row][col]=0      end    end  end  drawScreen()  updateNumbers()  --declare & init the pit  clearPit()  local halt=false  local dropSpeed=speedsByLevel[math.min(level,12)]  local curBlock=next  next=blocks[math.random(1,7)]  local curX, curY, curRot=4, 1, 1  local dropTimer=os.startTimer(dropSpeed)  drawBlockAt(next,11.5,15+heightAdjust,1)  drawBlockAt(curBlock,curX,curY,curRot)  local function redrawPit()    for r=1+heightAdjust,20 do      term.setCursorPos(1,r-heightAdjust)      for c=1,10 do        if pit[r][c]==0 then          term.setTextColor(colors.black)          term.setBackgroundColor(colors.black)          term.write("  ")        else          term.setTextColor(pit[r][c].fg)          term.setBackgroundColor(pit[r][c].bg)          term.write(pit[r][c].ch)        end      end    end  end  local function hidePit()    for r=1+heightAdjust,20 do      term.setCursorPos(1,r-heightAdjust)      term.setTextColor(colors.black)      term.setBackgroundColor(colors.black)      term.write("                    ")    end  end  local function msgBox(message)    local x=math.floor((17-#message)/2)    term.setBackgroundColor(colorass(colors.lightGray,colors.white))    term.setTextColor(colors.black)    term.setCursorPos(x,9)    term.write("+"..string.rep("-",#message+2).."+")    term.setCursorPos(x,10)    term.write("|")    term.setCursorPos(x+#message+3,10)    term.write("|")    term.setCursorPos(x,11)    term.write("+"..string.rep("-",#message+2).."+")    term.setTextColor(colors.white)    term.setBackgroundColor(colors.black)    term.setCursorPos(x+1,10)    term.write(" "..message.." ")  end  local function clearRows()    local rows={}    for r=1,20 do      local count=0      for c=1,10 do        if pit[r][c]~=0 then          count=count+1        else          break        end      end      if count==10 then        rows[#rows+1]=r      end    end    if #rows>0 then      for i=1,4 do        sleep(.1)        for r=1,#rows do          r=rows[r]          term.setCursorPos(1,r-heightAdjust)          for c=1,10 do            term.setTextColor(pit[r][c].bg)            term.setBackgroundColor(pit[r][c].fg)            term.write(pit[r][c].ch)          end        end        sleep(.1)        for r=1,#rows do          r=rows[r]          term.setCursorPos(1,r-heightAdjust)          for c=1,10 do            term.setTextColor(pit[r][c].fg)            term.setBackgroundColor(pit[r][c].bg)            term.write(pit[r][c].ch)          end        end      end      --now remove the rows and drop everythign else      term.setBackgroundColor(colors.black)      for r=1,#rows do        r=rows[r]        term.setCursorPos(1,r-heightAdjust)        term.write("                    ")      end      sleep(.25)      for r=1,#rows do        table.remove(pit,rows[r])        table.insert(pit,1,{0,0,0,0,0,0,0,0,0,0})      end      redrawPit()      lines=lines+#rows      score=score+points[#rows]*math.min(level,20)      level=math.floor(lines/10)+initialLevel      dropSpeed=speedsByLevel[math.min(level,12)]      updateNumbers()    end    sleep(.25)  end  local function blockFall()    local result = false    if testBlockAt(curBlock,curX,curY+1,curRot) then      pitBlock(curBlock,curX,curY,curRot)      --detect rows that clear      clearRows(rows)      curBlock=next      curX=4      curY=1      curRot=1      if testBlockAt(curBlock,curX,curY,curRot) then        halt=true      end      drawBlockAt(curBlock,curX,curY,curRot)      eraseBlockAt(next,11.5,15+heightAdjust,1)      next=blocks[math.random(1,7)]      drawBlockAt(next,11.5,15+heightAdjust,1)      return true    else      eraseBlockAt(curBlock,curX,curY,curRot)      curY=curY+1      drawBlockAt(curBlock,curX,curY,curRot)      return false    end  end  while not halt do    local e={os.pullEvent()}    if e[1]=="timer" then      if e[2]==dropTimer then        blockFall()        dropTimer=os.startTimer(dropSpeed)      end    elseif e[1]=="key" then      local key=e[2]      local dx,dy,dr=0,0,0      if key==keys.left or key==keys.a then        dx=-1      elseif key==keys.right or key==keys.d then        dx=1      elseif key==keys.up or key==keys.w then        dr=1      elseif key==keys.down or key==keys.s then        while not blockFall() do end        dropTimer=os.startTimer(dropSpeed)      elseif key==keys.space then        hidePit()        msgBox("Paused")        while ({os.pullEvent("key")})[2]~=keys.space do end        redrawPit()        drawBlockAt(curBlock,curX,curY,curRot)        dropTimer=os.startTimer(dropSpeed)      end      if dx+dr~=0 then        if not testBlockAt(curBlock,curX+dx,curY+dy,(dr>0 and curRot%#curBlock+dr or curRot)) then          eraseBlockAt(curBlock,curX,curY,curRot)          curX=curX+dx          curY=curY+dy          curRot=dr==0 and curRot or (curRot%#curBlock+dr)          drawBlockAt(curBlock,curX,curY,curRot)        end      end    elseif e[1]=="term_resize" then      local w,h=term.getSize()      if h==20 then        heightAdjust=0      else        heightAdjust=1      end      redrawPit()      drawBlockAt(curBlock,curX,curY,curRot)    end  end  msgBox("Game Over!")  while true do    local _,k=os.pullEvent("key")    if k==keys.space or k==keys.enter then      break    end  end  level = math.min(level,9)endlocal selected=1local playersDetected=falselocal function drawMenu()  term.setBackgroundColor(colors.black)  term.setTextColor(colorass(colors.red,colors.white))  term.clear()  local cx,cy=math.floor(width/2),math.floor(height/2)  term.setCursorPos(cx-6,cy-2)  term.write("F A L L I N G")  if playersDetected then    if selected==0 then      term.setTextColor(colorass(colors.blue,colors.black))      term.setBackgroundColor(colorass(colors.gray,colors.white))    else      term.setTextColor(colorass(colors.lightBlue,colors.white))      term.setBackgroundColor(colors.black)    end    term.setCursorPos(cx-12,cy)    term.write(" Play head-to-head game! ")  end  term.setCursorPos(cx-10,cy+1)  if selected==1 then    term.setTextColor(colorass(colors.blue,colors.black))    term.setBackgroundColor(colorass(colors.lightGray,colors.white))  else    term.setTextColor(colorass(colors.lightBlue,colors.white))    term.setBackgroundColor(colors.black)  end  term.write(" Play from level: <" .. level .. "> ")  term.setCursorPos(cx-3,cy+3)  if selected==2 then    term.setTextColor(colorass(colors.blue,colors.black))    term.setBackgroundColor(colorass(colors.lightGray,colors.white))  else    term.setTextColor(colorass(colors.lightBlue,colors.white))    term.setBackgroundColor(colors.black)  end  term.write(" Quit ")endlocal function runMenu()  drawMenu()  while true do    local event={os.pullEvent()}    if event[1]=="key" then      local key=event[2]      if key==keys.right or key==keys.d and selected==1 then        level=math.min(level+1,9)        drawMenu()      elseif key==keys.left or key==keys.a and selected==1 then        level=math.max(level-1,1)        drawMenu()      elseif key>=keys.one and key<=keys.nine and selected==1 then        level=(key-keys.one) + 1        drawMenu()      elseif key==keys.up or key==keys.w then        selected=selected-1        if selected==0 then          selected=2        end        drawMenu()      elseif key==keys.down or key==keys.s then        selected=selected%2+1        drawMenu()      elseif key==keys.enter or key==keys.space then        break --begin play!      end    end  endendwhile true do  runMenu()  if selected==2 then    break  end  playGame()endterm.setTextColor(colors.white)term.setBackgroundColor(colors.black)term.clear()term.setCursorPos(1,1)`n/rom/programs/pocket`nlocal tArgs = { ... }local function printUsage()	print( "Usages:" )	print( "chat host <hostname>" )	print( "chat join <hostname> <nickname>" )endlocal sOpenedModem = nillocal function openModem()    for n,sModem in ipairs( peripheral.getNames() ) do        if peripheral.getType( sModem ) == "modem" then            if not rednet.isOpen( sModem ) then                rednet.open( sModem )                sOpenedModem = sModem            end            return true        end    end    print( "No modems found." )    return falseendlocal function closeModem()    if sOpenedModem ~= nil then        rednet.close( sOpenedModem )        sOpenedModem = nil    endend-- Colourslocal highlightColour, textColourif term.isColour() then	textColour = colours.white	highlightColour = colours.yellowelse	textColour = colours.white	highlightColour = colours.whiteendlocal sCommand = tArgs[1]if sCommand == "host" then    -- "chat host"    -- Get hostname    local sHostname = tArgs[2]    if sHostname == nil then        printUsage()        return    end    -- Host server    if not openModem() then        return    end    rednet.host( "chat", sHostname )    print( "0 users connected." )    local tUsers = {}    local nUsers = 0    function send( sText, nUserID )        if nUserID then            local tUser = tUsers[ nUserID ]            if tUser then                rednet.send( tUser.nID, {                    sType = "text",                    nUserID = nUserID,                    sText = sText,                }, "chat" )            end        else            for nUserID, tUser in pairs( tUsers ) do                rednet.send( tUser.nID, {                    sType = "text",                    nUserID = nUserID,                    sText = sText,                }, "chat" )            end        end    end    -- Setup ping pong    local tPingPongTimer = {}    function ping( nUserID )        local tUser = tUsers[ nUserID ]        rednet.send( tUser.nID, {            sType = "ping to client",            nUserID = nUserID,        }, "chat" )        local timer = os.startTimer( 15 )        tUser.bPingPonged = false        tPingPongTimer[ timer ] = nUserID    end    function printUsers()        local x,y = term.getCursorPos()        term.setCursorPos( 1, y - 1 )        term.clearLine()        if nUsers == 1 then            print( nUsers .. " user connected." )        else            print( nUsers .. " users connected." )        end    end    -- Handle messages    local ok, error = pcall( function()        parallel.waitForAny( function()            while true do                local sEvent, timer = os.pullEvent( "timer" )                local nUserID = tPingPongTimer[ timer ]                if nUserID and tUsers[ nUserID ] then                    local tUser = tUsers[ nUserID ]                    if tUser then                        if not tUser.bPingPonged then                            send( "* "..tUser.sUsername.." has timed out" )                            tUsers[ nUserID ] = nil                            nUsers = nUsers - 1                            printUsers()                        else                            ping( nUserID )                        end                    end                end            end        end,        function()            while true do                local tCommands                tCommands = {                    ["me"] = function( tUser, sContent )                        if string.len(sContent) > 0 then                            send( "* "..tUser.sUsername.." "..sContent )                        else                            send( "* Usage: /me [words]", tUser.nUserID )                        end                    end,                    ["nick"] = function( tUser, sContent )                        if string.len(sContent) > 0 then                            local sOldName = tUser.sUsername                            tUser.sUsername = sContent                            send( "* "..sOldName.." is now known as "..tUser.sUsername )                        else                            send( "* Usage: /nick [nickname]", tUser.nUserID )                        end                    end,                    ["users"] = function( tUser, sContent )                        send( "* Connected Users:", tUser.nUserID )                        local sUsers = "*"                        for nUserID, tUser in pairs( tUsers ) do                            sUsers = sUsers .. " " .. tUser.sUsername                        end                        send( sUsers, tUser.nUserID )                    end,                    ["help"] = function( tUser, sContent )                        send( "* Available commands:", tUser.nUserID )                        local sCommands = "*"                        for sCommand, fnCommand in pairs( tCommands ) do                            sCommands = sCommands .. " /" .. sCommand                        end                        send( sCommands.." /logout", tUser.nUserID )                    end,                }                local nSenderID, tMessage = rednet.receive( "chat" )                if type( tMessage ) == "table" then                    if tMessage.sType == "login" then                        -- Login from new client                        local nUserID = tMessage.nUserID                        local sUsername = tMessage.sUsername                        if nUserID and sUsername then                            tUsers[ nUserID ] = {                                nID = nSenderID,                                nUserID = nUserID,                                sUsername = sUsername,                            }                            nUsers = nUsers + 1                            printUsers()                            send( "* "..sUsername.." has joined the chat" )                            ping( nUserID )                        end                    else                        -- Something else from existing client                        local nUserID = tMessage.nUserID                        local tUser = tUsers[ nUserID ]                        if tUser and tUser.nID == nSenderID then                            if tMessage.sType == "logout" then                                send( "* "..tUser.sUsername.." has left the chat" )                                tUsers[ nUserID ] = nil                                nUsers = nUsers - 1                                printUsers()                            elseif tMessage.sType == "chat" then                                local sMessage = tMessage.sText                                if sMessage then                                    local sCommand = string.match( sMessage, "^/([a-z]+)" )                                    if sCommand then                                        local fnCommand = tCommands[ sCommand ]                                        if fnCommand then                                            local sContent = string.sub( sMessage, string.len(sCommand)+3 )                                            fnCommand( tUser, sContent )                                        else                                            send( "* Unrecognised command: /"..sCommand, tUser.nUserID )                                        end                                    else                                        send( "<"..tUser.sUsername.."> "..tMessage.sText )                                    end                                end                            elseif tMessage.sType == "ping to server" then                                rednet.send( tUser.nID, {                                    sType = "pong to client",                                    nUserID = nUserID,                                }, "chat" )                            elseif tMessage.sType == "pong to server" then                                tUser.bPingPonged = true                            end                        end                    end                 end            end        end )    end )    if not ok then        printError( error )    end    -- Unhost server    for nUserID, tUser in pairs( tUsers ) do        rednet.send( tUser.nID, {            sType = "kick",            nUserID = nUserID,        }, "chat" )    end    rednet.unhost( "chat" )    closeModem()elseif sCommand == "join" then    -- "chat join"    -- Get hostname and username    local sHostname = tArgs[2]    local sUsername = tArgs[3]    if sHostname == nil or sUsername == nil then        printUsage()        return    end    -- Connect    if not openModem() then        return    end    write( "Looking up " .. sHostname .. "... " )    local nHostID = rednet.lookup( "chat", sHostname )    if nHostID == nil then        print( "Failed." )        return    else        print( "Success." )    end    -- Login    local nUserID = math.random( 1, 2147483647 )    rednet.send( nHostID, {        sType = "login",        nUserID = nUserID,        sUsername = sUsername,    }, "chat" )    -- Setup ping pong    local bPingPonged = true    local pingPongTimer = os.startTimer( 0 )    function ping()        rednet.send( nHostID, {            sType = "ping to server",            nUserID = nUserID,        }, "chat" )        bPingPonged = false        pingPongTimer = os.startTimer( 15 )    end    -- Handle messages    local w,h = term.getSize()    local parentTerm = term.current()    local titleWindow = window.create( parentTerm, 1, 1, w, 1, true )    local historyWindow = window.create( parentTerm, 1, 2, w, h-2, true )    local promptWindow = window.create( parentTerm, 1, h, w, 1, true )    historyWindow.setCursorPos( 1, h-2 )    term.clear()    term.setTextColour( textColour )    term.redirect( promptWindow )    promptWindow.restoreCursor()    function drawTitle()        local x,y = titleWindow.getCursorPos()        local w,h = titleWindow.getSize()        local sTitle = sUsername.." on "..sHostname        titleWindow.setTextColour( highlightColour )        titleWindow.setCursorPos( math.floor( w/2 - string.len(sTitle)/2 ), 1 )        titleWindow.clearLine()        titleWindow.write( sTitle )        promptWindow.restoreCursor()    end    function printMessage( sMessage )        term.redirect( historyWindow )        print()        if string.match( sMessage, "^\*" ) then            -- Information            term.setTextColour( highlightColour )            write( sMessage )            term.setTextColour( textColour )        else            -- Chat            local sUsernameBit = string.match( sMessage, "^\<[^\>]*\>" )            if sUsernameBit then                term.setTextColour( highlightColour )                write( sUsernameBit )                term.setTextColour( textColour )                write( string.sub( sMessage, string.len( sUsernameBit ) + 1 ) )            else                write( sMessage )            end        end        term.redirect( promptWindow )        promptWindow.restoreCursor()    end    drawTitle()    local ok, error = pcall( function()        parallel.waitForAny( function()            while true do                local sEvent, timer = os.pullEvent()                if sEvent == "timer" then                    if timer == pingPongTimer then                        if not bPingPonged then                            printMessage( "Server timeout." )                            return                        else                            ping()                        end                    end                elseif sEvent == "term_resize" then                    local w,h = parentTerm.getSize()                    titleWindow.reposition( 1, 1, w, 1 )                    historyWindow.reposition( 1, 2, w, h-2 )                    promptWindow.reposition( 1, h, w, 1 )                end            end        end,        function()            while true do                local nSenderID, tMessage = rednet.receive( "chat" )                if nSenderID == nHostID and type( tMessage ) == "table" and tMessage.nUserID == nUserID then                    if tMessage.sType == "text" then                        local sText = tMessage.sText                        if sText then                            printMessage( sText )                        end                    elseif tMessage.sType == "ping to client" then                        rednet.send( nSenderID, {                            sType = "pong to server",                            nUserID = nUserID,                        }, "chat" )                    elseif tMessage.sType == "pong to client" then                        bPingPonged = true                    elseif tMessage.sType == "kick" then                        return                    end                end            end        end,        function()            local tSendHistory = {}            while true do                promptWindow.setCursorPos( 1,1 )                promptWindow.clearLine()                promptWindow.setTextColor( highlightColour )                promptWindow.write( ": ")                promptWindow.setTextColor( textColour )                local sChat = read( nil, tSendHistory )                if string.match( sChat, "^/logout" ) then                    break                else                    rednet.send( nHostID, {                        sType = "chat",                        nUserID = nUserID,                        sText = sChat,                    }, "chat" )                    table.insert( tSendHistory, sChat )                end            end        end )    end )    -- Close the windows    term.redirect( parentTerm )    -- Print error notice    local w,h = term.getSize()    term.setCursorPos( 1, h )    term.clearLine()    term.setCursorBlink( false )    if not ok then        printError( error )    end    -- Logout    rednet.send( nHostID, {        sType = "logout",        nUserID = nUserID,    }, "chat" )    closeModem()    -- Print disconnection notice    print( "Disconnected." )else    -- "chat somethingelse"    printUsage()end`n-- Find modemslocal tModems = {}for n,sModem in ipairs( peripheral.getNames() ) do    if peripheral.getType( sModem ) == "modem" then        table.insert( tModems, sModem )    endendif #tModems == 0 then    print( "No modems found." )    returnelseif #tModems == 1 then    print( "1 modem found." )else    print( #tModems .. " modems found." )endfunction open( nChannel )    for n=1,#tModems do        local sModem = tModems[n]        peripheral.call( sModem, "open", nChannel )    endendfunction close( nChannel )    for n=1,#tModems do        local sModem = tModems[n]        peripheral.call( sModem, "close", nChannel )    endend-- Open channelsprint( "0 messages repeated." )open( rednet.CHANNEL_REPEAT )-- Main loop (terminate to break)local ok, error = pcall( function()    local tReceivedMessages = {}    local tReceivedMessageTimeouts = {}    local nTransmittedMessages = 0    while true do        local sEvent, sModem, nChannel, nReplyChannel, tMessage = os.pullEvent()        if sEvent == "modem_message" then            -- Got a modem message, rebroadcast it if it's a rednet thing            if nChannel == rednet.CHANNEL_REPEAT then                if type( tMessage ) == "table" and tMessage.nMessageID and tMessage.nRecipient then                    if not tReceivedMessages[ tMessage.nMessageID ] then                        -- Ensure we only repeat a message once                        tReceivedMessages[ tMessage.nMessageID ] = true                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = tMessage.nMessageID                        -- Send on all other open modems, to the target and to other repeaters                        for n=1,#tModems do                            local sOtherModem = tModems[n]                            peripheral.call( sOtherModem, "transmit", rednet.CHANNEL_REPEAT, nReplyChannel, tMessage )                            peripheral.call( sOtherModem, "transmit", tMessage.nRecipient, nReplyChannel, tMessage )                        end                        -- Log the event                        nTransmittedMessages = nTransmittedMessages + 1                        local x,y = term.getCursorPos()                        term.setCursorPos( 1, y - 1 )                        term.clearLine()                        if nTransmittedMessages == 1 then                            print( nTransmittedMessages .. " message repeated." )                        else                            print( nTransmittedMessages .. " messages repeated." )                        end                    end                end            end        elseif sEvent == "timer" then            -- Got a timer event, use it to clear the message history            local nTimer = sModem            local nMessageID = tReceivedMessageTimeouts[ nTimer ]            if nMessageID then                tReceivedMessageTimeouts[ nTimer ] = nil                tReceivedMessages[ nMessageID ] = nil            end        end    endend )if not ok then    printError( error )end-- Close channelsclose( rednet.CHANNEL_REPEAT )`n/rom/programs/rednet`nif not turtle.craft then    print( "Requires a Crafty Turtle" )    returnendlocal tArgs = { ... }local nLimit = nilif #tArgs < 1 then	print( "Usage: craft [number]" )	returnelse	nLimit = tonumber( tArgs[1] )endlocal nCrafted = 0local nOldCount = turtle.getItemCount( turtle.getSelectedSlot() )if turtle.craft( nLimit ) then    local nNewCount = turtle.getItemCount( turtle.getSelectedSlot() )    if nOldCount <= nLimit then        nCrafted = nNewCount    else        nCrafted = nOldCount - nNewCount    endendif nCrafted > 1 then    print( nCrafted.." items crafted" )elseif nCrafted == 1 then    print( "1 item crafted" )else    print( "No items crafted" )end`nlocal tMoves = {	function()		turtle.up()		turtle.down()	end,	function()		turtle.up()		turtle.turnLeft()		turtle.turnLeft()		turtle.turnLeft()		turtle.turnLeft()		turtle.down()	end,	function()		turtle.up()		turtle.turnRight()		turtle.turnRight()		turtle.turnRight()		turtle.turnRight()		turtle.down()	end,	function()		turtle.turnLeft()		turtle.turnLeft()		turtle.turnLeft()		turtle.turnLeft()	end,	function()		turtle.turnRight()		turtle.turnRight()		turtle.turnRight()		turtle.turnRight()	end,	function()		turtle.turnLeft()		turtle.back()		turtle.back()		turtle.turnRight()		turtle.turnRight()		turtle.back()		turtle.back()		turtle.turnLeft()	end,	function()		turtle.turnRight()		turtle.back()		turtle.back()		turtle.turnLeft()		turtle.turnLeft()		turtle.back()		turtle.back()		turtle.turnRight()	end,	function()		turtle.back()		turtle.turnLeft()		turtle.back()		turtle.turnLeft()		turtle.back()		turtle.turnLeft()		turtle.back()		turtle.turnLeft()	end,	function()		turtle.back()		turtle.turnRight()		turtle.back()		turtle.turnRight()		turtle.back()		turtle.turnRight()		turtle.back()		turtle.turnRight()	end,}textutils.slowWrite( "Preparing to get down." )textutils.slowPrint( "..", 0.75 )local sAudio = nilfor n,sName in pairs( peripheral.getNames() ) do	if disk.hasAudio( sName ) then		disk.playAudio( sName )		print( "Jamming to "..disk.getAudioTitle( sName ) )		sAudio = sName		break	endendprint( "Press any key to stop the groove" )local bEnd = falseparallel.waitForAll(	function()		while not bEnd do			local event, key = os.pullEvent("key")			if key ~= keys.escape then				bEnd = true			end		end			end,	function()		while not bEnd do			local fnMove = tMoves[math.random(1,#tMoves)]			fnMove()		end	end)if sAudio then	disk.stopAudio( sAudio )end`nlocal tArgs = { ... }local function printUsage()	print( "Usage: equip <slot> <side>" )endif #tArgs ~= 2 then    printUsage()	returnendlocal function equip( nSlot, fnEquipFunction )    turtle.select( nSlot )    local nOldCount = turtle.getItemCount( nSlot )    if nOldCount == 0 then        print( "Nothing to equip" )    elseif fnEquipFunction() then        local nNewCount = turtle.getItemCount( nSlot )        if nNewCount > 0 then            print( "Items swapped" )        else            print( "Item equipped" )        end    else        print( "Item not equippable" )    endendlocal nSlot = tonumber( tArgs[1] )local sSide = tArgs[2]if sSide == "left" then    equip( nSlot, turtle.equipLeft )elseif sSide == "right" then    equip( nSlot, turtle.equipRight )else    printUsage()    returnend`nlocal tArgs = { ... }if #tArgs ~= 1 then	print( "Usage: excavate <diameter>" )	returnend-- Mine in a quarry pattern until we hit something we can't diglocal size = tonumber( tArgs[1] )if size < 1 then	print( "Excavate diameter must be positive" )	returnend	local depth = 0local unloaded = 0local collected = 0local xPos,zPos = 0,0local xDir,zDir = 0,1local goTo -- Filled in further downlocal refuel -- Filled in further down local function unload( _bKeepOneFuelStack )	print( "Unloading items..." )	for n=1,16 do		local nCount = turtle.getItemCount(n)		if nCount > 0 then			turtle.select(n)						local bDrop = true			if _bKeepOneFuelStack and turtle.refuel(0) then				bDrop = false				_bKeepOneFuelStack = false			end						if bDrop then				turtle.drop()				unloaded = unloaded + nCount			end		end	end	collected = 0	turtle.select(1)endlocal function returnSupplies()	local x,y,z,xd,zd = xPos,depth,zPos,xDir,zDir	print( "Returning to surface..." )	goTo( 0,0,0,0,-1 )		local fuelNeeded = 2*(x+y+z) + 1	if not refuel( fuelNeeded ) then		unload( true )		print( "Waiting for fuel" )		while not refuel( fuelNeeded ) do			os.pullEvent( "turtle_inventory" )		end	else		unload( true )		end		print( "Resuming mining..." )	goTo( x,y,z,xd,zd )endlocal function collect()		local bFull = true	local nTotalItems = 0	for n=1,16 do		local nCount = turtle.getItemCount(n)		if nCount == 0 then			bFull = false		end		nTotalItems = nTotalItems + nCount	end		if nTotalItems > collected then		collected = nTotalItems		if math.fmod(collected + unloaded, 50) == 0 then			print( "Mined "..(collected + unloaded).." items." )		end	end		if bFull then		print( "No empty slots left." )		return false	end	return trueendfunction refuel( ammount )	local fuelLevel = turtle.getFuelLevel()	if fuelLevel == "unlimited" then		return true	end		local needed = ammount or (xPos + zPos + depth + 2)	if turtle.getFuelLevel() < needed then		local fueled = false		for n=1,16 do			if turtle.getItemCount(n) > 0 then				turtle.select(n)				if turtle.refuel(1) then					while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do						turtle.refuel(1)					end					if turtle.getFuelLevel() >= needed then						turtle.select(1)						return true					end				end			end		end		turtle.select(1)		return false	end		return trueendlocal function tryForwards()	if not refuel() then		print( "Not enough Fuel" )		returnSupplies()	end		while not turtle.forward() do		if turtle.detect() then			if turtle.dig() then				if not collect() then					returnSupplies()				end			else				return false			end		elseif turtle.attack() then			if not collect() then				returnSupplies()			end		else			sleep( 0.5 )		end	end		xPos = xPos + xDir	zPos = zPos + zDir	return trueendlocal function tryDown()	if not refuel() then		print( "Not enough Fuel" )		returnSupplies()	end		while not turtle.down() do		if turtle.detectDown() then			if turtle.digDown() then				if not collect() then					returnSupplies()				end			else				return false			end		elseif turtle.attackDown() then			if not collect() then				returnSupplies()			end		else			sleep( 0.5 )		end	end	depth = depth + 1	if math.fmod( depth, 10 ) == 0 then		print( "Descended "..depth.." metres." )	end	return trueendlocal function turnLeft()	turtle.turnLeft()	xDir, zDir = -zDir, xDirendlocal function turnRight()	turtle.turnRight()	xDir, zDir = zDir, -xDirendfunction goTo( x, y, z, xd, zd )	while depth > y do		if turtle.up() then			depth = depth - 1		elseif turtle.digUp() or turtle.attackUp() then			collect()		else			sleep( 0.5 )		end	end	if xPos > x then		while xDir ~= -1 do			turnLeft()		end		while xPos > x do			if turtle.forward() then				xPos = xPos - 1			elseif turtle.dig() or turtle.attack() then				collect()			else				sleep( 0.5 )			end		end	elseif xPos < x then		while xDir ~= 1 do			turnLeft()		end		while xPos < x do			if turtle.forward() then				xPos = xPos + 1			elseif turtle.dig() or turtle.attack() then				collect()			else				sleep( 0.5 )			end		end	end		if zPos > z then		while zDir ~= -1 do			turnLeft()		end		while zPos > z do			if turtle.forward() then				zPos = zPos - 1			elseif turtle.dig() or turtle.attack() then				collect()			else				sleep( 0.5 )			end		end	elseif zPos < z then		while zDir ~= 1 do			turnLeft()		end		while zPos < z do			if turtle.forward() then				zPos = zPos + 1			elseif turtle.dig() or turtle.attack() then				collect()			else				sleep( 0.5 )			end		end		end		while depth < y do		if turtle.down() then			depth = depth + 1		elseif turtle.digDown() or turtle.attackDown() then			collect()		else			sleep( 0.5 )		end	end		while zDir ~= zd or xDir ~= xd do		turnLeft()	endendif not refuel() then	print( "Out of Fuel" )	returnendprint( "Excavating..." )local reseal = falseturtle.select(1)if turtle.digDown() then	reseal = trueendlocal alternate = 0local done = falsewhile not done do	for n=1,size do		for m=1,size-1 do			if not tryForwards() then				done = true				break			end		end		if done then			break		end		if n<size then			if math.fmod(n + alternate,2) == 0 then				turnLeft()				if not tryForwards() then					done = true					break				end				turnLeft()			else				turnRight()				if not tryForwards() then					done = true					break				end				turnRight()			end		end	end	if done then		break	end		if size > 1 then		if math.fmod(size,2) == 0 then			turnRight()		else			if alternate == 0 then				turnLeft()			else				turnRight()			end			alternate = 1 - alternate		end	end		if not tryDown() then		done = true		break	endendprint( "Returning to surface..." )-- Return to where we startedgoTo( 0,0,0,0,-1 )unload( false )goTo( 0,0,0,0,1 )-- Seal the holeif reseal then	turtle.placeDown()endprint( "Mined "..(collected + unloaded).." items total." )`nlocal tArgs = { ... }if #tArgs < 1 then	print( "Usage: go <direction> <distance>" )	returnendlocal tHandlers = {	["fd"] = turtle.forward,	["forward"] = turtle.forward,	["forwards"] = turtle.forward,	["bk"] = turtle.back,	["back"] = turtle.back,	["up"] = turtle.up,	["dn"] = turtle.down,	["down"] = turtle.down,	["lt"] = turtle.turnLeft,	["left"] = turtle.turnLeft,	["rt"] = turtle.turnRight,	["right"] = turtle.turnRight,}local nArg = 1while nArg <= #tArgs do	local sDirection = tArgs[nArg]	local nDistance = 1	if nArg < #tArgs then		local num = tonumber( tArgs[nArg + 1] )		if num then			nDistance = num			nArg = nArg + 1		end	end	nArg = nArg + 1	local fnHandler = tHandlers[string.lower(sDirection)]	if fnHandler then		while nDistance > 0 do			if fnHandler() then				nDistance = nDistance - 1			elseif turtle.getFuelLevel() == 0 then				print( "Out of fuel" )				return			else				sleep(0.5)			end		end	else		print( "No such direction: "..sDirection )		print( "Try: forward, back, up, down" )		return	endend`nlocal tArgs = { ... }local nLimit = 1if #tArgs > 1 then	print( "Usage: refuel [number]" )	returnelseif #tArgs > 0 then	if tArgs[1] == "all" then		nLimit = 64 * 16	else		nLimit = tonumber( tArgs[1] )	endendif turtle.getFuelLevel() ~= "unlimited" then	for n=1,16 do		local nCount = turtle.getItemCount(n)		if nLimit > 0 and nCount > 0 and turtle.getFuelLevel() < turtle.getFuelLimit() then		    local nBurn = math.min( nLimit, nCount )			turtle.select( n )			if turtle.refuel( nBurn ) then			    local nNewCount = turtle.getItemCount(n)    			nLimit = nLimit - (nCount - nNewCount)    		end		end	end    print( "Fuel level is "..turtle.getFuelLevel() )    if turtle.getFuelLevel() == turtle.getFuelLimit() then        print( "Fuel limit reached" )    endelse    print( "Fuel level is unlimited" )end`nlocal tArgs = { ... }if #tArgs ~= 1 then	print( "Usage: tunnel <length>" )	returnend-- Mine in a quarry pattern until we hit something we can't diglocal length = tonumber( tArgs[1] )if length < 1 then	print( "Tunnel length must be positive" )	returnend	local depth = 0local collected = 0local function collect()	collected = collected + 1	if math.fmod(collected, 25) == 0 then		print( "Mined "..collected.." items." )	endendlocal function tryDig()	while turtle.detect() do		if turtle.dig() then			collect()			sleep(0.5)		else			return false		end	end	return trueendlocal function tryDigUp()	while turtle.detectUp() do		if turtle.digUp() then			collect()			sleep(0.5)		else			return false		end	end	return trueendlocal function tryDigDown()	while turtle.detectDown() do		if turtle.digDown() then			collect()			sleep(0.5)		else			return false		end	end	return trueendlocal function refuel()	local fuelLevel = turtle.getFuelLevel()	if fuelLevel == "unlimited" or fuelLevel > 0 then		return	end		local function tryRefuel()		for n=1,16 do			if turtle.getItemCount(n) > 0 then				turtle.select(n)				if turtle.refuel(1) then					turtle.select(1)					return true				end			end		end		turtle.select(1)		return false	end		if not tryRefuel() then		print( "Add more fuel to continue." )		while not tryRefuel() do			os.pullEvent( "turtle_inventory" )		end		print( "Resuming Tunnel." )	endendlocal function tryUp()	refuel()	while not turtle.up() do		if turtle.detectUp() then			if not tryDigUp() then				return false			end		elseif turtle.attackUp() then			collect()		else			sleep( 0.5 )		end	end	return trueendlocal function tryDown()	refuel()	while not turtle.down() do		if turtle.detectDown() then			if not tryDigDown() then				return false			end		elseif turtle.attackDown() then			collect()		else			sleep( 0.5 )		end	end	return trueendlocal function tryForward()	refuel()	while not turtle.forward() do		if turtle.detect() then			if not tryDig() then				return false			end		elseif turtle.attack() then			collect()		else			sleep( 0.5 )		end	end	return trueendprint( "Tunnelling..." )for n=1,length do	turtle.placeDown()	tryDigUp()	turtle.turnLeft()	tryDig()	tryUp()	tryDig()	turtle.turnRight()	turtle.turnRight()	tryDig()	tryDown()	tryDig()	turtle.turnLeft()		if n<length then		tryDig()		if not tryForward() then			print( "Aborting Tunnel." )			break		end	else		print( "Tunnel complete." )	endend--[[print( "Returning to start..." )-- Return to where we startedturtle.turnLeft()turtle.turnLeft()while depth > 0 do	if turtle.forward() then		depth = depth - 1	else		turtle.dig()	endendturtle.turnRight()turtle.turnRight()]]print( "Tunnel complete." )print( "Mined "..collected.." items total." )`nlocal tArgs = { ... }if #tArgs < 1 then	print( "Usage: turn <direction> <turns>" )	returnendlocal tHandlers = {	["lt"] = turtle.turnLeft,	["left"] = turtle.turnLeft,	["rt"] = turtle.turnRight,	["right"] = turtle.turnRight,}local nArg = 1while nArg <= #tArgs do	local sDirection = tArgs[nArg]	local nDistance = 1	if nArg < #tArgs then		local num = tonumber( tArgs[nArg + 1] )		if num then			nDistance = num			nArg = nArg + 1		end	end	nArg = nArg + 1	local fnHandler = tHandlers[string.lower(sDirection)]	if fnHandler then		for n=1,nDistance do			fnHandler( nArg )		end	else		print( "No such direction: "..sDirection )		print( "Try: left, right" )		return	end	end`nlocal tArgs = { ... }local function printUsage()	print( "Usage: unequip <side>" )endif #tArgs ~= 1 then    printUsage()	returnendlocal function unequip( fnEquipFunction )    for nSlot=1,16 do        local nOldCount = turtle.getItemCount( nSlot )        if nOldCount == 0 then            turtle.select( nSlot )            if fnEquipFunction() then                local nNewCount = turtle.getItemCount( nSlot )                if nNewCount > 0 then                    print( "Item unequipped" )                    return                else                    print( "Nothing to unequip" )                    return                end            end        end    end    print( "No space to unequip item" )endlocal sSide = tArgs[1]if sSide == "left" then    unequip( turtle.equipLeft )elseif sSide == "right" then    unequip( turtle.equipRight )else    printUsage()    returnend`n/rom/programs/turtle`n/rom/programs`n/rom