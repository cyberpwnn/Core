local APIBuffer = {}
local APIStored = {}

local sls = "/"
local stc = "/core"
local stcLib = "/lib"
local stcLogs = "/logs"
local stcConfig = "/config"
local tStc = {}

local eventStart = {}
local eventStop = {}
local eventCrash = {}

local deb
local net

local otd = false
local otn = false
local ots = false

local ERROR = {}

function launch(path, stored)
  ots = true
  inf("Starting Debugger")
  startDebugger()
  APIStored = stored
  vrb("Transferring CPI Cache")
  stc = path
  vrb("Path set to " .. stc)
  stcLib = stc..stcLib
  stcLogs = stc..stcLogs
  stcConfig = stc..stcConfig
  tStc = {stcLib, stcLogs, stcConfig}
  for i,v in ipairs(tStc) do
    vrb("Checking " .. v)
    if not fs.exists(v) then fs.makeDir(v) end
  end
  for i,v in ipairs(fs.list(stcLib)) do
    if v ~= "CPI" then
      if loadAPI(stcLib..sls..v) then
        
      else
        err("Failed to load " .. v)
      end
    end
  end  
  
  if #ERROR > 0 then
    erc("Core Has Crashed!")
    erc("There are " .. #ERROR .. " errors")
    erc("---------------------- TRACE ----------------------")
    for i,v in ipairs(ERROR) do
      erc("["..i.."] "..v)
    end
    erc("---------------------- ----- ----------------------")
    deployEventCrash(ERROR)
    read()
    os.reboot()
  else
    ots = false
    inf("Main Logging Onscreen Closed")
    Renderer.render()
    deployEventStart()
  end
end

function stop()
  deployEventStop()
end

function requireAPI(s)
  if isLoaded(s) or isLoaded(stcLib..sls..s) then return false else
    vrb("Waiting for " .. s .. " to be loaded.")
    if fs.exists(s) then
      os.loadAPI(s)
      return true
    elseif fs.exists(stcLib..sls..s) then 
      os.loadAPI(stcLib..sls..s)
      return true
    else
      return false
    end 
  end
end

function loadAPI(path)
  if isLoaded(path) or isLoaded(stcLib..sls..path) then return false end
  inf("Loading ".. path)
  local name = fs.getName(path)
  local envelope = {}
  local fAPI, errt = loadfile(path)
  local cAPI = {}

  if APIBuffer[name] == true then
    err(name.." is already in the load queue!")
    err("Loading apis to each other is not a good idea!")
    return false
  end
  
  APIBuffer[name] = true
  setmetatable(envelope, {__index = _G})
  
  if fAPI then
    setfenv(fAPI, envelope)
    fAPI()
  else
    err(errt)
    APIBuffer[name] = nil
    return false
  end
  
  for k,v in pairs(envelope) do
    cAPI[k] = v
  end
  
  _G[name] = cAPI    
  APIBuffer[name] = nil
  table.insert(APIStored, path)
  return true
end

function unloadAPI(name)
  if name ~= "_G" and type(_G[name]) == "table" then
    _G[name] = nil
  end
end

function isLoaded(s)
  for i,v in ipairs(APIStored) do
    if v == s then return true end
  end
  if APIBuffer[s] == true then return true end
  return false
end

-- Logging
function output(s, t)
  if ots then
    term.setTextColor(t)
    print(s)
  end
  if otd then 
    local ax,ay = deb.getCursorPos()
    local aw,ah = deb.getSize()
    deb.setTextColor(t)
    deb.write(s)
    if ay == ah then deb.scroll(1) else
      deb.setCursorPos(1,ay+1)
    end
  end
  if otn then
    net.transmit(3, 1, "#"..tostring(t))
    net.transmit(3, 1, s)
  end
end

function inf(s) output(s, colors.white) end
function vrb(s) output(s, colors.lightGray) end
function wrn(s) output(s, colors.yellow) end
function err(s) output(s, colors.red) table.insert(ERROR, s) end
function erc(s) output(s, colors.red) end

function getPath() return stc end

function startDebugger()
  deb = peripheral.find("monitor")
  if monitor then otd = true else otd = false end
  net = peripheral.wrap("top")
  if net then otn = true net.transmit(3, 1, "/clear") else otn = false end
end

function deployEventStart()
  vrb("Deploying " .. #eventStart .. " start events...")
  for i,v in ipairs(eventStart) do
    v()
  end
  inf("Deployed " .. #eventStart .. " start events")
end

function deployEventStop()
  vrb("Deploying " .. #eventStop .. " stop events...")
  for i,v in ipairs(eventStop) do
    v()
  end
  inf("Deployed " .. #eventStop .. " stop events")
end

function deployEventCrash(e)
  vrb("Deploying " .. #eventCrash .. " crash events...")
  for i,v in ipairs(eventCrash) do
    v(e)
  end
  inf("Deployed " .. #eventCrash .. " crash events")
end

function onStart(f) table.insert(eventStart, f) end
function onStop(f) table.insert(eventStop, f) end
function onCrash(f) table.insert(eventCrash, f) end

function object(o)
  if o then 
    o = setmetatable({}, o)
    return o
  else
    local this = {}
    this.__index = this
    return this
  end
end
