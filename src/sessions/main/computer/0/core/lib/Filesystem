local PATH = CPI.getPath()
local r = "r"
local w = "w"
local a = "a"
local b = "b"

local loaded = {}

local File = CPI.object()
local Collection = CPI.object()

CPI.onStop(function() closeAll() end)

function open(d, m)
  local self = CPI.object(File)
  self.d = d
  self.m = m
  self.i = #loaded +1
  
  table.insert(loaded, {self.d, fs.open(d,m)})
  CPI.inf("FS: Opened " .. d)
  
  return self
end

function File:write(s) loaded[self.i][2].write(s) return self end
function File:writeLine(s) loaded[self.i][2].writeLine(s) return self end
function File:read() return loaded[self.i][2].read() end
function File:readAll() return loaded[self.i][2].readAll() end
function File:readLine() return loaded[self.i][2].readLine() end
function File:close(s) loaded[self.i][2].close() loaded[self.i] = nil end
function File:flush(s) loaded[self.i][2].flush() return self end

function closeAll()
  local loadedv = loaded
  if #loadedv == 0 then return false end
  CPI.inf("FS: Closing "..#loadedv .. " Files")
  for i,v in ipairs(loadedv) do
    CPI.wrn("FS: Closing File " .. v[1])
    v[2].close()
  end
  loaded = {}
end

function newCollection(d)
  local self = CPI.object(Collection)
  self.l = {}
  self:add(d)
  return self
end

function Collection:add(l)
  if fs.exists(l) then
    if fs.isDir(l) then
      for i,v in ipairs(fs.list(l)) do
        self:add(l.."/"..v)
      end
    end
    if not self:is(l) then
      if not fs.isDir(l) then
        if l:sub(1,2) == "//" then table.insert(self.l, l:sub(2)) else table.insert(self.l, l) end
      end
    end
  end
end

function Collection:list()
  return self.l
end

function Collection:output(l)
  local f = open(l..".col", "w")
  local s = ""
  local d = {}
  local n = 0
  
  local idNewLine = "`n"
  local idSource = "/@/"
  local idExit = "``"
  local idIgnore = "'"
  
  local iLimit = 1000000
  
  for i,v in ipairs(self.l) do
    -- Gather Data and store it to s,d,n
    if fs.isDir(v) then
      table.insert(d, v)
    else
      local fd = open(v, "r")
      local fl = {}
      
      for i = 1, iLimit do
        local rc = fd:readLine()
        if rc then
          if i == 1 then table.insert(fl, v..idSource..rc) else
            table.insert(fl, rc)
          end
        else break end
      end
      
      table.insert(d,fl)
    end
  end
  
  -- Additional Processing
  for i,v in ipairs(d) do
    if s ~= "" then s = s .. idNewLine end
    if type(v) == "string" then
      s = s .. v
    elseif type(v) == "table" then
      for j,w in ipairs(v) do
      -- Line processing
        local space = 0
      
        w:gsub(idIgnore, idExit) -- NULLIFY PREEXISTING NEWLINE TAGS
        for k = 1, w:len() do
        -- Char Processing
          if w:sub(k,k) == " " then space = space + 1 
            else 
              if space > 3 then
                
              else space = 0 end
            end
        end
        
        if s ~= "" then s = s .. idNewLine end
        s = s .. w
      end
    end
  end
  
  -- Output
  f:write(s):flush():close()
end

function Collection:extract(l)
  
end

function Collection:is(l)
  for i,v in ipairs(self.l) do
    if v == l then return true end
  end
  return false
end

function Collection:list()
  return self.l
end

function listAll(d)
  return newCollection(d):list()
end