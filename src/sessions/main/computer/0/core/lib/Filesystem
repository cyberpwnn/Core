local PATH = CPI.getPath()
local r = "r"
local w = "w"
local a = "a"
local b = "b"

local n = true

local loaded = {}

local File = CPI.object()
local Archive = CPI.object()

-- Remove safeguard when issue #2 is fixed
CPI.onStop(function() closeAll() end)

function open(d, m)
  local self = CPI.object(File)
  self.d = d
  self.m = m
  self.i = #loaded +1
  
  table.insert(loaded, {self.d, fs.open(d,m)})
  CPI.wrn("Opened " .. d)
  
  return self
end

function File:write(s) loaded[self.i][2].write(s) return self end
function File:writeLine(s) loaded[self.i][2].writeLine(s) return self end
function File:read() return loaded[self.i][2].read() end
function File:readAll() return loaded[self.i][2].readAll() end
function File:readLine() return loaded[self.i][2].readLine() end
function File:close(s) loaded[self.i][2].close() loaded[self.i] = nil end
function File:flush(s) loaded[self.i][2].flush() return self end

function closeAll()
  local loadedv = loaded
  CPI.inf("Filesystem: Closing "..#loadedv .. " Files")
  for i,v in ipairs(loadedv) do
    CPI.vrb("Filesystem: Closing File " .. v[1])
    v[2].close()
  end
end

function newArchive(d)
  local self = CPI.object(Archive)
  self.l = {}
  
  self:add(d)

  
  return self
end

function Archive:add(l)
  if fs.exists(l) then
    if fs.isDir(l) then
      for i,v in ipairs(fs.list(l)) do
        self:add(l.."/"..v)
      end
    end
    if not self:is(l) then
      if l:sub(1,2) == "//" then table.insert(self.l, l:sub(2)) else table.insert(self.l, l) end
    end
  end
end

function Archive:output(l)
  
end

function Archive:extract()
  
end

function Archive:is(l)
  for i,v in ipairs(self.l) do
    if v == l then return true end
  end
  return false
end

function Archive:list()
  return self.l
end
